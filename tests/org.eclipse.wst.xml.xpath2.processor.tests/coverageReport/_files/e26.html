<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://www.eclemma.org/">EMMA</A> Coverage Report (generated Tue Jun 09 19:59:05 GMT 2009)</TH></TR><TR><TD CLASS="nv">[<A HREF="../xslUnitTestCoverage.html">all classes</A>][<A HREF="144.html">org.eclipse.wst.jsdt.internal.corext.refactoring.rename</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">RenameAnalyzeUtil.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>RenameAnalyzeUtil.java</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/936)</TD><TD CLASS="h">0%   (0/208)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">RenameAnalyzeUtil</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/816)</TD><TD CLASS="h">0%   (0/177)</TD></TR><TR><TD CLASS="f"><A HREF="#0">RenameAnalyzeUtil (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">addReferenceShadowedError (IJavaScriptUnit, SearchMatch, String, RefactoringS...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/33)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#3">addShadowsError (IJavaScriptUnit, SearchMatch, RefactoringStatus): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/29)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">analyzeChanges (IJavaScriptUnit, TextChange, SearchMatch [], SearchMatch [], ...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/51)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#5">analyzeCompileErrors (String, JavaScriptUnit, JavaScriptUnit): RefactoringStatus</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/46)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">analyzeLocalRenames (RenameAnalyzeUtil$LocalAnalyzePackage [], TextChange, Ja...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/92)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR><TD CLASS="f"><A HREF="#7">analyzeRenameChanges (TextChangeManager, SearchResultGroup [], SearchResultGr...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/48)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">analyzeRenameChanges2 (TextChangeManager, SearchResultGroup [], SearchResultG...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/127)</TD><TD CLASS="h">0%   (0/26)</TD></TR><TR><TD CLASS="f"><A HREF="#9">createNewWorkingCopies (IJavaScriptUnit [], TextChangeManager, WorkingCopyOwn...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/37)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">createNewWorkingCopy (IJavaScriptUnit, TextChangeManager, WorkingCopyOwner, S...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#b">createTextRange (SearchMatch): IRegion</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">existsInNewOccurrences (SearchMatch, SearchResultGroup [], TextChangeManager)...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/41)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="f"><A HREF="#d">findOccurrenceGroup (IResource, SearchResultGroup []): SearchResultGroup</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">findWorkingCopyForCu (IJavaScriptUnit [], IJavaScriptUnit): IJavaScriptUnit</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#f">getCorrespondingEditChangeRange (SearchMatch, TextChangeManager): IRegion</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/39)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">getEditChangeOffsetUpdates (TextChange): Map</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/51)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="f"><A HREF="#11">getEnclosingBlockOrMethod (TextEdit, TextChange, JavaScriptUnit): ASTNode</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">getOldSourceRange (SearchMatch): ISourceRange</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#13">getTextChange (SearchMatch, TextChangeManager): TextChange</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">getUpdatedChangeOffsets (TextChange, SearchMatch []): Map</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/42)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#15">getVariableDeclaration (Name): VariableDeclaration</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/45)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#16">RenameAnalyzeUtil$LocalAnalyzePackage</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#16">RenameAnalyzeUtil$LocalAnalyzePackage (TextEdit, TextEdit []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#18">RenameAnalyzeUtil$ProblemNodeFinder</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#18">RenameAnalyzeUtil$ProblemNodeFinder (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">getProblemNodes (ASTNode, VariableDeclaration, TextEdit [], TextChange): Simp...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#1b">RenameAnalyzeUtil$ProblemNodeFinder$NameNodeVisitor</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/91)</TD><TD CLASS="h">0%   (0/21)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">RenameAnalyzeUtil$ProblemNodeFinder$NameNodeVisitor (TextEdit [], TextChange,...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1d">getProblemNodes (): SimpleName []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#1e">visit (SimpleName): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/57)</TD><TD CLASS="h">0%   (0/13)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/*******************************************************************************</TD></TR><TR><TD CLASS="l">2</TD><TD> * Copyright (c) 2000, 2008 IBM Corporation and others.</TD></TR><TR><TD CLASS="l">3</TD><TD> * All rights reserved. This program and the accompanying materials</TD></TR><TR><TD CLASS="l">4</TD><TD> * are made available under the terms of the Eclipse Public License v1.0</TD></TR><TR><TD CLASS="l">5</TD><TD> * which accompanies this distribution, and is available at</TD></TR><TR><TD CLASS="l">6</TD><TD> * http://www.eclipse.org/legal/epl-v10.html</TD></TR><TR><TD CLASS="l">7</TD><TD> *</TD></TR><TR><TD CLASS="l">8</TD><TD> * Contributors:</TD></TR><TR><TD CLASS="l">9</TD><TD> *     IBM Corporation - initial API and implementation</TD></TR><TR><TD CLASS="l">10</TD><TD> *******************************************************************************/</TD></TR><TR><TD CLASS="l">11</TD><TD>package org.eclipse.wst.jsdt.internal.corext.refactoring.rename;</TD></TR><TR><TD CLASS="l">12</TD><TD> </TD></TR><TR><TD CLASS="l">13</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">14</TD><TD>import java.util.Arrays;</TD></TR><TR><TD CLASS="l">15</TD><TD>import java.util.Collection;</TD></TR><TR><TD CLASS="l">16</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">17</TD><TD>import java.util.HashSet;</TD></TR><TR><TD CLASS="l">18</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">19</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">20</TD><TD>import java.util.Map.Entry;</TD></TR><TR><TD CLASS="l">21</TD><TD> </TD></TR><TR><TD CLASS="l">22</TD><TD>import org.eclipse.core.resources.IResource;</TD></TR><TR><TD CLASS="l">23</TD><TD>import org.eclipse.core.runtime.Assert;</TD></TR><TR><TD CLASS="l">24</TD><TD>import org.eclipse.core.runtime.CoreException;</TD></TR><TR><TD CLASS="l">25</TD><TD>import org.eclipse.core.runtime.NullProgressMonitor;</TD></TR><TR><TD CLASS="l">26</TD><TD>import org.eclipse.core.runtime.SubProgressMonitor;</TD></TR><TR><TD CLASS="l">27</TD><TD>import org.eclipse.jface.text.IRegion;</TD></TR><TR><TD CLASS="l">28</TD><TD>import org.eclipse.jface.text.Region;</TD></TR><TR><TD CLASS="l">29</TD><TD>import org.eclipse.ltk.core.refactoring.RefactoringStatus;</TD></TR><TR><TD CLASS="l">30</TD><TD>import org.eclipse.ltk.core.refactoring.RefactoringStatusContext;</TD></TR><TR><TD CLASS="l">31</TD><TD>import org.eclipse.ltk.core.refactoring.RefactoringStatusEntry;</TD></TR><TR><TD CLASS="l">32</TD><TD>import org.eclipse.ltk.core.refactoring.TextChange;</TD></TR><TR><TD CLASS="l">33</TD><TD>import org.eclipse.ltk.core.refactoring.TextEditChangeGroup;</TD></TR><TR><TD CLASS="l">34</TD><TD>import org.eclipse.text.edits.TextEdit;</TD></TR><TR><TD CLASS="l">35</TD><TD>import org.eclipse.wst.jsdt.core.IJavaScriptUnit;</TD></TR><TR><TD CLASS="l">36</TD><TD>import org.eclipse.wst.jsdt.core.IJavaScriptElement;</TD></TR><TR><TD CLASS="l">37</TD><TD>import org.eclipse.wst.jsdt.core.ISourceRange;</TD></TR><TR><TD CLASS="l">38</TD><TD>import org.eclipse.wst.jsdt.core.ISourceReference;</TD></TR><TR><TD CLASS="l">39</TD><TD>import org.eclipse.wst.jsdt.core.JavaScriptModelException;</TD></TR><TR><TD CLASS="l">40</TD><TD>import org.eclipse.wst.jsdt.core.WorkingCopyOwner;</TD></TR><TR><TD CLASS="l">41</TD><TD>import org.eclipse.wst.jsdt.core.compiler.IProblem;</TD></TR><TR><TD CLASS="l">42</TD><TD>import org.eclipse.wst.jsdt.core.dom.AST;</TD></TR><TR><TD CLASS="l">43</TD><TD>import org.eclipse.wst.jsdt.core.dom.ASTNode;</TD></TR><TR><TD CLASS="l">44</TD><TD>import org.eclipse.wst.jsdt.core.dom.ASTVisitor;</TD></TR><TR><TD CLASS="l">45</TD><TD>import org.eclipse.wst.jsdt.core.dom.JavaScriptUnit;</TD></TR><TR><TD CLASS="l">46</TD><TD>import org.eclipse.wst.jsdt.core.dom.IBinding;</TD></TR><TR><TD CLASS="l">47</TD><TD>import org.eclipse.wst.jsdt.core.dom.IVariableBinding;</TD></TR><TR><TD CLASS="l">48</TD><TD>import org.eclipse.wst.jsdt.core.dom.Name;</TD></TR><TR><TD CLASS="l">49</TD><TD>import org.eclipse.wst.jsdt.core.dom.SimpleName;</TD></TR><TR><TD CLASS="l">50</TD><TD>import org.eclipse.wst.jsdt.core.dom.VariableDeclaration;</TD></TR><TR><TD CLASS="l">51</TD><TD>import org.eclipse.wst.jsdt.core.search.FieldDeclarationMatch;</TD></TR><TR><TD CLASS="l">52</TD><TD>import org.eclipse.wst.jsdt.core.search.MethodDeclarationMatch;</TD></TR><TR><TD CLASS="l">53</TD><TD>import org.eclipse.wst.jsdt.core.search.SearchMatch;</TD></TR><TR><TD CLASS="l">54</TD><TD>import org.eclipse.wst.jsdt.internal.corext.SourceRange;</TD></TR><TR><TD CLASS="l">55</TD><TD>import org.eclipse.wst.jsdt.internal.corext.dom.ASTNodes;</TD></TR><TR><TD CLASS="l">56</TD><TD>import org.eclipse.wst.jsdt.internal.corext.dom.NodeFinder;</TD></TR><TR><TD CLASS="l">57</TD><TD>import org.eclipse.wst.jsdt.internal.corext.refactoring.RefactoringCoreMessages;</TD></TR><TR><TD CLASS="l">58</TD><TD>import org.eclipse.wst.jsdt.internal.corext.refactoring.SearchResultGroup;</TD></TR><TR><TD CLASS="l">59</TD><TD>import org.eclipse.wst.jsdt.internal.corext.refactoring.base.JavaStatusContext;</TD></TR><TR><TD CLASS="l">60</TD><TD>import org.eclipse.wst.jsdt.internal.corext.refactoring.base.JavaStringStatusContext;</TD></TR><TR><TD CLASS="l">61</TD><TD>import org.eclipse.wst.jsdt.internal.corext.refactoring.util.RefactoringASTParser;</TD></TR><TR><TD CLASS="l">62</TD><TD>import org.eclipse.wst.jsdt.internal.corext.refactoring.util.TextChangeManager;</TD></TR><TR><TD CLASS="l">63</TD><TD>import org.eclipse.wst.jsdt.internal.corext.util.Messages;</TD></TR><TR><TD CLASS="l">64</TD><TD>import org.eclipse.wst.jsdt.internal.corext.util.SearchUtils;</TD></TR><TR><TD CLASS="l">65</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="18">66</A></TD><TD>class RenameAnalyzeUtil {</TD></TR><TR><TD CLASS="l">67</TD><TD>        </TD></TR><TR><TD CLASS="l">68</TD><TD>        private static class ProblemNodeFinder {</TD></TR><TR><TD CLASS="l">69</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">70</TD><TD>                private ProblemNodeFinder() {</TD></TR><TR><TD CLASS="l"><A NAME="1a">71</A></TD><TD>                        //static</TD></TR><TR CLASS="z"><TD CLASS="l">72</TD><TD>                }</TD></TR><TR><TD CLASS="l">73</TD><TD>                </TD></TR><TR><TD CLASS="l">74</TD><TD>                public static SimpleName[] getProblemNodes(ASTNode methodNode, VariableDeclaration variableNode, TextEdit[] edits, TextChange change) {</TD></TR><TR CLASS="z"><TD CLASS="l">75</TD><TD>                        String key= variableNode.resolveBinding().getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">76</TD><TD>                        NameNodeVisitor visitor= new NameNodeVisitor(edits, change, key);</TD></TR><TR CLASS="z"><TD CLASS="l">77</TD><TD>                        methodNode.accept(visitor);</TD></TR><TR CLASS="z"><TD CLASS="l">78</TD><TD>                        return visitor.getProblemNodes();</TD></TR><TR><TD CLASS="l">79</TD><TD>                }</TD></TR><TR><TD CLASS="l">80</TD><TD>                </TD></TR><TR><TD CLASS="l">81</TD><TD>                private static class NameNodeVisitor extends ASTVisitor {</TD></TR><TR><TD CLASS="l">82</TD><TD>        </TD></TR><TR><TD CLASS="l"><A NAME="1b">83</A></TD><TD>                        private Collection fRanges;</TD></TR><TR><TD CLASS="l">84</TD><TD>                        private Collection fProblemNodes;</TD></TR><TR><TD CLASS="l">85</TD><TD>                        private String fKey;</TD></TR><TR><TD CLASS="l">86</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">87</TD><TD>                        public NameNodeVisitor(TextEdit[] edits, TextChange change, String key) {</TD></TR><TR CLASS="z"><TD CLASS="l">88</TD><TD>                                Assert.isNotNull(edits);</TD></TR><TR CLASS="z"><TD CLASS="l">89</TD><TD>                                Assert.isNotNull(key);</TD></TR><TR><TD CLASS="l">90</TD><TD>                                </TD></TR><TR CLASS="z"><TD CLASS="l">91</TD><TD>                                fRanges= new HashSet(Arrays.asList(RefactoringAnalyzeUtil.getNewRanges(edits, change)));</TD></TR><TR CLASS="z"><TD CLASS="l">92</TD><TD>                                fProblemNodes= new ArrayList(0);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1d">93</A></TD><TD>                                fKey= key;</TD></TR><TR CLASS="z"><TD CLASS="l">94</TD><TD>                        }</TD></TR><TR><TD CLASS="l">95</TD><TD>        </TD></TR><TR><TD CLASS="l">96</TD><TD>                        public SimpleName[] getProblemNodes() {</TD></TR><TR CLASS="z"><TD CLASS="l">97</TD><TD>                                return (SimpleName[]) fProblemNodes.toArray(new SimpleName[fProblemNodes.size()]);</TD></TR><TR><TD CLASS="l">98</TD><TD>                        }</TD></TR><TR><TD CLASS="l"><A NAME="1e">99</A></TD><TD>        </TD></TR><TR><TD CLASS="l">100</TD><TD>                        //----- visit methods </TD></TR><TR><TD CLASS="l">101</TD><TD>        </TD></TR><TR><TD CLASS="l">102</TD><TD>                        public boolean visit(SimpleName node) {</TD></TR><TR CLASS="z"><TD CLASS="l">103</TD><TD>                                VariableDeclaration decl= getVariableDeclaration(node);</TD></TR><TR CLASS="z"><TD CLASS="l">104</TD><TD>                                if (decl == null)</TD></TR><TR CLASS="z"><TD CLASS="l">105</TD><TD>                                        return super.visit(node);</TD></TR><TR><TD CLASS="l">106</TD><TD>                                </TD></TR><TR CLASS="z"><TD CLASS="l">107</TD><TD>                                IVariableBinding binding= decl.resolveBinding();</TD></TR><TR CLASS="z"><TD CLASS="l">108</TD><TD>                                if (binding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">109</TD><TD>                                        return super.visit(node);</TD></TR><TR><TD CLASS="l">110</TD><TD>                                </TD></TR><TR CLASS="z"><TD CLASS="l">111</TD><TD>                                boolean keysEqual= fKey.equals(binding.getKey()); </TD></TR><TR CLASS="z"><TD CLASS="l">112</TD><TD>                                boolean rangeInSet= fRanges.contains(new Region(node.getStartPosition(), node.getLength()));</TD></TR><TR><TD CLASS="l">113</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">114</TD><TD>                                if (keysEqual &amp;&amp; !rangeInSet)</TD></TR><TR CLASS="z"><TD CLASS="l">115</TD><TD>                                        fProblemNodes.add(node);</TD></TR><TR><TD CLASS="l">116</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">117</TD><TD>                                if (!keysEqual &amp;&amp; rangeInSet)</TD></TR><TR CLASS="z"><TD CLASS="l">118</TD><TD>                                        fProblemNodes.add(node);</TD></TR><TR><TD CLASS="l">119</TD><TD>                                </TD></TR><TR><TD CLASS="l">120</TD><TD>                                /*</TD></TR><TR><TD CLASS="l">121</TD><TD>                                 * if (!keyEquals &amp;&amp; !rangeInSet) </TD></TR><TR><TD CLASS="l">122</TD><TD>                                 *                 ok, different local variable.</TD></TR><TR><TD CLASS="l">123</TD><TD>                                 * </TD></TR><TR><TD CLASS="l">124</TD><TD>                                 * if (keyEquals &amp;&amp; rangeInSet) </TD></TR><TR><TD CLASS="l">125</TD><TD>                                 *                 ok, renamed local variable &amp; has been renamed.</TD></TR><TR><TD CLASS="l">126</TD><TD>                                 */</TD></TR><TR><TD CLASS="l">127</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">128</TD><TD>                                return super.visit(node);</TD></TR><TR><TD CLASS="l">129</TD><TD>                        }</TD></TR><TR><TD CLASS="l">130</TD><TD>                }</TD></TR><TR><TD CLASS="l">131</TD><TD>        }</TD></TR><TR><TD CLASS="l">132</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="16">133</A></TD><TD>        static class LocalAnalyzePackage {</TD></TR><TR><TD CLASS="l">134</TD><TD>                public final TextEdit fDeclarationEdit;</TD></TR><TR><TD CLASS="l">135</TD><TD>                public final TextEdit[] fOccurenceEdits;</TD></TR><TR><TD CLASS="l">136</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">137</TD><TD>                public LocalAnalyzePackage(final TextEdit declarationEdit, final TextEdit[] occurenceEdits) {</TD></TR><TR CLASS="z"><TD CLASS="l">138</TD><TD>                        fDeclarationEdit = declarationEdit;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="0">139</A></TD><TD>                        fOccurenceEdits = occurenceEdits;</TD></TR><TR CLASS="z"><TD CLASS="l">140</TD><TD>                }</TD></TR><TR><TD CLASS="l">141</TD><TD>        }</TD></TR><TR><TD CLASS="l">142</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">143</TD><TD>        private RenameAnalyzeUtil() {</TD></TR><TR><TD CLASS="l"><A NAME="7">144</A></TD><TD>                //no instance</TD></TR><TR CLASS="z"><TD CLASS="l">145</TD><TD>        }</TD></TR><TR><TD CLASS="l">146</TD><TD>        </TD></TR><TR><TD CLASS="l">147</TD><TD>        static RefactoringStatus analyzeRenameChanges(TextChangeManager manager,  SearchResultGroup[] oldOccurrences, SearchResultGroup[] newOccurrences) {</TD></TR><TR CLASS="z"><TD CLASS="l">148</TD><TD>                RefactoringStatus result= new RefactoringStatus();</TD></TR><TR CLASS="z"><TD CLASS="l">149</TD><TD>                for (int i= 0; i &lt; oldOccurrences.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">150</TD><TD>                        SearchResultGroup oldGroup= oldOccurrences[i];</TD></TR><TR CLASS="z"><TD CLASS="l">151</TD><TD>                        SearchMatch[] oldSearchResults= oldGroup.getSearchResults();</TD></TR><TR CLASS="z"><TD CLASS="l">152</TD><TD>                        IJavaScriptUnit cunit= oldGroup.getCompilationUnit();</TD></TR><TR CLASS="z"><TD CLASS="l">153</TD><TD>                        if (cunit == null)</TD></TR><TR CLASS="z"><TD CLASS="l">154</TD><TD>                                continue;</TD></TR><TR CLASS="z"><TD CLASS="l">155</TD><TD>                        for (int j= 0; j &lt; oldSearchResults.length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">156</TD><TD>                                SearchMatch oldSearchResult= oldSearchResults[j];</TD></TR><TR CLASS="z"><TD CLASS="l">157</TD><TD>                                if (! RenameAnalyzeUtil.existsInNewOccurrences(oldSearchResult, newOccurrences, manager)){</TD></TR><TR CLASS="z"><TD CLASS="l">158</TD><TD>                                        addShadowsError(cunit, oldSearchResult, result);</TD></TR><TR><TD CLASS="l">159</TD><TD>                                }        </TD></TR><TR><TD CLASS="l">160</TD><TD>                        }</TD></TR><TR><TD CLASS="l">161</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="e">162</A></TD><TD>                return result;</TD></TR><TR><TD CLASS="l">163</TD><TD>        }</TD></TR><TR><TD CLASS="l">164</TD><TD> </TD></TR><TR><TD CLASS="l">165</TD><TD>        static IJavaScriptUnit findWorkingCopyForCu(IJavaScriptUnit[] newWorkingCopies, IJavaScriptUnit cu){</TD></TR><TR CLASS="z"><TD CLASS="l">166</TD><TD>                IJavaScriptUnit original= cu == null ? null : cu.getPrimary();</TD></TR><TR CLASS="z"><TD CLASS="l">167</TD><TD>                for (int i= 0; i &lt; newWorkingCopies.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">168</TD><TD>                        if (newWorkingCopies[i].getPrimary().equals(original))</TD></TR><TR CLASS="z"><TD CLASS="l">169</TD><TD>                                return newWorkingCopies[i];</TD></TR><TR><TD CLASS="l">170</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="9">171</A></TD><TD>                return null;</TD></TR><TR><TD CLASS="l">172</TD><TD>        }</TD></TR><TR><TD CLASS="l">173</TD><TD> </TD></TR><TR><TD CLASS="l">174</TD><TD>        static IJavaScriptUnit[] createNewWorkingCopies(IJavaScriptUnit[] compilationUnitsToModify, TextChangeManager manager, WorkingCopyOwner owner, SubProgressMonitor pm) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">175</TD><TD>                pm.beginTask(&#34;&#34;, compilationUnitsToModify.length); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">176</TD><TD>                IJavaScriptUnit[] newWorkingCopies= new IJavaScriptUnit[compilationUnitsToModify.length];</TD></TR><TR CLASS="z"><TD CLASS="l">177</TD><TD>                for (int i= 0; i &lt; compilationUnitsToModify.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>                        IJavaScriptUnit cu= compilationUnitsToModify[i];</TD></TR><TR CLASS="z"><TD CLASS="l">179</TD><TD>                        newWorkingCopies[i]= createNewWorkingCopy(cu, manager, owner, new SubProgressMonitor(pm, 1));</TD></TR><TR><TD CLASS="l">180</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">181</TD><TD>                pm.done();</TD></TR><TR CLASS="z"><TD CLASS="l">182</TD><TD>                return newWorkingCopies;</TD></TR><TR><TD CLASS="l"><A NAME="a">183</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">184</TD><TD>        </TD></TR><TR><TD CLASS="l">185</TD><TD>        static IJavaScriptUnit createNewWorkingCopy(IJavaScriptUnit cu, TextChangeManager manager,</TD></TR><TR><TD CLASS="l">186</TD><TD>                        WorkingCopyOwner owner, SubProgressMonitor pm) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">187</TD><TD>                IJavaScriptUnit newWc= cu.getWorkingCopy(owner, null, null);</TD></TR><TR CLASS="z"><TD CLASS="l">188</TD><TD>                String previewContent= manager.get(cu).getPreviewContent(new NullProgressMonitor());</TD></TR><TR CLASS="z"><TD CLASS="l">189</TD><TD>                newWc.getBuffer().setContents(previewContent);</TD></TR><TR CLASS="z"><TD CLASS="l">190</TD><TD>                newWc.reconcile(IJavaScriptUnit.NO_AST, false, owner, pm);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="c">191</A></TD><TD>                return newWc;</TD></TR><TR><TD CLASS="l">192</TD><TD>        }</TD></TR><TR><TD CLASS="l">193</TD><TD>        </TD></TR><TR><TD CLASS="l">194</TD><TD>        private static boolean existsInNewOccurrences(SearchMatch searchResult, SearchResultGroup[] newOccurrences, TextChangeManager manager) {</TD></TR><TR CLASS="z"><TD CLASS="l">195</TD><TD>                SearchResultGroup newGroup= findOccurrenceGroup(searchResult.getResource(), newOccurrences);</TD></TR><TR CLASS="z"><TD CLASS="l">196</TD><TD>                if (newGroup == null)</TD></TR><TR CLASS="z"><TD CLASS="l">197</TD><TD>                        return false;</TD></TR><TR><TD CLASS="l">198</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">199</TD><TD>                IRegion oldEditRange= getCorrespondingEditChangeRange(searchResult, manager);</TD></TR><TR CLASS="z"><TD CLASS="l">200</TD><TD>                if (oldEditRange == null)</TD></TR><TR CLASS="z"><TD CLASS="l">201</TD><TD>                        return false;</TD></TR><TR><TD CLASS="l">202</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">203</TD><TD>                SearchMatch[] newSearchResults= newGroup.getSearchResults();</TD></TR><TR CLASS="z"><TD CLASS="l">204</TD><TD>                int oldRangeOffset = oldEditRange.getOffset();</TD></TR><TR CLASS="z"><TD CLASS="l">205</TD><TD>                for (int i= 0; i &lt; newSearchResults.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">206</TD><TD>                        if (newSearchResults[i].getOffset() == oldRangeOffset)</TD></TR><TR CLASS="z"><TD CLASS="l">207</TD><TD>                                return true;</TD></TR><TR><TD CLASS="l">208</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="f">209</A></TD><TD>                return false;</TD></TR><TR><TD CLASS="l">210</TD><TD>        }</TD></TR><TR><TD CLASS="l">211</TD><TD>        </TD></TR><TR><TD CLASS="l">212</TD><TD>        private static IRegion getCorrespondingEditChangeRange(SearchMatch searchResult, TextChangeManager manager) {</TD></TR><TR CLASS="z"><TD CLASS="l">213</TD><TD>                TextChange change= getTextChange(searchResult, manager);</TD></TR><TR CLASS="z"><TD CLASS="l">214</TD><TD>                if (change == null)</TD></TR><TR CLASS="z"><TD CLASS="l">215</TD><TD>                        return null;</TD></TR><TR><TD CLASS="l">216</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">217</TD><TD>                IRegion oldMatchRange= createTextRange(searchResult);</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>                TextEditChangeGroup[] editChanges= change.getTextEditChangeGroups();        </TD></TR><TR CLASS="z"><TD CLASS="l">219</TD><TD>                for (int i= 0; i &lt; editChanges.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">220</TD><TD>                        if (oldMatchRange.equals(editChanges[i].getRegion()))</TD></TR><TR CLASS="z"><TD CLASS="l">221</TD><TD>                                return TextEdit.getCoverage(change.getPreviewEdits(editChanges[i].getTextEdits()));</TD></TR><TR><TD CLASS="l">222</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="13">223</A></TD><TD>                return null;</TD></TR><TR><TD CLASS="l">224</TD><TD>        }</TD></TR><TR><TD CLASS="l">225</TD><TD>        </TD></TR><TR><TD CLASS="l">226</TD><TD>        private static TextChange getTextChange(SearchMatch searchResult, TextChangeManager manager) {</TD></TR><TR CLASS="z"><TD CLASS="l">227</TD><TD>                IJavaScriptUnit cu= SearchUtils.getCompilationUnit(searchResult);</TD></TR><TR CLASS="z"><TD CLASS="l">228</TD><TD>                if (cu == null)</TD></TR><TR CLASS="z"><TD CLASS="l">229</TD><TD>                        return null;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="b">230</A></TD><TD>                return manager.get(cu);</TD></TR><TR><TD CLASS="l">231</TD><TD>        }</TD></TR><TR><TD CLASS="l">232</TD><TD>        </TD></TR><TR><TD CLASS="l">233</TD><TD>        private static IRegion createTextRange(SearchMatch searchResult) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="d">234</A></TD><TD>                return new Region(searchResult.getOffset(), searchResult.getLength());</TD></TR><TR><TD CLASS="l">235</TD><TD>        }</TD></TR><TR><TD CLASS="l">236</TD><TD>        </TD></TR><TR><TD CLASS="l">237</TD><TD>        private static SearchResultGroup findOccurrenceGroup(IResource resource, SearchResultGroup[] newOccurrences) {</TD></TR><TR CLASS="z"><TD CLASS="l">238</TD><TD>                for (int i= 0; i &lt; newOccurrences.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">239</TD><TD>                        if (newOccurrences[i].getResource().equals(resource))</TD></TR><TR CLASS="z"><TD CLASS="l">240</TD><TD>                                return newOccurrences[i];</TD></TR><TR><TD CLASS="l">241</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">242</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">243</TD><TD>        }</TD></TR><TR><TD CLASS="l">244</TD><TD>        </TD></TR><TR><TD CLASS="l">245</TD><TD>//--- find missing changes in BOTH directions</TD></TR><TR><TD CLASS="l">246</TD><TD>        </TD></TR><TR><TD CLASS="l"><A NAME="8">247</A></TD><TD>        //TODO: Currently filters out declarations (MethodDeclarationMatch, FieldDeclarationMatch).</TD></TR><TR><TD CLASS="l">248</TD><TD>        //Long term solution: only pass reference search results in.</TD></TR><TR><TD CLASS="l">249</TD><TD>        static RefactoringStatus analyzeRenameChanges2(TextChangeManager manager,</TD></TR><TR><TD CLASS="l">250</TD><TD>                        SearchResultGroup[] oldReferences, SearchResultGroup[] newReferences, String newElementName) {</TD></TR><TR CLASS="z"><TD CLASS="l">251</TD><TD>                RefactoringStatus result= new RefactoringStatus();</TD></TR><TR><TD CLASS="l">252</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">253</TD><TD>                HashMap cuToNewResults= new HashMap(newReferences.length);</TD></TR><TR CLASS="z"><TD CLASS="l">254</TD><TD>                for (int i1= 0; i1 &lt; newReferences.length; i1++) {</TD></TR><TR CLASS="z"><TD CLASS="l">255</TD><TD>                        IJavaScriptUnit cu= newReferences[i1].getCompilationUnit();</TD></TR><TR CLASS="z"><TD CLASS="l">256</TD><TD>                        if (cu != null)</TD></TR><TR CLASS="z"><TD CLASS="l">257</TD><TD>                                cuToNewResults.put(cu.getPrimary(), newReferences[i1].getSearchResults());</TD></TR><TR><TD CLASS="l">258</TD><TD>                }</TD></TR><TR><TD CLASS="l">259</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">260</TD><TD>                for (int i= 0; i &lt; oldReferences.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">261</TD><TD>                        SearchResultGroup oldGroup= oldReferences[i];</TD></TR><TR CLASS="z"><TD CLASS="l">262</TD><TD>                        SearchMatch[] oldMatches= oldGroup.getSearchResults();</TD></TR><TR CLASS="z"><TD CLASS="l">263</TD><TD>                        IJavaScriptUnit cu= oldGroup.getCompilationUnit();</TD></TR><TR CLASS="z"><TD CLASS="l">264</TD><TD>                        if (cu == null)</TD></TR><TR CLASS="z"><TD CLASS="l">265</TD><TD>                                continue;</TD></TR><TR><TD CLASS="l">266</TD><TD>                        </TD></TR><TR CLASS="z"><TD CLASS="l">267</TD><TD>                        SearchMatch[] newSearchMatches= (SearchMatch[]) cuToNewResults.remove(cu);</TD></TR><TR CLASS="z"><TD CLASS="l">268</TD><TD>                        if (newSearchMatches == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">269</TD><TD>                                for (int j = 0; j &lt; oldMatches.length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">270</TD><TD>                                        SearchMatch oldMatch = oldMatches[j];</TD></TR><TR CLASS="z"><TD CLASS="l">271</TD><TD>                                        addShadowsError(cu, oldMatch, result);</TD></TR><TR><TD CLASS="l">272</TD><TD>                                }</TD></TR><TR><TD CLASS="l">273</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">274</TD><TD>                                analyzeChanges(cu, manager.get(cu), oldMatches, newSearchMatches, newElementName, result);</TD></TR><TR><TD CLASS="l">275</TD><TD>                        }</TD></TR><TR><TD CLASS="l">276</TD><TD>                }</TD></TR><TR><TD CLASS="l">277</TD><TD>                </TD></TR><TR CLASS="z"><TD CLASS="l">278</TD><TD>                for (Iterator iter= cuToNewResults.entrySet().iterator(); iter.hasNext();) {</TD></TR><TR CLASS="z"><TD CLASS="l">279</TD><TD>                        Map.Entry entry= (Entry) iter.next();</TD></TR><TR CLASS="z"><TD CLASS="l">280</TD><TD>                        IJavaScriptUnit cu= (IJavaScriptUnit) entry.getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>                        SearchMatch[] newSearchMatches= (SearchMatch[]) entry.getValue();</TD></TR><TR CLASS="z"><TD CLASS="l">282</TD><TD>                        for (int i= 0; i &lt; newSearchMatches.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">283</TD><TD>                                SearchMatch newMatch= newSearchMatches[i];</TD></TR><TR CLASS="z"><TD CLASS="l">284</TD><TD>                                addReferenceShadowedError(cu, newMatch, newElementName, result);</TD></TR><TR><TD CLASS="l">285</TD><TD>                        }</TD></TR><TR><TD CLASS="l">286</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">287</TD><TD>                return result;</TD></TR><TR><TD CLASS="l"><A NAME="4">288</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">289</TD><TD> </TD></TR><TR><TD CLASS="l">290</TD><TD>        private static void analyzeChanges(IJavaScriptUnit cu, TextChange change,</TD></TR><TR><TD CLASS="l">291</TD><TD>                        SearchMatch[] oldMatches, SearchMatch[] newMatches, String newElementName, RefactoringStatus result) {</TD></TR><TR CLASS="z"><TD CLASS="l">292</TD><TD>                Map updatedOldOffsets= getUpdatedChangeOffsets(change, oldMatches);</TD></TR><TR CLASS="z"><TD CLASS="l">293</TD><TD>                for (int i= 0; i &lt; newMatches.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">294</TD><TD>                        SearchMatch newMatch= newMatches[i];</TD></TR><TR CLASS="z"><TD CLASS="l">295</TD><TD>                        Integer offsetInNew= new Integer(newMatch.getOffset());</TD></TR><TR CLASS="z"><TD CLASS="l">296</TD><TD>                        SearchMatch oldMatch= (SearchMatch) updatedOldOffsets.remove(offsetInNew);</TD></TR><TR CLASS="z"><TD CLASS="l">297</TD><TD>                        if (oldMatch == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">298</TD><TD>                                addReferenceShadowedError(cu, newMatch, newElementName, result);</TD></TR><TR><TD CLASS="l">299</TD><TD>                        }</TD></TR><TR><TD CLASS="l">300</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">301</TD><TD>                for (Iterator iter= updatedOldOffsets.values().iterator(); iter.hasNext();) {</TD></TR><TR><TD CLASS="l">302</TD><TD>                        // remaining old matches are not found any more -&gt; they have been shadowed</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>                        SearchMatch oldMatch= (SearchMatch) iter.next();</TD></TR><TR CLASS="z"><TD CLASS="l">304</TD><TD>                        addShadowsError(cu, oldMatch, result);</TD></TR><TR><TD CLASS="l">305</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="14">306</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">307</TD><TD>        </TD></TR><TR><TD CLASS="l">308</TD><TD>        /** @return Map &amp;lt;Integer updatedOffset, SearchMatch oldMatch&amp;gt; */</TD></TR><TR><TD CLASS="l">309</TD><TD>        private static Map getUpdatedChangeOffsets(TextChange change, SearchMatch[] oldMatches) {</TD></TR><TR CLASS="z"><TD CLASS="l">310</TD><TD>                Map/*&lt;Integer updatedOffset, SearchMatch oldMatch&gt;*/ updatedOffsets= new HashMap();</TD></TR><TR CLASS="z"><TD CLASS="l">311</TD><TD>                Map oldToUpdatedOffsets= getEditChangeOffsetUpdates(change);</TD></TR><TR CLASS="z"><TD CLASS="l">312</TD><TD>                for (int i= 0; i &lt; oldMatches.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">313</TD><TD>                        SearchMatch oldMatch= oldMatches[i];</TD></TR><TR CLASS="z"><TD CLASS="l">314</TD><TD>                        Integer updatedOffset= (Integer) oldToUpdatedOffsets.get(new Integer(oldMatch.getOffset()));</TD></TR><TR CLASS="z"><TD CLASS="l">315</TD><TD>                        if (updatedOffset == null)</TD></TR><TR CLASS="z"><TD CLASS="l">316</TD><TD>                                updatedOffset= new Integer(-1); //match not updated</TD></TR><TR CLASS="z"><TD CLASS="l">317</TD><TD>                        updatedOffsets.put(updatedOffset, oldMatch);</TD></TR><TR><TD CLASS="l">318</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">319</TD><TD>                return updatedOffsets;</TD></TR><TR><TD CLASS="l"><A NAME="10">320</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">321</TD><TD> </TD></TR><TR><TD CLASS="l">322</TD><TD>        /** @return Map &amp;lt;Integer oldOffset, Integer updatedOffset&amp;gt; */</TD></TR><TR><TD CLASS="l">323</TD><TD>        private static Map getEditChangeOffsetUpdates(TextChange change) {</TD></TR><TR CLASS="z"><TD CLASS="l">324</TD><TD>                TextEditChangeGroup[] editChanges= change.getTextEditChangeGroups();</TD></TR><TR CLASS="z"><TD CLASS="l">325</TD><TD>                Map/*&lt;oldOffset, newOffset&gt;*/ offsetUpdates= new HashMap(editChanges.length);</TD></TR><TR CLASS="z"><TD CLASS="l">326</TD><TD>                for (int i= 0; i &lt; editChanges.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">327</TD><TD>                        TextEditChangeGroup editChange= editChanges[i];</TD></TR><TR CLASS="z"><TD CLASS="l">328</TD><TD>                        IRegion oldRegion= editChange.getRegion();</TD></TR><TR CLASS="z"><TD CLASS="l">329</TD><TD>                        if (oldRegion == null)</TD></TR><TR CLASS="z"><TD CLASS="l">330</TD><TD>                                continue;</TD></TR><TR CLASS="z"><TD CLASS="l">331</TD><TD>                        IRegion updatedRegion= TextEdit.getCoverage(change.getPreviewEdits(editChange.getTextEdits()));</TD></TR><TR CLASS="z"><TD CLASS="l">332</TD><TD>                        if (updatedRegion == null)</TD></TR><TR CLASS="z"><TD CLASS="l">333</TD><TD>                                continue;</TD></TR><TR><TD CLASS="l">334</TD><TD>                        </TD></TR><TR CLASS="z"><TD CLASS="l">335</TD><TD>                        offsetUpdates.put(new Integer(oldRegion.getOffset()), new Integer(updatedRegion.getOffset()));</TD></TR><TR><TD CLASS="l">336</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">337</TD><TD>                return offsetUpdates;</TD></TR><TR><TD CLASS="l">338</TD><TD>        }</TD></TR><TR><TD CLASS="l">339</TD><TD> </TD></TR><TR><TD CLASS="l">340</TD><TD>        private static void addReferenceShadowedError(IJavaScriptUnit cu, SearchMatch newMatch, String newElementName, RefactoringStatus result) {</TD></TR><TR><TD CLASS="l">341</TD><TD>                //Found a new match with no corresponding old match.</TD></TR><TR><TD CLASS="l"><A NAME="2">342</A></TD><TD>                //-&gt; The new match is a reference which was pointing to another element,</TD></TR><TR><TD CLASS="l">343</TD><TD>                //but that other element has been shadowed</TD></TR><TR><TD CLASS="l">344</TD><TD>                </TD></TR><TR><TD CLASS="l">345</TD><TD>                //TODO: should not have to filter declarations:</TD></TR><TR CLASS="z"><TD CLASS="l">346</TD><TD>                if (newMatch instanceof MethodDeclarationMatch || newMatch instanceof FieldDeclarationMatch)</TD></TR><TR CLASS="z"><TD CLASS="l">347</TD><TD>                        return;</TD></TR><TR CLASS="z"><TD CLASS="l">348</TD><TD>                ISourceRange range= getOldSourceRange(newMatch);</TD></TR><TR CLASS="z"><TD CLASS="l">349</TD><TD>                RefactoringStatusContext context= JavaStatusContext.create(cu, range);</TD></TR><TR CLASS="z"><TD CLASS="l">350</TD><TD>                String message= Messages.format(</TD></TR><TR CLASS="z"><TD CLASS="l">351</TD><TD>                                RefactoringCoreMessages.RenameAnalyzeUtil_reference_shadowed, </TD></TR><TR CLASS="z"><TD CLASS="l">352</TD><TD>                                new String[] {cu.getElementName(), newElementName});</TD></TR><TR CLASS="z"><TD CLASS="l">353</TD><TD>                result.addError(message, context);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="12">354</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">355</TD><TD> </TD></TR><TR><TD CLASS="l">356</TD><TD>        private static ISourceRange getOldSourceRange(SearchMatch newMatch) {</TD></TR><TR><TD CLASS="l">357</TD><TD>                // cannot transfom offset in preview to offset in original -&gt; just show enclosing method</TD></TR><TR CLASS="z"><TD CLASS="l">358</TD><TD>                IJavaScriptElement newMatchElement= (IJavaScriptElement) newMatch.getElement();</TD></TR><TR CLASS="z"><TD CLASS="l">359</TD><TD>                IJavaScriptElement primaryElement= newMatchElement.getPrimaryElement();</TD></TR><TR CLASS="z"><TD CLASS="l">360</TD><TD>                ISourceRange range= null;</TD></TR><TR CLASS="z"><TD CLASS="l">361</TD><TD>                if (primaryElement.exists() &amp;&amp; primaryElement instanceof ISourceReference) {</TD></TR><TR><TD CLASS="l">362</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">363</TD><TD>                                range= ((ISourceReference) primaryElement).getSourceRange();</TD></TR><TR CLASS="z"><TD CLASS="l">364</TD><TD>                        } catch (JavaScriptModelException e) {</TD></TR><TR><TD CLASS="l">365</TD><TD>                                // can live without source range</TD></TR><TR><TD CLASS="l">366</TD><TD>                        }</TD></TR><TR><TD CLASS="l">367</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">368</TD><TD>                return range;</TD></TR><TR><TD CLASS="l">369</TD><TD>        }</TD></TR><TR><TD CLASS="l">370</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="3">371</A></TD><TD>        private static void addShadowsError(IJavaScriptUnit cu, SearchMatch oldMatch, RefactoringStatus result) {</TD></TR><TR><TD CLASS="l">372</TD><TD>                // Old match not found in new matches -&gt; reference has been shadowed</TD></TR><TR><TD CLASS="l">373</TD><TD>                </TD></TR><TR><TD CLASS="l">374</TD><TD>                //TODO: should not have to filter declarations:</TD></TR><TR CLASS="z"><TD CLASS="l">375</TD><TD>                if (oldMatch instanceof MethodDeclarationMatch || oldMatch instanceof FieldDeclarationMatch)</TD></TR><TR CLASS="z"><TD CLASS="l">376</TD><TD>                        return;</TD></TR><TR CLASS="z"><TD CLASS="l">377</TD><TD>                ISourceRange range= new SourceRange(oldMatch.getOffset(), oldMatch.getLength());</TD></TR><TR CLASS="z"><TD CLASS="l">378</TD><TD>                RefactoringStatusContext context= JavaStatusContext.create(cu, range);</TD></TR><TR CLASS="z"><TD CLASS="l">379</TD><TD>                String message= Messages.format(RefactoringCoreMessages.RenameAnalyzeUtil_shadows, cu.getElementName()); </TD></TR><TR CLASS="z"><TD CLASS="l">380</TD><TD>                result.addError(message, context);</TD></TR><TR CLASS="z"><TD CLASS="l">381</TD><TD>        }</TD></TR><TR><TD CLASS="l">382</TD><TD> </TD></TR><TR><TD CLASS="l">383</TD><TD>        /**</TD></TR><TR><TD CLASS="l">384</TD><TD>         * This method analyzes a set of local variable renames inside one cu. It checks whether</TD></TR><TR><TD CLASS="l">385</TD><TD>         * any new compile errors have been introduced by the rename(s) and whether the correct</TD></TR><TR><TD CLASS="l">386</TD><TD>         * node(s) has/have been renamed.</TD></TR><TR><TD CLASS="l">387</TD><TD>         * </TD></TR><TR><TD CLASS="l">388</TD><TD>         * @param analyzePackages the LocalAnalyzePackages containing the information about the local renames</TD></TR><TR><TD CLASS="l">389</TD><TD>         * @param cuChange the TextChange containing all local variable changes to be applied.</TD></TR><TR><TD CLASS="l">390</TD><TD>         * @param oldCUNode the fully (incl. bindings) resolved AST node of the original compilation unit</TD></TR><TR><TD CLASS="l">391</TD><TD>         * @param statementsRecovery whether statements recovery should be performed when parsing the changed CU</TD></TR><TR><TD CLASS="l">392</TD><TD>         * @return a RefactoringStatus containing errors if compile errors or wrongly renamed nodes are found</TD></TR><TR><TD CLASS="l"><A NAME="6">393</A></TD><TD>         * @throws CoreException thrown if there was an error greating the preview content of the change</TD></TR><TR><TD CLASS="l">394</TD><TD>         */</TD></TR><TR><TD CLASS="l">395</TD><TD>        public static RefactoringStatus analyzeLocalRenames(LocalAnalyzePackage[] analyzePackages, TextChange cuChange, JavaScriptUnit oldCUNode, boolean statementsRecovery) throws CoreException {</TD></TR><TR><TD CLASS="l">396</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">397</TD><TD>                RefactoringStatus result= new RefactoringStatus();</TD></TR><TR CLASS="z"><TD CLASS="l">398</TD><TD>                IJavaScriptUnit compilationUnit= (IJavaScriptUnit) oldCUNode.getJavaElement();</TD></TR><TR><TD CLASS="l">399</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">400</TD><TD>                String newCuSource= cuChange.getPreviewContent(new NullProgressMonitor());</TD></TR><TR CLASS="z"><TD CLASS="l">401</TD><TD>                JavaScriptUnit newCUNode= new RefactoringASTParser(AST.JLS3).parse(newCuSource, compilationUnit, true, statementsRecovery, null);</TD></TR><TR><TD CLASS="l">402</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">403</TD><TD>                result.merge(analyzeCompileErrors(newCuSource, newCUNode, oldCUNode));</TD></TR><TR CLASS="z"><TD CLASS="l">404</TD><TD>                if (result.hasError())</TD></TR><TR CLASS="z"><TD CLASS="l">405</TD><TD>                        return result;</TD></TR><TR><TD CLASS="l">406</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">407</TD><TD>                for (int i= 0; i &lt; analyzePackages.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">408</TD><TD>                        ASTNode enclosing= getEnclosingBlockOrMethod(analyzePackages[i].fDeclarationEdit, cuChange, newCUNode);</TD></TR><TR><TD CLASS="l">409</TD><TD> </TD></TR><TR><TD CLASS="l">410</TD><TD>                        // get new declaration</TD></TR><TR CLASS="z"><TD CLASS="l">411</TD><TD>                        IRegion newRegion= RefactoringAnalyzeUtil.getNewTextRange(analyzePackages[i].fDeclarationEdit, cuChange);</TD></TR><TR CLASS="z"><TD CLASS="l">412</TD><TD>                        ASTNode newDeclaration= NodeFinder.perform(newCUNode, newRegion.getOffset(), newRegion.getLength());</TD></TR><TR CLASS="z"><TD CLASS="l">413</TD><TD>                        Assert.isTrue(newDeclaration instanceof Name);</TD></TR><TR><TD CLASS="l">414</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">415</TD><TD>                        VariableDeclaration declaration= getVariableDeclaration((Name) newDeclaration);</TD></TR><TR CLASS="z"><TD CLASS="l">416</TD><TD>                        Assert.isNotNull(declaration);</TD></TR><TR><TD CLASS="l">417</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">418</TD><TD>                        SimpleName[] problemNodes= ProblemNodeFinder.getProblemNodes(enclosing, declaration, analyzePackages[i].fOccurenceEdits, cuChange);</TD></TR><TR CLASS="z"><TD CLASS="l">419</TD><TD>                        result.merge(RefactoringAnalyzeUtil.reportProblemNodes(newCuSource, problemNodes));</TD></TR><TR><TD CLASS="l">420</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="15">421</A></TD><TD>                return result;</TD></TR><TR><TD CLASS="l">422</TD><TD>        }</TD></TR><TR><TD CLASS="l">423</TD><TD> </TD></TR><TR><TD CLASS="l">424</TD><TD>        private static VariableDeclaration getVariableDeclaration(Name node) {</TD></TR><TR CLASS="z"><TD CLASS="l">425</TD><TD>                IBinding binding= node.resolveBinding();</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>                if (binding == null &amp;&amp; node.getParent() instanceof VariableDeclaration)</TD></TR><TR CLASS="z"><TD CLASS="l">427</TD><TD>                        return (VariableDeclaration) node.getParent();</TD></TR><TR><TD CLASS="l">428</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">429</TD><TD>                if (binding != null &amp;&amp; binding.getKind() == IBinding.VARIABLE) {</TD></TR><TR CLASS="z"><TD CLASS="l">430</TD><TD>                        JavaScriptUnit cu= (JavaScriptUnit) ASTNodes.getParent(node, JavaScriptUnit.class);</TD></TR><TR CLASS="z"><TD CLASS="l">431</TD><TD>                        return ASTNodes.findVariableDeclaration( ((IVariableBinding) binding), cu);</TD></TR><TR><TD CLASS="l">432</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="11">433</A></TD><TD>                return null;</TD></TR><TR><TD CLASS="l">434</TD><TD>        }</TD></TR><TR><TD CLASS="l">435</TD><TD> </TD></TR><TR><TD CLASS="l">436</TD><TD>        private static ASTNode getEnclosingBlockOrMethod(TextEdit declarationEdit, TextChange change, JavaScriptUnit newCUNode) {</TD></TR><TR CLASS="z"><TD CLASS="l">437</TD><TD>                ASTNode enclosing= RefactoringAnalyzeUtil.getBlock(declarationEdit, change, newCUNode);</TD></TR><TR CLASS="z"><TD CLASS="l">438</TD><TD>                if (enclosing == null)</TD></TR><TR CLASS="z"><TD CLASS="l">439</TD><TD>                        enclosing= RefactoringAnalyzeUtil.getMethodDeclaration(declarationEdit, change, newCUNode);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5">440</A></TD><TD>                return enclosing;</TD></TR><TR><TD CLASS="l">441</TD><TD>        }</TD></TR><TR><TD CLASS="l">442</TD><TD> </TD></TR><TR><TD CLASS="l">443</TD><TD>        private static RefactoringStatus analyzeCompileErrors(String newCuSource, JavaScriptUnit newCUNode, JavaScriptUnit oldCUNode) {</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>                RefactoringStatus result= new RefactoringStatus();</TD></TR><TR CLASS="z"><TD CLASS="l">445</TD><TD>                IProblem[] newProblems= RefactoringAnalyzeUtil.getIntroducedCompileProblems(newCUNode, oldCUNode);</TD></TR><TR CLASS="z"><TD CLASS="l">446</TD><TD>                for (int i= 0; i &lt; newProblems.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">447</TD><TD>                        IProblem problem= newProblems[i];</TD></TR><TR CLASS="z"><TD CLASS="l">448</TD><TD>                        if (problem.isError())</TD></TR><TR CLASS="z"><TD CLASS="l">449</TD><TD>                                result.addEntry(new RefactoringStatusEntry((problem.isError() ? RefactoringStatus.ERROR : RefactoringStatus.WARNING), problem.getMessage(), new JavaStringStatusContext(newCuSource, new SourceRange(problem))));</TD></TR><TR><TD CLASS="l">450</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">451</TD><TD>                return result;</TD></TR><TR><TD CLASS="l">452</TD><TD>        }</TD></TR><TR><TD CLASS="l">453</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../xslUnitTestCoverage.html">all classes</A>][<A HREF="144.html">org.eclipse.wst.jsdt.internal.corext.refactoring.rename</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://www.eclemma.org/support.html">EMMA 2.0.5312 EclEmma Fix 1</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>