<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://www.eclemma.org/">EMMA</A> Coverage Report (generated Tue Jun 09 19:59:05 GMT 2009)</TH></TR><TR><TD CLASS="nv">[<A HREF="../xslUnitTestCoverage.html">all classes</A>][<A HREF="11f.html">org.eclipse.wst.jsdt.internal.compiler.lookup</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">Scope.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>Scope.java</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/94)</TD><TD CLASS="h">0%   (0/9659)</TD><TD CLASS="h">0%   (0/2401)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">Scope</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/94)</TD><TD CLASS="h">0%   (0/9659)</TD><TD CLASS="h">0%   (0/2401)</TD></TR><TR><TD CLASS="f"><A HREF="#1">Scope (int, Scope): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">boxing (TypeBinding): TypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#3">classScope (): ClassScope</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">compareTypes (TypeBinding, TypeBinding): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#5">compilationUnitScope (): CompilationUnitScope</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">compilerOptions (): CompilerOptions</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#7">computeCompatibleMethod (MethodBinding, TypeBinding [], InvocationSite): Meth...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/125)</TD><TD CLASS="h">0%   (0/31)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">connectTypeVariables (TypeParameter [], boolean): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/324)</TD><TD CLASS="h">0%   (0/81)</TD></TR><TR><TD CLASS="f"><A HREF="#9">createArrayType (TypeBinding, int): ArrayBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">createTypeVariables (TypeParameter [], Binding): TypeVariableBinding []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/87)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR><TD CLASS="f"><A HREF="#b">enclosingClassScope (): ClassScope</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">enclosingCompilationUnit (): CompilationUnitBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#d">enclosingMethodScope (): MethodScope</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">enclosingReceiverType (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/89)</TD><TD CLASS="h">0%   (0/22)</TD></TR><TR><TD CLASS="f"><A HREF="#f">enclosingReferenceContext (): ReferenceContext</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">enclosingSourceType (): SourceTypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#11">enclosingTypeBinding (): SourceTypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">environment (): LookupEnvironment</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#13">findBinding (char [], int, PackageBinding, PackageBinding, boolean): Binding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/46)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">findDefaultAbstractMethod (ReferenceBinding, char [], TypeBinding [], Invocat...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/118)</TD><TD CLASS="h">0%   (0/32)</TD></TR><TR><TD CLASS="f"><A HREF="#15">findDirectMemberType (char [], ReferenceBinding): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/52)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">findExactMethod (ReferenceBinding, char [], TypeBinding [], InvocationSite): ...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/50)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#17">findField (TypeBinding, char [], InvocationSite, boolean): FieldBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/165)</TD><TD CLASS="h">0%   (0/48)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">findMemberType (char [], ReferenceBinding): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/324)</TD><TD CLASS="h">0%   (0/83)</TD></TR><TR><TD CLASS="f"><A HREF="#19">findMethod (ReferenceBinding, char [], TypeBinding [], InvocationSite): Metho...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/704)</TD><TD CLASS="h">0%   (0/165)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">findMethodForArray (ArrayBinding, char [], TypeBinding [], InvocationSite): M...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/106)</TD><TD CLASS="h">0%   (0/26)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">findMethodInSuperInterfaces (ReferenceBinding, char [], ObjectVector): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/134)</TD><TD CLASS="h">0%   (0/27)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">findType (char [], PackageBinding, PackageBinding): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">findVariable (char []): LocalVariableBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">getBaseType (char []): TypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/225)</TD><TD CLASS="h">0%   (0/41)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">getBinding (char [], int, InvocationSite, boolean): Binding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/580)</TD><TD CLASS="h">0%   (0/171)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">getConstructor (ReferenceBinding, TypeBinding [], InvocationSite): MethodBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/203)</TD><TD CLASS="h">0%   (0/47)</TD></TR><TR><TD CLASS="f"><A HREF="#21">getCurrentPackage (): PackageBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">getDeclarationModifiers (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/48)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR><TD CLASS="f"><A HREF="#23">getField (TypeBinding, char [], InvocationSite): FieldBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/54)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">getFieldOrMethod (TypeBinding, char [], InvocationSite): Binding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/87)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR><TD CLASS="f"><A HREF="#25">getImplicitMethod (char [], TypeBinding [], InvocationSite): MethodBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/476)</TD><TD CLASS="h">0%   (0/144)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">getJavaIoSerializable (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#27">getJavaLangAnnotationAnnotation (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">getJavaLangArray (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#29">getJavaLangAssertionError (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">getJavaLangBoolean (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">getJavaLangClass (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2c">getJavaLangCloneable (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#2d">getJavaLangEnum (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2e">getJavaLangError (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#2f">getJavaLangFunction (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#30">getJavaLangIterable (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#31">getJavaLangNumber (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#32">getJavaLangObject (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#33">getJavaLangRegExp (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#34">getJavaLangString (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#35">getJavaLangThrowable (): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#36">getLocalBinding (char [], int, InvocationSite, boolean): Binding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/380)</TD><TD CLASS="h">0%   (0/128)</TD></TR><TR><TD CLASS="f"><A HREF="#37">getMemberType (char [], ReferenceBinding): ReferenceBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#38">getMethod (TypeBinding, char [], TypeBinding [], InvocationSite): MethodBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/141)</TD><TD CLASS="h">0%   (0/30)</TD></TR><TR><TD CLASS="f"><A HREF="#39">getPackage (char [][]): Binding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/98)</TD><TD CLASS="h">0%   (0/25)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3a">getType (char []): TypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">getType (char [], PackageBinding): TypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/63)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">getType (char [][], int): TypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/193)</TD><TD CLASS="h">0%   (0/58)</TD></TR><TR><TD CLASS="f"><A HREF="#3d">getTypeOrPackage (char [], int): Binding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/686)</TD><TD CLASS="h">0%   (0/169)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">getTypeOrPackage (char [][]): Binding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">getTypeOrPackage (char [][], int): Binding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/177)</TD><TD CLASS="h">0%   (0/48)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#40">greaterLowerBound (ReferenceBinding []): ReferenceBinding []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/104)</TD><TD CLASS="h">0%   (0/25)</TD></TR><TR><TD CLASS="f"><A HREF="#41">greaterLowerBound (TypeBinding []): TypeBinding []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/104)</TD><TD CLASS="h">0%   (0/25)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">hasErasedCandidatesCollisions (TypeBinding, TypeBinding, Map, ReferenceBindin...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/69)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#43">innermostSwitchCase (): CaseStatement</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">isAcceptableMethod (MethodBinding, MethodBinding): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/172)</TD><TD CLASS="h">0%   (0/33)</TD></TR><TR><TD CLASS="f"><A HREF="#45">isBoxingCompatibleWith (TypeBinding, TypeBinding): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">isDefinedInField (FieldBinding): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#47">isDefinedInMethod (MethodBinding): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">isDefinedInSameUnit (ReferenceBinding): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#49">isDefinedInType (ReferenceBinding): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">isInsideCase (CaseStatement): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#4b">isInsideDeprecatedCode (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/85)</TD><TD CLASS="h">0%   (0/26)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4c">leastContainingInvocation (TypeBinding, Object, List): TypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/143)</TD><TD CLASS="h">0%   (0/27)</TD></TR><TR><TD CLASS="f"><A HREF="#4d">leastContainingTypeArgument (TypeBinding, TypeBinding, ReferenceBinding, int,...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/308)</TD><TD CLASS="h">0%   (0/43)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4e">lowerUpperBound (TypeBinding []): TypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#4f">lowerUpperBound (TypeBinding [], List): TypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/258)</TD><TD CLASS="h">0%   (0/52)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">methodScope (): MethodScope</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#51">minimalErasedCandidates (TypeBinding [], Map): TypeBinding []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/691)</TD><TD CLASS="h">0%   (0/159)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#52">mostSpecificClassMethodBinding (MethodBinding [], int, InvocationSite): Metho...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/68)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#53">mostSpecificInterfaceMethodBinding (MethodBinding [], int, InvocationSite): M...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/53)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#54">mostSpecificMethodBinding (MethodBinding [], int, TypeBinding [], InvocationS...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/610)</TD><TD CLASS="h">0%   (0/131)</TD></TR><TR><TD CLASS="f"><A HREF="#55">outerMostClassScope (): ClassScope</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#56">outerMostMethodScope (): MethodScope</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#57">parameterCompatibilityLevel (MethodBinding, TypeBinding []): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/181)</TD><TD CLASS="h">0%   (0/48)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#58">parameterCompatibilityLevel (TypeBinding, TypeBinding, LookupEnvironment): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#59">referenceCompilationUnit (): CompilationUnitDeclaration</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5a">referenceContext (): ReferenceContext</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#5b">startIndex (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5c">substitute (Substitution, ReferenceBinding []): ReferenceBinding []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/54)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="f"><A HREF="#5d">substitute (Substitution, TypeBinding []): TypeBinding []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/53)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5e">substitute (Substitution, TypeBinding): TypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/202)</TD><TD CLASS="h">0%   (0/51)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/*******************************************************************************</TD></TR><TR><TD CLASS="l">2</TD><TD> * Copyright (c) 2007, 2008 IBM Corporation and others.</TD></TR><TR><TD CLASS="l">3</TD><TD> * All rights reserved. This program and the accompanying materials</TD></TR><TR><TD CLASS="l">4</TD><TD> * are made available under the terms of the Eclipse Public License v1.0</TD></TR><TR><TD CLASS="l">5</TD><TD> * which accompanies this distribution, and is available at</TD></TR><TR><TD CLASS="l">6</TD><TD> * http://www.eclipse.org/legal/epl-v10.html</TD></TR><TR><TD CLASS="l">7</TD><TD> *</TD></TR><TR><TD CLASS="l">8</TD><TD> * Contributors:</TD></TR><TR><TD CLASS="l">9</TD><TD> *     IBM Corporation - initial API and implementation</TD></TR><TR><TD CLASS="l">10</TD><TD> *******************************************************************************/</TD></TR><TR><TD CLASS="l">11</TD><TD>package org.eclipse.wst.jsdt.internal.compiler.lookup;</TD></TR><TR><TD CLASS="l">12</TD><TD> </TD></TR><TR><TD CLASS="l">13</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">14</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">15</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">16</TD><TD>import java.util.List;</TD></TR><TR><TD CLASS="l">17</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">18</TD><TD> </TD></TR><TR><TD CLASS="l">19</TD><TD>import org.eclipse.wst.jsdt.core.JavaScriptCore;</TD></TR><TR><TD CLASS="l">20</TD><TD>import org.eclipse.wst.jsdt.core.compiler.CharOperation;</TD></TR><TR><TD CLASS="l">21</TD><TD>import org.eclipse.wst.jsdt.core.infer.InferredType;</TD></TR><TR><TD CLASS="l">22</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.ASTNode;</TD></TR><TR><TD CLASS="l">23</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.AbstractMethodDeclaration;</TD></TR><TR><TD CLASS="l">24</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.CaseStatement;</TD></TR><TR><TD CLASS="l">25</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.CompilationUnitDeclaration;</TD></TR><TR><TD CLASS="l">26</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.ImportReference;</TD></TR><TR><TD CLASS="l">27</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.TypeParameter;</TD></TR><TR><TD CLASS="l">28</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.TypeReference;</TD></TR><TR><TD CLASS="l">29</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.Wildcard;</TD></TR><TR><TD CLASS="l">30</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.classfmt.ClassFileConstants;</TD></TR><TR><TD CLASS="l">31</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.impl.CompilerOptions;</TD></TR><TR><TD CLASS="l">32</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.impl.ReferenceContext;</TD></TR><TR><TD CLASS="l">33</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.problem.AbortCompilation;</TD></TR><TR><TD CLASS="l">34</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.problem.ProblemReporter;</TD></TR><TR><TD CLASS="l">35</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.util.HashtableOfObject;</TD></TR><TR><TD CLASS="l">36</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.util.ObjectVector;</TD></TR><TR><TD CLASS="l">37</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.util.SimpleSet;</TD></TR><TR><TD CLASS="l">38</TD><TD> </TD></TR><TR><TD CLASS="l">39</TD><TD>public abstract class Scope implements TypeConstants, TypeIds {</TD></TR><TR><TD CLASS="l">40</TD><TD> </TD></TR><TR><TD CLASS="l">41</TD><TD>        /* Scope kinds */</TD></TR><TR><TD CLASS="l">42</TD><TD>        public final static int BLOCK_SCOPE = 1;</TD></TR><TR><TD CLASS="l">43</TD><TD>        public final static int CLASS_SCOPE = 3;</TD></TR><TR><TD CLASS="l">44</TD><TD>        public final static int COMPILATION_UNIT_SCOPE = 4;</TD></TR><TR><TD CLASS="l">45</TD><TD>        public final static int METHOD_SCOPE = 2;</TD></TR><TR><TD CLASS="l">46</TD><TD>        public final static int WITH_SCOPE = 5;</TD></TR><TR><TD CLASS="l">47</TD><TD> </TD></TR><TR><TD CLASS="l">48</TD><TD>        /* Argument Compatibilities */</TD></TR><TR><TD CLASS="l">49</TD><TD>        public final static int NOT_COMPATIBLE = -1;</TD></TR><TR><TD CLASS="l">50</TD><TD>        public final static int COMPATIBLE = 0;</TD></TR><TR><TD CLASS="l">51</TD><TD>        public final static int AUTOBOX_COMPATIBLE = 1;</TD></TR><TR><TD CLASS="l">52</TD><TD>        public final static int VARARGS_COMPATIBLE = 2;</TD></TR><TR><TD CLASS="l">53</TD><TD> </TD></TR><TR><TD CLASS="l">54</TD><TD>        /* Type Compatibilities */</TD></TR><TR><TD CLASS="l">55</TD><TD>        public static final int EQUAL_OR_MORE_SPECIFIC = -1;</TD></TR><TR><TD CLASS="l">56</TD><TD>        public static final int NOT_RELATED = 0;</TD></TR><TR><TD CLASS="l">57</TD><TD>        public static final int MORE_GENERIC = 1;</TD></TR><TR><TD CLASS="l">58</TD><TD> </TD></TR><TR><TD CLASS="l">59</TD><TD>        public int kind;</TD></TR><TR><TD CLASS="l">60</TD><TD>        public Scope parent;</TD></TR><TR><TD CLASS="l">61</TD><TD> </TD></TR><TR><TD CLASS="l">62</TD><TD>        /* Answer an int describing the relationship between the given types.</TD></TR><TR><TD CLASS="l">63</TD><TD>        *</TD></TR><TR><TD CLASS="l">64</TD><TD>        *                 NOT_RELATED</TD></TR><TR><TD CLASS="l"><A NAME="0">65</A></TD><TD>        *                 EQUAL_OR_MORE_SPECIFIC : left is compatible with right</TD></TR><TR><TD CLASS="l">66</TD><TD>        *                 MORE_GENERIC : right is compatible with left</TD></TR><TR><TD CLASS="l">67</TD><TD>        */</TD></TR><TR><TD CLASS="l">68</TD><TD>        public static int compareTypes(TypeBinding left, TypeBinding right) {</TD></TR><TR CLASS="z"><TD CLASS="l">69</TD><TD>                if (left.isCompatibleWith(right))</TD></TR><TR CLASS="z"><TD CLASS="l">70</TD><TD>                        return Scope.EQUAL_OR_MORE_SPECIFIC;</TD></TR><TR CLASS="z"><TD CLASS="l">71</TD><TD>                if (right.isCompatibleWith(left))</TD></TR><TR CLASS="z"><TD CLASS="l">72</TD><TD>                        return Scope.MORE_GENERIC;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1e">73</A></TD><TD>                return Scope.NOT_RELATED;</TD></TR><TR><TD CLASS="l">74</TD><TD>        }</TD></TR><TR><TD CLASS="l">75</TD><TD>        public static TypeBinding getBaseType(char[] name) {</TD></TR><TR><TD CLASS="l">76</TD><TD>                // list should be optimized (with most often used first)</TD></TR><TR CLASS="z"><TD CLASS="l">77</TD><TD>                int length = name.length;</TD></TR><TR CLASS="z"><TD CLASS="l">78</TD><TD>                if (length &gt; 2 &amp;&amp; length &lt; 8) {</TD></TR><TR CLASS="z"><TD CLASS="l">79</TD><TD>                        switch (name[0]) {</TD></TR><TR><TD CLASS="l">80</TD><TD>                                case 'i' :</TD></TR><TR CLASS="z"><TD CLASS="l">81</TD><TD>                                        if (length == 3 &amp;&amp; name[1] == 'n' &amp;&amp; name[2] == 't')</TD></TR><TR CLASS="z"><TD CLASS="l">82</TD><TD>                                                return TypeBinding.INT;</TD></TR><TR><TD CLASS="l">83</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">84</TD><TD>                                case 'v' :</TD></TR><TR CLASS="z"><TD CLASS="l">85</TD><TD>                                        if (length == 4 &amp;&amp; name[1] == 'o' &amp;&amp; name[2] == 'i' &amp;&amp; name[3] == 'd')</TD></TR><TR CLASS="z"><TD CLASS="l">86</TD><TD>                                                return TypeBinding.VOID;</TD></TR><TR><TD CLASS="l">87</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">88</TD><TD>                                case 'b' :</TD></TR><TR CLASS="z"><TD CLASS="l">89</TD><TD>                                        if (length == 7</TD></TR><TR CLASS="z"><TD CLASS="l">90</TD><TD>                                                &amp;&amp; name[1] == 'o'</TD></TR><TR CLASS="z"><TD CLASS="l">91</TD><TD>                                                &amp;&amp; name[2] == 'o'</TD></TR><TR CLASS="z"><TD CLASS="l">92</TD><TD>                                                &amp;&amp; name[3] == 'l'</TD></TR><TR CLASS="z"><TD CLASS="l">93</TD><TD>                                                &amp;&amp; name[4] == 'e'</TD></TR><TR CLASS="z"><TD CLASS="l">94</TD><TD>                                                &amp;&amp; name[5] == 'a'</TD></TR><TR CLASS="z"><TD CLASS="l">95</TD><TD>                                                &amp;&amp; name[6] == 'n')</TD></TR><TR CLASS="z"><TD CLASS="l">96</TD><TD>                                                return TypeBinding.BOOLEAN;</TD></TR><TR CLASS="z"><TD CLASS="l">97</TD><TD>                                        if (length == 4 &amp;&amp; name[1] == 'y' &amp;&amp; name[2] == 't' &amp;&amp; name[3] == 'e')</TD></TR><TR CLASS="z"><TD CLASS="l">98</TD><TD>                                                return TypeBinding.BYTE;</TD></TR><TR><TD CLASS="l">99</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">100</TD><TD>                                case 'c' :</TD></TR><TR CLASS="z"><TD CLASS="l">101</TD><TD>                                        if (length == 4 &amp;&amp; name[1] == 'h' &amp;&amp; name[2] == 'a' &amp;&amp; name[3] == 'r')</TD></TR><TR CLASS="z"><TD CLASS="l">102</TD><TD>                                                return TypeBinding.CHAR;</TD></TR><TR><TD CLASS="l">103</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">104</TD><TD>                                case 'd' :</TD></TR><TR CLASS="z"><TD CLASS="l">105</TD><TD>                                        if (length == 6</TD></TR><TR CLASS="z"><TD CLASS="l">106</TD><TD>                                                &amp;&amp; name[1] == 'o'</TD></TR><TR CLASS="z"><TD CLASS="l">107</TD><TD>                                                &amp;&amp; name[2] == 'u'</TD></TR><TR CLASS="z"><TD CLASS="l">108</TD><TD>                                                &amp;&amp; name[3] == 'b'</TD></TR><TR CLASS="z"><TD CLASS="l">109</TD><TD>                                                &amp;&amp; name[4] == 'l'</TD></TR><TR CLASS="z"><TD CLASS="l">110</TD><TD>                                                &amp;&amp; name[5] == 'e')</TD></TR><TR CLASS="z"><TD CLASS="l">111</TD><TD>                                                return TypeBinding.DOUBLE;</TD></TR><TR><TD CLASS="l">112</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">113</TD><TD>                                case 'f' :</TD></TR><TR CLASS="z"><TD CLASS="l">114</TD><TD>                                        if (length == 5</TD></TR><TR CLASS="z"><TD CLASS="l">115</TD><TD>                                                &amp;&amp; name[1] == 'l'</TD></TR><TR CLASS="z"><TD CLASS="l">116</TD><TD>                                                &amp;&amp; name[2] == 'o'</TD></TR><TR CLASS="z"><TD CLASS="l">117</TD><TD>                                                &amp;&amp; name[3] == 'a'</TD></TR><TR CLASS="z"><TD CLASS="l">118</TD><TD>                                                &amp;&amp; name[4] == 't')</TD></TR><TR CLASS="z"><TD CLASS="l">119</TD><TD>                                                return TypeBinding.FLOAT;</TD></TR><TR><TD CLASS="l">120</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">121</TD><TD>                                case 'l' :</TD></TR><TR CLASS="z"><TD CLASS="l">122</TD><TD>                                        if (length == 4 &amp;&amp; name[1] == 'o' &amp;&amp; name[2] == 'n' &amp;&amp; name[3] == 'g')</TD></TR><TR CLASS="z"><TD CLASS="l">123</TD><TD>                                                return TypeBinding.LONG;</TD></TR><TR><TD CLASS="l">124</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">125</TD><TD>                                case 's' :</TD></TR><TR CLASS="z"><TD CLASS="l">126</TD><TD>                                        if (length == 5</TD></TR><TR CLASS="z"><TD CLASS="l">127</TD><TD>                                                &amp;&amp; name[1] == 'h'</TD></TR><TR CLASS="z"><TD CLASS="l">128</TD><TD>                                                &amp;&amp; name[2] == 'o'</TD></TR><TR CLASS="z"><TD CLASS="l">129</TD><TD>                                                &amp;&amp; name[3] == 'r'</TD></TR><TR CLASS="z"><TD CLASS="l">130</TD><TD>                                                &amp;&amp; name[4] == 't')</TD></TR><TR CLASS="z"><TD CLASS="l">131</TD><TD>                                                return TypeBinding.SHORT;</TD></TR><TR><TD CLASS="l">132</TD><TD>                        }</TD></TR><TR><TD CLASS="l">133</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">134</TD><TD>                return null;</TD></TR><TR><TD CLASS="l"><A NAME="40">135</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">136</TD><TD> </TD></TR><TR><TD CLASS="l">137</TD><TD>   // 5.1.10</TD></TR><TR><TD CLASS="l">138</TD><TD>        public static ReferenceBinding[] greaterLowerBound(ReferenceBinding[] types) {</TD></TR><TR CLASS="z"><TD CLASS="l">139</TD><TD>                if (types == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">140</TD><TD>                int length = types.length;</TD></TR><TR CLASS="z"><TD CLASS="l">141</TD><TD>                if (length == 0) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">142</TD><TD>                ReferenceBinding[] result = types;</TD></TR><TR CLASS="z"><TD CLASS="l">143</TD><TD>                int removed = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">144</TD><TD>                for (int i = 0; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">145</TD><TD>                        ReferenceBinding iType = result[i];</TD></TR><TR CLASS="z"><TD CLASS="l">146</TD><TD>                        if (iType == null) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">147</TD><TD>                        for (int j = 0; j &lt; length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">148</TD><TD>                                if (i == j) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">149</TD><TD>                                ReferenceBinding jType = result[j];</TD></TR><TR CLASS="z"><TD CLASS="l">150</TD><TD>                                if (jType == null) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">151</TD><TD>                                if (iType.isCompatibleWith(jType)) { // if Vi &lt;: Vj, Vj is removed</TD></TR><TR CLASS="z"><TD CLASS="l">152</TD><TD>                                        if (result == types) { // defensive copy</TD></TR><TR CLASS="z"><TD CLASS="l">153</TD><TD>                                                System.arraycopy(result, 0, result = new ReferenceBinding[length], 0, length);</TD></TR><TR><TD CLASS="l">154</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">155</TD><TD>                                        result[j] = null;</TD></TR><TR CLASS="z"><TD CLASS="l">156</TD><TD>                                        removed ++;</TD></TR><TR><TD CLASS="l">157</TD><TD>                                }</TD></TR><TR><TD CLASS="l">158</TD><TD>                        }</TD></TR><TR><TD CLASS="l">159</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">160</TD><TD>                if (removed == 0) return result;</TD></TR><TR CLASS="z"><TD CLASS="l">161</TD><TD>                if (length == removed) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">162</TD><TD>                ReferenceBinding[] trimmedResult = new ReferenceBinding[length - removed];</TD></TR><TR CLASS="z"><TD CLASS="l">163</TD><TD>                for (int i = 0, index = 0; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">164</TD><TD>                        ReferenceBinding iType = result[i];</TD></TR><TR CLASS="z"><TD CLASS="l">165</TD><TD>                        if (iType != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">166</TD><TD>                                trimmedResult[index++] = iType;</TD></TR><TR><TD CLASS="l">167</TD><TD>                        }</TD></TR><TR><TD CLASS="l">168</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">169</TD><TD>                return trimmedResult;</TD></TR><TR><TD CLASS="l"><A NAME="41">170</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">171</TD><TD> </TD></TR><TR><TD CLASS="l">172</TD><TD>        // 5.1.10</TD></TR><TR><TD CLASS="l">173</TD><TD>        public static TypeBinding[] greaterLowerBound(TypeBinding[] types) {</TD></TR><TR CLASS="z"><TD CLASS="l">174</TD><TD>                if (types == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">175</TD><TD>                int length = types.length;</TD></TR><TR CLASS="z"><TD CLASS="l">176</TD><TD>                if (length == 0) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">177</TD><TD>                TypeBinding[] result = types;</TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>                int removed = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">179</TD><TD>                for (int i = 0; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">180</TD><TD>                        TypeBinding iType = result[i];</TD></TR><TR CLASS="z"><TD CLASS="l">181</TD><TD>                        if (iType == null) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">182</TD><TD>                        for (int j = 0; j &lt; length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">183</TD><TD>                                if (i == j) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">184</TD><TD>                                TypeBinding jType = result[j];</TD></TR><TR CLASS="z"><TD CLASS="l">185</TD><TD>                                if (jType == null) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">186</TD><TD>                                if (iType.isCompatibleWith(jType)) { // if Vi &lt;: Vj, Vj is removed</TD></TR><TR CLASS="z"><TD CLASS="l">187</TD><TD>                                        if (result == types) { // defensive copy</TD></TR><TR CLASS="z"><TD CLASS="l">188</TD><TD>                                                System.arraycopy(result, 0, result = new TypeBinding[length], 0, length);</TD></TR><TR><TD CLASS="l">189</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">190</TD><TD>                                        result[j] = null;</TD></TR><TR CLASS="z"><TD CLASS="l">191</TD><TD>                                        removed ++;</TD></TR><TR><TD CLASS="l">192</TD><TD>                                }</TD></TR><TR><TD CLASS="l">193</TD><TD>                        }</TD></TR><TR><TD CLASS="l">194</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">195</TD><TD>                if (removed == 0) return result;</TD></TR><TR CLASS="z"><TD CLASS="l">196</TD><TD>                if (length == removed) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">197</TD><TD>                TypeBinding[] trimmedResult = new TypeBinding[length - removed];</TD></TR><TR CLASS="z"><TD CLASS="l">198</TD><TD>                for (int i = 0, index = 0; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">199</TD><TD>                        TypeBinding iType = result[i];</TD></TR><TR CLASS="z"><TD CLASS="l">200</TD><TD>                        if (iType != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">201</TD><TD>                                trimmedResult[index++] = iType;</TD></TR><TR><TD CLASS="l">202</TD><TD>                        }</TD></TR><TR><TD CLASS="l">203</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">204</TD><TD>                return trimmedResult;</TD></TR><TR><TD CLASS="l">205</TD><TD>        }</TD></TR><TR><TD CLASS="l">206</TD><TD> </TD></TR><TR><TD CLASS="l">207</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="5c">208</A></TD><TD>         * Returns an array of types, where original types got substituted given a substitution.</TD></TR><TR><TD CLASS="l">209</TD><TD>         * Only allocate an array if anything is different.</TD></TR><TR><TD CLASS="l">210</TD><TD>         */</TD></TR><TR><TD CLASS="l">211</TD><TD>        public static ReferenceBinding[] substitute(Substitution substitution, ReferenceBinding[] originalTypes) {</TD></TR><TR CLASS="z"><TD CLASS="l">212</TD><TD>                if (originalTypes == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">213</TD><TD>            ReferenceBinding[] substitutedTypes = originalTypes;</TD></TR><TR CLASS="z"><TD CLASS="l">214</TD><TD>            for (int i = 0, length = originalTypes.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">215</TD><TD>                ReferenceBinding originalType = originalTypes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">216</TD><TD>                ReferenceBinding substitutedParameter = (ReferenceBinding)substitute(substitution, originalType);</TD></TR><TR CLASS="z"><TD CLASS="l">217</TD><TD>                if (substitutedParameter != originalType) {</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>                    if (substitutedTypes == originalTypes) {</TD></TR><TR CLASS="z"><TD CLASS="l">219</TD><TD>                        System.arraycopy(originalTypes, 0, substitutedTypes = new ReferenceBinding[length], 0, i);</TD></TR><TR><TD CLASS="l">220</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">221</TD><TD>                    substitutedTypes[i] = substitutedParameter;</TD></TR><TR CLASS="z"><TD CLASS="l">222</TD><TD>                } else if (substitutedTypes != originalTypes) {</TD></TR><TR CLASS="z"><TD CLASS="l">223</TD><TD>                    substitutedTypes[i] = originalType;</TD></TR><TR><TD CLASS="l">224</TD><TD>                }</TD></TR><TR><TD CLASS="l">225</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">226</TD><TD>            return substitutedTypes;</TD></TR><TR><TD CLASS="l">227</TD><TD>        }</TD></TR><TR><TD CLASS="l">228</TD><TD> </TD></TR><TR><TD CLASS="l">229</TD><TD>        /**</TD></TR><TR><TD CLASS="l">230</TD><TD>         * Returns a type, where original type was substituted using the receiver</TD></TR><TR><TD CLASS="l">231</TD><TD>         * parameterized type.</TD></TR><TR><TD CLASS="l">232</TD><TD>         * In raw mode, all parameterized type denoting same original type are converted</TD></TR><TR><TD CLASS="l">233</TD><TD>         * to raw types. e.g.</TD></TR><TR><TD CLASS="l">234</TD><TD>         * class X &lt;T&gt; {</TD></TR><TR><TD CLASS="l">235</TD><TD>         *   X&lt;T&gt; foo;</TD></TR><TR><TD CLASS="l">236</TD><TD>         *   X&lt;String&gt; bar;</TD></TR><TR><TD CLASS="l"><A NAME="5e">237</A></TD><TD>         * } when used in raw fashion, then type of both foo and bar is raw type X.</TD></TR><TR><TD CLASS="l">238</TD><TD>         *</TD></TR><TR><TD CLASS="l">239</TD><TD>         */</TD></TR><TR><TD CLASS="l">240</TD><TD>        public static TypeBinding substitute(Substitution substitution, TypeBinding originalType) {</TD></TR><TR CLASS="z"><TD CLASS="l">241</TD><TD>                if (originalType == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">242</TD><TD>                switch (originalType.kind()) {</TD></TR><TR><TD CLASS="l">243</TD><TD> </TD></TR><TR><TD CLASS="l">244</TD><TD>                        case Binding.TYPE_PARAMETER:</TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>                                return substitution.substitute((TypeVariableBinding) originalType);</TD></TR><TR><TD CLASS="l">246</TD><TD> </TD></TR><TR><TD CLASS="l">247</TD><TD>                        case Binding.PARAMETERIZED_TYPE:</TD></TR><TR CLASS="z"><TD CLASS="l">248</TD><TD>                                ParameterizedTypeBinding originalParameterizedType = (ParameterizedTypeBinding) originalType;</TD></TR><TR CLASS="z"><TD CLASS="l">249</TD><TD>                                ReferenceBinding originalEnclosing = originalType.enclosingType();</TD></TR><TR CLASS="z"><TD CLASS="l">250</TD><TD>                                ReferenceBinding substitutedEnclosing = originalEnclosing;</TD></TR><TR CLASS="z"><TD CLASS="l">251</TD><TD>                                if (originalEnclosing != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">252</TD><TD>                                        substitutedEnclosing = (ReferenceBinding) substitute(substitution, originalEnclosing);</TD></TR><TR><TD CLASS="l">253</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">254</TD><TD>                                TypeBinding[] originalArguments = originalParameterizedType.arguments;</TD></TR><TR CLASS="z"><TD CLASS="l">255</TD><TD>                                TypeBinding[] substitutedArguments = originalArguments;</TD></TR><TR CLASS="z"><TD CLASS="l">256</TD><TD>                                if (originalArguments != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">257</TD><TD>                                        if (substitution.isRawSubstitution()) {</TD></TR><TR CLASS="z"><TD CLASS="l">258</TD><TD>                                                return originalParameterizedType.environment.createRawType(originalParameterizedType.genericType(), substitutedEnclosing);</TD></TR><TR><TD CLASS="l">259</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">260</TD><TD>                                        substitutedArguments = substitute(substitution, originalArguments);</TD></TR><TR><TD CLASS="l">261</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">262</TD><TD>                                if (substitutedArguments != originalArguments || substitutedEnclosing != originalEnclosing) {</TD></TR><TR><TD CLASS="l">263</TD><TD>//                                        identicalVariables: { // if substituted with original variables, then answer the generic type itself</TD></TR><TR><TD CLASS="l">264</TD><TD>//                                                if (substitutedEnclosing != null) {</TD></TR><TR><TD CLASS="l">265</TD><TD>//                                                        //if (!(substitutedEnclosing instanceof SourceTypeBinding)) break identicalVariables;</TD></TR><TR><TD CLASS="l">266</TD><TD>//                                                        if (substitutedEnclosing != originalEnclosing) break identicalVariables;</TD></TR><TR><TD CLASS="l">267</TD><TD>//                                                }</TD></TR><TR><TD CLASS="l">268</TD><TD>//                                                if (originalParameterizedType.type.isBinaryBinding()) break identicalVariables; // generic binary is never used as is, see 85262</TD></TR><TR><TD CLASS="l">269</TD><TD>//                                                TypeVariableBinding[] originalVariables = originalParameterizedType.type.typeVariables();</TD></TR><TR><TD CLASS="l">270</TD><TD>//                                                for (int i = 0, length = originalVariables.length; i &lt; length; i++) {</TD></TR><TR><TD CLASS="l">271</TD><TD>//                                                        if (substitutedArguments[i] != originalVariables[i]) break identicalVariables;</TD></TR><TR><TD CLASS="l">272</TD><TD>//                                                }</TD></TR><TR><TD CLASS="l">273</TD><TD>//                                                return originalParameterizedType.type;</TD></TR><TR><TD CLASS="l">274</TD><TD>//                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>                                        return originalParameterizedType.environment.createParameterizedType(</TD></TR><TR CLASS="z"><TD CLASS="l">276</TD><TD>                                                        originalParameterizedType.genericType(), substitutedArguments, substitutedEnclosing);</TD></TR><TR><TD CLASS="l">277</TD><TD>                                }</TD></TR><TR><TD CLASS="l">278</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">279</TD><TD> </TD></TR><TR><TD CLASS="l">280</TD><TD>                        case Binding.ARRAY_TYPE:</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>                                ArrayBinding originalArrayType = (ArrayBinding) originalType;</TD></TR><TR CLASS="z"><TD CLASS="l">282</TD><TD>                                TypeBinding originalLeafComponentType = originalArrayType.leafComponentType;</TD></TR><TR CLASS="z"><TD CLASS="l">283</TD><TD>                                TypeBinding substitute = substitute(substitution, originalLeafComponentType); // substitute could itself be array type</TD></TR><TR CLASS="z"><TD CLASS="l">284</TD><TD>                                if (substitute != originalLeafComponentType) {</TD></TR><TR CLASS="z"><TD CLASS="l">285</TD><TD>                                        return originalArrayType.environment.createArrayType(substitute.leafComponentType(), substitute.dimensions() + originalType.dimensions());</TD></TR><TR><TD CLASS="l">286</TD><TD>                                }</TD></TR><TR><TD CLASS="l">287</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">288</TD><TD> </TD></TR><TR><TD CLASS="l">289</TD><TD>                        case Binding.WILDCARD_TYPE:</TD></TR><TR CLASS="z"><TD CLASS="l">290</TD><TD>                        WildcardBinding wildcard = (WildcardBinding) originalType;</TD></TR><TR CLASS="z"><TD CLASS="l">291</TD><TD>                        if (wildcard.boundKind != Wildcard.UNBOUND) {</TD></TR><TR CLASS="z"><TD CLASS="l">292</TD><TD>                                TypeBinding originalBound = wildcard.bound;</TD></TR><TR CLASS="z"><TD CLASS="l">293</TD><TD>                                TypeBinding substitutedBound = substitute(substitution, originalBound);</TD></TR><TR CLASS="z"><TD CLASS="l">294</TD><TD>                                TypeBinding[] originalOtherBounds = wildcard.otherBounds;</TD></TR><TR CLASS="z"><TD CLASS="l">295</TD><TD>                                TypeBinding[] substitutedOtherBounds = substitute(substitution, originalOtherBounds);</TD></TR><TR CLASS="z"><TD CLASS="l">296</TD><TD>                                if (substitutedBound != originalBound || originalOtherBounds != substitutedOtherBounds) {</TD></TR><TR CLASS="z"><TD CLASS="l">297</TD><TD>                                        return wildcard.environment.createWildcard(wildcard.genericType, wildcard.rank, substitutedBound, substitutedOtherBounds, wildcard.boundKind);</TD></TR><TR><TD CLASS="l">298</TD><TD>                                }</TD></TR><TR><TD CLASS="l">299</TD><TD>                        }</TD></TR><TR><TD CLASS="l">300</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">301</TD><TD> </TD></TR><TR><TD CLASS="l">302</TD><TD>                        case Binding.TYPE:</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>                                if (!originalType.isMemberType()) break;</TD></TR><TR CLASS="z"><TD CLASS="l">304</TD><TD>                                ReferenceBinding originalReferenceType = (ReferenceBinding) originalType;</TD></TR><TR CLASS="z"><TD CLASS="l">305</TD><TD>                                originalEnclosing = originalType.enclosingType();</TD></TR><TR CLASS="z"><TD CLASS="l">306</TD><TD>                                substitutedEnclosing = originalEnclosing;</TD></TR><TR CLASS="z"><TD CLASS="l">307</TD><TD>                                if (originalEnclosing != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">308</TD><TD>                                        substitutedEnclosing = (ReferenceBinding) substitute(substitution, originalEnclosing);</TD></TR><TR><TD CLASS="l">309</TD><TD>                                }</TD></TR><TR><TD CLASS="l">310</TD><TD> </TD></TR><TR><TD CLASS="l">311</TD><TD>                            // treat as if parameterized with its type variables (non generic type gets 'null' arguments)</TD></TR><TR CLASS="z"><TD CLASS="l">312</TD><TD>                                if (substitutedEnclosing != originalEnclosing) {</TD></TR><TR CLASS="z"><TD CLASS="l">313</TD><TD>                                        return substitution.isRawSubstitution()</TD></TR><TR CLASS="z"><TD CLASS="l">314</TD><TD>                                                ? substitution.environment().createRawType(originalReferenceType, substitutedEnclosing)</TD></TR><TR CLASS="z"><TD CLASS="l">315</TD><TD>                                                :  substitution.environment().createParameterizedType(originalReferenceType, null, substitutedEnclosing);</TD></TR><TR><TD CLASS="l">316</TD><TD>                                }</TD></TR><TR><TD CLASS="l">317</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">318</TD><TD>                        case Binding.GENERIC_TYPE:</TD></TR><TR CLASS="z"><TD CLASS="l">319</TD><TD>                                originalReferenceType = (ReferenceBinding) originalType;</TD></TR><TR CLASS="z"><TD CLASS="l">320</TD><TD>                                originalEnclosing = originalType.enclosingType();</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>                                substitutedEnclosing = originalEnclosing;</TD></TR><TR CLASS="z"><TD CLASS="l">322</TD><TD>                                if (originalEnclosing != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">323</TD><TD>                                        substitutedEnclosing = (ReferenceBinding) substitute(substitution, originalEnclosing);</TD></TR><TR><TD CLASS="l">324</TD><TD>                                }</TD></TR><TR><TD CLASS="l">325</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">326</TD><TD>                                if (substitution.isRawSubstitution()) {</TD></TR><TR CLASS="z"><TD CLASS="l">327</TD><TD>                                        return substitution.environment().createRawType(originalReferenceType, substitutedEnclosing);</TD></TR><TR><TD CLASS="l">328</TD><TD>                                }</TD></TR><TR><TD CLASS="l">329</TD><TD>                            // treat as if parameterized with its type variables (non generic type gets 'null' arguments)</TD></TR><TR CLASS="z"><TD CLASS="l">330</TD><TD>                                originalArguments = originalReferenceType.typeVariables();</TD></TR><TR CLASS="z"><TD CLASS="l">331</TD><TD>                                substitutedArguments = substitute(substitution, originalArguments);</TD></TR><TR><TD CLASS="l">332</TD><TD>//                                if (substitutedArguments != originalArguments || substitutedEnclosing != originalEnclosing) {</TD></TR><TR CLASS="z"><TD CLASS="l">333</TD><TD>                                return substitution.environment().createParameterizedType(originalReferenceType, substitutedArguments, substitutedEnclosing);</TD></TR><TR><TD CLASS="l">334</TD><TD>//                                }</TD></TR><TR><TD CLASS="l">335</TD><TD>//                                break;</TD></TR><TR><TD CLASS="l">336</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">337</TD><TD>                return originalType;</TD></TR><TR><TD CLASS="l">338</TD><TD>        }</TD></TR><TR><TD CLASS="l">339</TD><TD> </TD></TR><TR><TD CLASS="l">340</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="5d">341</A></TD><TD>         * Returns an array of types, where original types got substituted given a substitution.</TD></TR><TR><TD CLASS="l">342</TD><TD>         * Only allocate an array if anything is different.</TD></TR><TR><TD CLASS="l">343</TD><TD>         */</TD></TR><TR><TD CLASS="l">344</TD><TD>        public static TypeBinding[] substitute(Substitution substitution, TypeBinding[] originalTypes) {</TD></TR><TR CLASS="z"><TD CLASS="l">345</TD><TD>                if (originalTypes == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">346</TD><TD>            TypeBinding[] substitutedTypes = originalTypes;</TD></TR><TR CLASS="z"><TD CLASS="l">347</TD><TD>            for (int i = 0, length = originalTypes.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">348</TD><TD>                TypeBinding originalType = originalTypes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">349</TD><TD>                TypeBinding substitutedParameter = substitute(substitution, originalType);</TD></TR><TR CLASS="z"><TD CLASS="l">350</TD><TD>                if (substitutedParameter != originalType) {</TD></TR><TR CLASS="z"><TD CLASS="l">351</TD><TD>                    if (substitutedTypes == originalTypes) {</TD></TR><TR CLASS="z"><TD CLASS="l">352</TD><TD>                        System.arraycopy(originalTypes, 0, substitutedTypes = new TypeBinding[length], 0, i);</TD></TR><TR><TD CLASS="l">353</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">354</TD><TD>                    substitutedTypes[i] = substitutedParameter;</TD></TR><TR CLASS="z"><TD CLASS="l">355</TD><TD>                } else if (substitutedTypes != originalTypes) {</TD></TR><TR CLASS="z"><TD CLASS="l">356</TD><TD>                    substitutedTypes[i] = originalType;</TD></TR><TR><TD CLASS="l">357</TD><TD>                }</TD></TR><TR><TD CLASS="l"><A NAME="1">358</A></TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">359</TD><TD>            return substitutedTypes;</TD></TR><TR><TD CLASS="l">360</TD><TD>        }</TD></TR><TR><TD CLASS="l">361</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">362</TD><TD>        protected Scope(int kind, Scope parent) {</TD></TR><TR CLASS="z"><TD CLASS="l">363</TD><TD>                this.kind = kind;</TD></TR><TR CLASS="z"><TD CLASS="l">364</TD><TD>                this.parent = parent;</TD></TR><TR CLASS="z"><TD CLASS="l">365</TD><TD>        }</TD></TR><TR><TD CLASS="l">366</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="2">367</A></TD><TD>        /*</TD></TR><TR><TD CLASS="l">368</TD><TD>         * Boxing primitive</TD></TR><TR><TD CLASS="l">369</TD><TD>         */</TD></TR><TR><TD CLASS="l">370</TD><TD>        public TypeBinding boxing(TypeBinding type) {</TD></TR><TR CLASS="z"><TD CLASS="l">371</TD><TD>                if (type.isBaseType())</TD></TR><TR CLASS="z"><TD CLASS="l">372</TD><TD>                        return environment().computeBoxingType(type);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3">373</A></TD><TD>                return type;</TD></TR><TR><TD CLASS="l">374</TD><TD>        }</TD></TR><TR><TD CLASS="l">375</TD><TD> </TD></TR><TR><TD CLASS="l">376</TD><TD>        public ClassScope classScope() {</TD></TR><TR CLASS="z"><TD CLASS="l">377</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">378</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">379</TD><TD>                        if (scope instanceof ClassScope)</TD></TR><TR CLASS="z"><TD CLASS="l">380</TD><TD>                                return (ClassScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">381</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">382</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5">383</A></TD><TD>                return null;</TD></TR><TR><TD CLASS="l">384</TD><TD>        }</TD></TR><TR><TD CLASS="l">385</TD><TD> </TD></TR><TR><TD CLASS="l">386</TD><TD>        public final CompilationUnitScope compilationUnitScope() {</TD></TR><TR CLASS="z"><TD CLASS="l">387</TD><TD>                Scope lastScope = null;</TD></TR><TR CLASS="z"><TD CLASS="l">388</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">389</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">390</TD><TD>                        lastScope = scope;</TD></TR><TR CLASS="z"><TD CLASS="l">391</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">392</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l">393</TD><TD>                return (CompilationUnitScope) lastScope;</TD></TR><TR><TD CLASS="l">394</TD><TD>        }</TD></TR><TR><TD CLASS="l">395</TD><TD> </TD></TR><TR><TD CLASS="l">396</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="6">397</A></TD><TD>         * Finds the most specific compiler options</TD></TR><TR><TD CLASS="l">398</TD><TD>         */</TD></TR><TR><TD CLASS="l">399</TD><TD>        public final CompilerOptions compilerOptions() {</TD></TR><TR><TD CLASS="l">400</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">401</TD><TD>                return compilationUnitScope().environment.globalOptions;</TD></TR><TR><TD CLASS="l">402</TD><TD>        }</TD></TR><TR><TD CLASS="l">403</TD><TD> </TD></TR><TR><TD CLASS="l">404</TD><TD>        /**</TD></TR><TR><TD CLASS="l">405</TD><TD>         * Internal use only</TD></TR><TR><TD CLASS="l">406</TD><TD>         * Given a method, returns null if arguments cannot be converted to parameters.</TD></TR><TR><TD CLASS="l">407</TD><TD>         * Will answer a subsituted method in case the method was generic and type inference got triggered;</TD></TR><TR><TD CLASS="l"><A NAME="7">408</A></TD><TD>         * in case the method was originally compatible, then simply answer it back.</TD></TR><TR><TD CLASS="l">409</TD><TD>         */</TD></TR><TR><TD CLASS="l">410</TD><TD>        protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite) {</TD></TR><TR><TD CLASS="l">411</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">412</TD><TD>                TypeBinding[] genericTypeArguments = invocationSite.genericTypeArguments();</TD></TR><TR CLASS="z"><TD CLASS="l">413</TD><TD>                TypeBinding[] parameters = method.parameters;</TD></TR><TR CLASS="z"><TD CLASS="l">414</TD><TD>                TypeVariableBinding[] typeVariables = method.typeVariables;</TD></TR><TR CLASS="z"><TD CLASS="l">415</TD><TD>                if (parameters == arguments</TD></TR><TR><TD CLASS="l">416</TD><TD>//                        &amp;&amp; (method.returnType.tagBits &amp; TagBits.HasTypeVariable) == 0</TD></TR><TR CLASS="z"><TD CLASS="l">417</TD><TD>                        &amp;&amp; genericTypeArguments == null</TD></TR><TR CLASS="z"><TD CLASS="l">418</TD><TD>                        &amp;&amp; typeVariables == Binding.NO_TYPE_VARIABLES)</TD></TR><TR CLASS="z"><TD CLASS="l">419</TD><TD>                                return method;</TD></TR><TR><TD CLASS="l">420</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">421</TD><TD>                int argLength = arguments.length;</TD></TR><TR CLASS="z"><TD CLASS="l">422</TD><TD>                int paramLength = parameters.length;</TD></TR><TR CLASS="z"><TD CLASS="l">423</TD><TD>                boolean isVarArgs = method.isVarargs();</TD></TR><TR CLASS="z"><TD CLASS="l">424</TD><TD>                if (argLength != paramLength)</TD></TR><TR CLASS="z"><TD CLASS="l">425</TD><TD>                        if (!isVarArgs || argLength &lt; paramLength - 1)</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>                                return null; // incompatible</TD></TR><TR><TD CLASS="l">427</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">428</TD><TD>                if (typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method</TD></TR><TR CLASS="z"><TD CLASS="l">429</TD><TD>                        TypeBinding[] newArgs = null;</TD></TR><TR CLASS="z"><TD CLASS="l">430</TD><TD>                        for (int i = 0; i &lt; argLength; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">431</TD><TD>                                TypeBinding param = i &lt; paramLength ? parameters[i] : parameters[paramLength - 1];</TD></TR><TR CLASS="z"><TD CLASS="l">432</TD><TD>                                if (arguments[i].isBaseType() != param.isBaseType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">433</TD><TD>                                        if (newArgs == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">434</TD><TD>                                                newArgs = new TypeBinding[argLength];</TD></TR><TR CLASS="z"><TD CLASS="l">435</TD><TD>                                                System.arraycopy(arguments, 0, newArgs, 0, argLength);</TD></TR><TR><TD CLASS="l">436</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">437</TD><TD>                                        newArgs[i] = environment().computeBoxingType(arguments[i]);</TD></TR><TR><TD CLASS="l">438</TD><TD>                                }</TD></TR><TR><TD CLASS="l">439</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">440</TD><TD>                        if (newArgs != null)</TD></TR><TR CLASS="z"><TD CLASS="l">441</TD><TD>                                arguments = newArgs;</TD></TR><TR CLASS="z"><TD CLASS="l">442</TD><TD>                        method = ParameterizedGenericMethodBinding.computeCompatibleMethod(method, arguments, this, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">443</TD><TD>                        if (method == null) return null; // incompatible</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>                        if (!method.isValidBinding()) return method; // bound check issue is taking precedence</TD></TR><TR CLASS="z"><TD CLASS="l">445</TD><TD>                        parameters = method.parameters; // reacquire them after type inference has performed</TD></TR><TR><TD CLASS="l">446</TD><TD>                }</TD></TR><TR><TD CLASS="l">447</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">448</TD><TD>                if (parameterCompatibilityLevel(method, arguments) &gt; NOT_COMPATIBLE)</TD></TR><TR CLASS="z"><TD CLASS="l">449</TD><TD>                        return method;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="8">450</A></TD><TD>                return null; // incompatible</TD></TR><TR><TD CLASS="l">451</TD><TD>        }</TD></TR><TR><TD CLASS="l">452</TD><TD> </TD></TR><TR><TD CLASS="l">453</TD><TD>        protected boolean connectTypeVariables(TypeParameter[] typeParameters, boolean checkForErasedCandidateCollisions) {</TD></TR><TR CLASS="z"><TD CLASS="l">454</TD><TD>                if (typeParameters == null || compilerOptions().sourceLevel &lt; ClassFileConstants.JDK1_5) return true;</TD></TR><TR CLASS="z"><TD CLASS="l">455</TD><TD>                boolean noProblems = true;</TD></TR><TR CLASS="z"><TD CLASS="l">456</TD><TD>                Map invocations = new HashMap(2);</TD></TR><TR CLASS="z"><TD CLASS="l">457</TD><TD>                nextVariable : for (int i = 0, paramLength = typeParameters.length; i &lt; paramLength; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">458</TD><TD>                        TypeParameter typeParameter = typeParameters[i];</TD></TR><TR CLASS="z"><TD CLASS="l">459</TD><TD>                        TypeVariableBinding typeVariable = typeParameter.binding;</TD></TR><TR CLASS="z"><TD CLASS="l">460</TD><TD>                        if (typeVariable == null) return false;</TD></TR><TR><TD CLASS="l">461</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">462</TD><TD>                        typeVariable.superclass = getJavaLangObject();</TD></TR><TR CLASS="z"><TD CLASS="l">463</TD><TD>                        typeVariable.superInterfaces = Binding.NO_SUPERINTERFACES;</TD></TR><TR><TD CLASS="l">464</TD><TD>                        // set firstBound to the binding of the first explicit bound in parameter declaration</TD></TR><TR CLASS="z"><TD CLASS="l">465</TD><TD>                        typeVariable.firstBound = null; // first bound used to compute erasure</TD></TR><TR><TD CLASS="l">466</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">467</TD><TD>                        TypeReference typeRef = typeParameter.type;</TD></TR><TR CLASS="z"><TD CLASS="l">468</TD><TD>                        if (typeRef == null)</TD></TR><TR CLASS="z"><TD CLASS="l">469</TD><TD>                                continue nextVariable;</TD></TR><TR CLASS="z"><TD CLASS="l">470</TD><TD>                        TypeBinding superType = this.kind == METHOD_SCOPE</TD></TR><TR CLASS="z"><TD CLASS="l">471</TD><TD>                                ? typeRef.resolveType((BlockScope)this, false/*no bound check*/)</TD></TR><TR CLASS="z"><TD CLASS="l">472</TD><TD>                                : typeRef.resolveType((ClassScope)this);</TD></TR><TR CLASS="z"><TD CLASS="l">473</TD><TD>                        if (superType == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">474</TD><TD>                                typeVariable.tagBits |= TagBits.HierarchyHasProblems;</TD></TR><TR CLASS="z"><TD CLASS="l">475</TD><TD>                                noProblems = false;</TD></TR><TR CLASS="z"><TD CLASS="l">476</TD><TD>                                continue nextVariable;</TD></TR><TR><TD CLASS="l">477</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">478</TD><TD>                        typeRef.resolvedType = superType; // hold onto the problem type</TD></TR><TR CLASS="z"><TD CLASS="l">479</TD><TD>                        if (superType.isArrayType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">480</TD><TD>                                problemReporter().boundCannotBeArray(typeRef, superType);</TD></TR><TR CLASS="z"><TD CLASS="l">481</TD><TD>                                continue nextVariable;</TD></TR><TR><TD CLASS="l">482</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">483</TD><TD>                        boolean isTypeVariableFirstBound =  superType.isTypeVariable();</TD></TR><TR CLASS="z"><TD CLASS="l">484</TD><TD>                        if (isTypeVariableFirstBound) {</TD></TR><TR CLASS="z"><TD CLASS="l">485</TD><TD>                                TypeVariableBinding varSuperType = (TypeVariableBinding) superType;</TD></TR><TR CLASS="z"><TD CLASS="l">486</TD><TD>                                if (varSuperType.rank &gt;= typeVariable.rank &amp;&amp; varSuperType.declaringElement == typeVariable.declaringElement) {</TD></TR><TR CLASS="z"><TD CLASS="l">487</TD><TD>                                        problemReporter().forwardTypeVariableReference(typeParameter, varSuperType);</TD></TR><TR CLASS="z"><TD CLASS="l">488</TD><TD>                                        typeVariable.tagBits |= TagBits.HierarchyHasProblems;</TD></TR><TR CLASS="z"><TD CLASS="l">489</TD><TD>                                        noProblems = false;</TD></TR><TR CLASS="z"><TD CLASS="l">490</TD><TD>                                        continue nextVariable;</TD></TR><TR><TD CLASS="l">491</TD><TD>                                }</TD></TR><TR><TD CLASS="l">492</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">493</TD><TD>                        ReferenceBinding superRefType = (ReferenceBinding) superType;</TD></TR><TR CLASS="z"><TD CLASS="l">494</TD><TD>                        if (superRefType.isFinal())</TD></TR><TR CLASS="z"><TD CLASS="l">495</TD><TD>                                problemReporter().finalVariableBound(typeVariable, typeRef);</TD></TR><TR CLASS="z"><TD CLASS="l">496</TD><TD>                        if (!superType.isInterface()) {</TD></TR><TR CLASS="z"><TD CLASS="l">497</TD><TD>                                typeVariable.superclass = superRefType;</TD></TR><TR><TD CLASS="l">498</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">499</TD><TD>                                typeVariable.superInterfaces = new ReferenceBinding[] {superRefType};</TD></TR><TR><TD CLASS="l">500</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">501</TD><TD>                        typeVariable.firstBound = superRefType; // first bound used to compute erasure</TD></TR><TR CLASS="z"><TD CLASS="l">502</TD><TD>                        TypeReference[] boundRefs = typeParameter.bounds;</TD></TR><TR CLASS="z"><TD CLASS="l">503</TD><TD>                        if (boundRefs != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">504</TD><TD>                                for (int j = 0, boundLength = boundRefs.length; j &lt; boundLength; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">505</TD><TD>                                        typeRef = boundRefs[j];</TD></TR><TR CLASS="z"><TD CLASS="l">506</TD><TD>                                        superType = this.kind == METHOD_SCOPE</TD></TR><TR CLASS="z"><TD CLASS="l">507</TD><TD>                                                ? typeRef.resolveType((BlockScope)this, false)</TD></TR><TR CLASS="z"><TD CLASS="l">508</TD><TD>                                                : typeRef.resolveType((ClassScope)this);</TD></TR><TR CLASS="z"><TD CLASS="l">509</TD><TD>                                        if (superType == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">510</TD><TD>                                                typeVariable.tagBits |= TagBits.HierarchyHasProblems;</TD></TR><TR CLASS="z"><TD CLASS="l">511</TD><TD>                                                noProblems = false;</TD></TR><TR CLASS="z"><TD CLASS="l">512</TD><TD>                                                continue nextVariable;</TD></TR><TR><TD CLASS="l">513</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">514</TD><TD>                                        typeRef.resolvedType = superType; // hold onto the problem type</TD></TR><TR CLASS="z"><TD CLASS="l">515</TD><TD>                                        if (isTypeVariableFirstBound &amp;&amp; j == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">516</TD><TD>                                                problemReporter().noAdditionalBoundAfterTypeVariable(typeRef);</TD></TR><TR><TD CLASS="l">517</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">518</TD><TD>                                        if (superType.isArrayType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">519</TD><TD>                                                problemReporter().boundCannotBeArray(typeRef, superType);</TD></TR><TR CLASS="z"><TD CLASS="l">520</TD><TD>                                                continue nextVariable;</TD></TR><TR><TD CLASS="l">521</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">522</TD><TD>                                        superRefType = (ReferenceBinding) superType;</TD></TR><TR CLASS="z"><TD CLASS="l">523</TD><TD>                                        if (!superType.isInterface()) {</TD></TR><TR CLASS="z"><TD CLASS="l">524</TD><TD>                                                problemReporter().boundMustBeAnInterface(typeRef, superType);</TD></TR><TR CLASS="z"><TD CLASS="l">525</TD><TD>                                                typeVariable.tagBits |= TagBits.HierarchyHasProblems;</TD></TR><TR CLASS="z"><TD CLASS="l">526</TD><TD>                                                noProblems = false;</TD></TR><TR CLASS="z"><TD CLASS="l">527</TD><TD>                                                continue nextVariable;</TD></TR><TR><TD CLASS="l">528</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">529</TD><TD>                                        // check against superclass</TD></TR><TR CLASS="z"><TD CLASS="l">530</TD><TD>                                        if (checkForErasedCandidateCollisions &amp;&amp; typeVariable.firstBound == typeVariable.superclass) {</TD></TR><TR CLASS="z"><TD CLASS="l">531</TD><TD>                                                if (hasErasedCandidatesCollisions(superType, typeVariable.superclass, invocations, typeVariable, typeRef)) {</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>                                                        noProblems = false;</TD></TR><TR CLASS="z"><TD CLASS="l">533</TD><TD>                                                        continue nextVariable;</TD></TR><TR><TD CLASS="l">534</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">535</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">536</TD><TD>                                        // check against superinterfaces</TD></TR><TR CLASS="z"><TD CLASS="l">537</TD><TD>                                        for (int index = typeVariable.superInterfaces.length; --index &gt;= 0;) {</TD></TR><TR CLASS="z"><TD CLASS="l">538</TD><TD>                                                ReferenceBinding previousInterface = typeVariable.superInterfaces[index];</TD></TR><TR CLASS="z"><TD CLASS="l">539</TD><TD>                                                if (previousInterface == superRefType) {</TD></TR><TR CLASS="z"><TD CLASS="l">540</TD><TD>                                                        problemReporter().duplicateBounds(typeRef, superType);</TD></TR><TR CLASS="z"><TD CLASS="l">541</TD><TD>                                                        typeVariable.tagBits |= TagBits.HierarchyHasProblems;</TD></TR><TR CLASS="z"><TD CLASS="l">542</TD><TD>                                                        noProblems = false;</TD></TR><TR CLASS="z"><TD CLASS="l">543</TD><TD>                                                        continue nextVariable;</TD></TR><TR><TD CLASS="l">544</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">545</TD><TD>                                                if (checkForErasedCandidateCollisions) {</TD></TR><TR CLASS="z"><TD CLASS="l">546</TD><TD>                                                        if (hasErasedCandidatesCollisions(superType, previousInterface, invocations, typeVariable, typeRef)) {</TD></TR><TR CLASS="z"><TD CLASS="l">547</TD><TD>                                                                noProblems = false;</TD></TR><TR CLASS="z"><TD CLASS="l">548</TD><TD>                                                                continue nextVariable;</TD></TR><TR><TD CLASS="l">549</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">550</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">551</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">552</TD><TD>                                        int size = typeVariable.superInterfaces.length;</TD></TR><TR CLASS="z"><TD CLASS="l">553</TD><TD>                                        System.arraycopy(typeVariable.superInterfaces, 0, typeVariable.superInterfaces = new ReferenceBinding[size + 1], 0, size);</TD></TR><TR CLASS="z"><TD CLASS="l">554</TD><TD>                                        typeVariable.superInterfaces[size] = superRefType;</TD></TR><TR><TD CLASS="l">555</TD><TD>                                }</TD></TR><TR><TD CLASS="l">556</TD><TD>                        }</TD></TR><TR><TD CLASS="l">557</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="9">558</A></TD><TD>                return noProblems;</TD></TR><TR><TD CLASS="l">559</TD><TD>        }</TD></TR><TR><TD CLASS="l">560</TD><TD> </TD></TR><TR><TD CLASS="l">561</TD><TD>        public ArrayBinding createArrayType(TypeBinding type, int dimension) {</TD></TR><TR CLASS="z"><TD CLASS="l">562</TD><TD>                if (type.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">563</TD><TD>                        return environment().createArrayType(type, dimension);</TD></TR><TR><TD CLASS="l">564</TD><TD>                // do not cache obvious invalid types</TD></TR><TR CLASS="z"><TD CLASS="l">565</TD><TD>                return new ArrayBinding(type, dimension, environment());</TD></TR><TR><TD CLASS="l"><A NAME="a">566</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">567</TD><TD> </TD></TR><TR><TD CLASS="l">568</TD><TD>        public TypeVariableBinding[] createTypeVariables(TypeParameter[] typeParameters, Binding declaringElement) {</TD></TR><TR><TD CLASS="l">569</TD><TD>                // do not construct type variables if source &lt; 1.5</TD></TR><TR CLASS="z"><TD CLASS="l">570</TD><TD>                if (typeParameters == null || compilerOptions().sourceLevel &lt; ClassFileConstants.JDK1_5)</TD></TR><TR CLASS="z"><TD CLASS="l">571</TD><TD>                        return Binding.NO_TYPE_VARIABLES;</TD></TR><TR><TD CLASS="l">572</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">573</TD><TD>                PackageBinding unitPackage = compilationUnitScope().getDefaultPackage();</TD></TR><TR CLASS="z"><TD CLASS="l">574</TD><TD>                int length = typeParameters.length;</TD></TR><TR CLASS="z"><TD CLASS="l">575</TD><TD>                TypeVariableBinding[] typeVariableBindings = new TypeVariableBinding[length];</TD></TR><TR CLASS="z"><TD CLASS="l">576</TD><TD>                int count = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">577</TD><TD>                for (int i = 0; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">578</TD><TD>                        TypeParameter typeParameter = typeParameters[i];</TD></TR><TR CLASS="z"><TD CLASS="l">579</TD><TD>                        TypeVariableBinding parameterBinding = new TypeVariableBinding(typeParameter.name, declaringElement, i);</TD></TR><TR CLASS="z"><TD CLASS="l">580</TD><TD>                        parameterBinding.fPackage = unitPackage;</TD></TR><TR CLASS="z"><TD CLASS="l">581</TD><TD>                        typeParameter.binding = parameterBinding;</TD></TR><TR><TD CLASS="l">582</TD><TD> </TD></TR><TR><TD CLASS="l">583</TD><TD>                        // detect duplicates, but keep each variable to reduce secondary errors with instantiating this generic type (assume number of variables is correct)</TD></TR><TR CLASS="z"><TD CLASS="l">584</TD><TD>                        for (int j = 0; j &lt; count; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">585</TD><TD>                                TypeVariableBinding knownVar = typeVariableBindings[j];</TD></TR><TR CLASS="z"><TD CLASS="l">586</TD><TD>                                if (CharOperation.equals(knownVar.sourceName, typeParameter.name))</TD></TR><TR CLASS="z"><TD CLASS="l">587</TD><TD>                                        problemReporter().duplicateTypeParameterInType(typeParameter);</TD></TR><TR><TD CLASS="l">588</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">589</TD><TD>                        typeVariableBindings[count++] = parameterBinding;</TD></TR><TR><TD CLASS="l">590</TD><TD>//                                TODO should offer warnings to inform about hiding declaring, enclosing or member types</TD></TR><TR><TD CLASS="l">591</TD><TD>//                                ReferenceBinding type = sourceType;</TD></TR><TR><TD CLASS="l">592</TD><TD>//                                // check that the member does not conflict with an enclosing type</TD></TR><TR><TD CLASS="l">593</TD><TD>//                                do {</TD></TR><TR><TD CLASS="l">594</TD><TD>//                                        if (CharOperation.equals(type.sourceName, memberContext.name)) {</TD></TR><TR><TD CLASS="l">595</TD><TD>//                                                problemReporter().hidingEnclosingType(memberContext);</TD></TR><TR><TD CLASS="l">596</TD><TD>//                                                continue nextParameter;</TD></TR><TR><TD CLASS="l">597</TD><TD>//                                        }</TD></TR><TR><TD CLASS="l">598</TD><TD>//                                        type = type.enclosingType();</TD></TR><TR><TD CLASS="l">599</TD><TD>//                                } while (type != null);</TD></TR><TR><TD CLASS="l">600</TD><TD>//                                // check that the member type does not conflict with another sibling member type</TD></TR><TR><TD CLASS="l">601</TD><TD>//                                for (int j = 0; j &lt; i; j++) {</TD></TR><TR><TD CLASS="l">602</TD><TD>//                                        if (CharOperation.equals(referenceContext.memberTypes[j].name, memberContext.name)) {</TD></TR><TR><TD CLASS="l">603</TD><TD>//                                                problemReporter().duplicateNestedType(memberContext);</TD></TR><TR><TD CLASS="l">604</TD><TD>//                                                continue nextParameter;</TD></TR><TR><TD CLASS="l">605</TD><TD>//                                        }</TD></TR><TR><TD CLASS="l">606</TD><TD>//                                }</TD></TR><TR><TD CLASS="l">607</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>                if (count != length)</TD></TR><TR CLASS="z"><TD CLASS="l">609</TD><TD>                        System.arraycopy(typeVariableBindings, 0, typeVariableBindings = new TypeVariableBinding[count], 0, count);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="b">610</A></TD><TD>                return typeVariableBindings;</TD></TR><TR><TD CLASS="l">611</TD><TD>        }</TD></TR><TR><TD CLASS="l">612</TD><TD> </TD></TR><TR><TD CLASS="l">613</TD><TD>        public final ClassScope enclosingClassScope() {</TD></TR><TR CLASS="z"><TD CLASS="l">614</TD><TD>                Scope scope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">615</TD><TD>                while ((scope = scope.parent) != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">616</TD><TD>                        if (scope instanceof ClassScope) return (ClassScope) scope;</TD></TR><TR><TD CLASS="l">617</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="d">618</A></TD><TD>                return null; // may answer null if no type around</TD></TR><TR><TD CLASS="l">619</TD><TD>        }</TD></TR><TR><TD CLASS="l">620</TD><TD> </TD></TR><TR><TD CLASS="l">621</TD><TD>        public final MethodScope enclosingMethodScope() {</TD></TR><TR CLASS="z"><TD CLASS="l">622</TD><TD>                Scope scope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">623</TD><TD>                if (scope instanceof MethodScope) return (MethodScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">624</TD><TD>                while ((scope = scope.parent) != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">625</TD><TD>                        if (scope instanceof MethodScope) return (MethodScope) scope;</TD></TR><TR><TD CLASS="l">626</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">627</TD><TD>                return null; // may answer null if no method around</TD></TR><TR><TD CLASS="l">628</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="e">629</A></TD><TD> </TD></TR><TR><TD CLASS="l">630</TD><TD>        /* Answer the scope receiver type (could be parameterized)</TD></TR><TR><TD CLASS="l">631</TD><TD>        */</TD></TR><TR><TD CLASS="l">632</TD><TD>        public final ReferenceBinding enclosingReceiverType() {</TD></TR><TR CLASS="z"><TD CLASS="l">633</TD><TD>                Scope scope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">634</TD><TD>                AbstractMethodDeclaration inMethod =null;</TD></TR><TR><TD CLASS="l">635</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">636</TD><TD>                        if (scope instanceof MethodScope) {</TD></TR><TR CLASS="z"><TD CLASS="l">637</TD><TD>                                MethodScope methodScope = (MethodScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">638</TD><TD>                                inMethod = methodScope.referenceMethod();</TD></TR><TR CLASS="z"><TD CLASS="l">639</TD><TD>                                if (inMethod.inferredMethod!=null &amp;&amp; inMethod.inferredMethod.inType!=null &amp;&amp; inMethod.inferredMethod.inType.binding!=null)</TD></TR><TR CLASS="z"><TD CLASS="l">640</TD><TD>                                        return inMethod.inferredMethod.inType.binding;</TD></TR><TR><TD CLASS="l">641</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">642</TD><TD>                        else if (scope instanceof CompilationUnitScope) {</TD></TR><TR CLASS="z"><TD CLASS="l">643</TD><TD>                                CompilationUnitScope compilationUnitScope = (CompilationUnitScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">644</TD><TD>                                for (int i=0;i&lt;compilationUnitScope.referenceContext.numberInferredTypes;i++)</TD></TR><TR><TD CLASS="l">645</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">646</TD><TD>                                        InferredType type= compilationUnitScope.referenceContext.inferredTypes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">647</TD><TD>                                        if (type.containsMethod(inMethod))</TD></TR><TR CLASS="z"><TD CLASS="l">648</TD><TD>                                                return (ReferenceBinding)compilationUnitScope.getTypeOrPackage(type.getName(),Binding.TYPE);</TD></TR><TR><TD CLASS="l">649</TD><TD>                                }</TD></TR><TR><TD CLASS="l">650</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">651</TD><TD>                        if (scope instanceof ClassScope) {</TD></TR><TR CLASS="z"><TD CLASS="l">652</TD><TD>                                ClassScope classScope=(ClassScope)scope;</TD></TR><TR CLASS="z"><TD CLASS="l">653</TD><TD>                                if (classScope.referenceContext!=null)</TD></TR><TR CLASS="z"><TD CLASS="l">654</TD><TD>                                        return classScope.referenceContext.binding;</TD></TR><TR CLASS="z"><TD CLASS="l">655</TD><TD>                                if (classScope.inferredType!=null)</TD></TR><TR CLASS="z"><TD CLASS="l">656</TD><TD>                                        return classScope.inferredType.binding;</TD></TR><TR><TD CLASS="l">657</TD><TD>//                                return environment().convertToParameterizedType(((ClassScope) scope).referenceContext.binding);</TD></TR><TR><TD CLASS="l">658</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">659</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="c">660</A></TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l">661</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">662</TD><TD>        }</TD></TR><TR><TD CLASS="l">663</TD><TD>        public final CompilationUnitBinding enclosingCompilationUnit() {</TD></TR><TR CLASS="z"><TD CLASS="l">664</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">665</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">666</TD><TD>                        if (scope instanceof CompilationUnitScope) {</TD></TR><TR CLASS="z"><TD CLASS="l">667</TD><TD>                                return ((CompilationUnitScope) scope).referenceContext.compilationUnitBinding;</TD></TR><TR><TD CLASS="l">668</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">669</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">670</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l">671</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">672</TD><TD>        }</TD></TR><TR><TD CLASS="l">673</TD><TD> </TD></TR><TR><TD CLASS="l">674</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="f">675</A></TD><TD>         * Returns the immediately enclosing reference context, starting from current scope parent.</TD></TR><TR><TD CLASS="l">676</TD><TD>         * If starting on a class, it will skip current class. If starting on unitScope, returns null.</TD></TR><TR><TD CLASS="l">677</TD><TD>         */</TD></TR><TR><TD CLASS="l">678</TD><TD>        public ReferenceContext enclosingReferenceContext() {</TD></TR><TR CLASS="z"><TD CLASS="l">679</TD><TD>                Scope current = this;</TD></TR><TR CLASS="z"><TD CLASS="l">680</TD><TD>                while ((current = current.parent) != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">681</TD><TD>                        switch(current.kind) {</TD></TR><TR><TD CLASS="l">682</TD><TD>                                case METHOD_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">683</TD><TD>                                        return ((MethodScope) current).referenceContext;</TD></TR><TR><TD CLASS="l">684</TD><TD>                                case CLASS_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">685</TD><TD>                                        return ((ClassScope) current).referenceContext;</TD></TR><TR><TD CLASS="l">686</TD><TD>                                case COMPILATION_UNIT_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">687</TD><TD>                                        return ((CompilationUnitScope) current).referenceContext;</TD></TR><TR CLASS="z"><TD CLASS="l">688</TD><TD>                        }</TD></TR><TR><TD CLASS="l">689</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">690</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">691</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="10">692</A></TD><TD> </TD></TR><TR><TD CLASS="l">693</TD><TD>        /* Answer the scope enclosing source type (could be generic)</TD></TR><TR><TD CLASS="l">694</TD><TD>        */</TD></TR><TR><TD CLASS="l">695</TD><TD>        public final SourceTypeBinding enclosingSourceType() {</TD></TR><TR CLASS="z"><TD CLASS="l">696</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">697</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">698</TD><TD>                        if (scope instanceof ClassScope)</TD></TR><TR CLASS="z"><TD CLASS="l">699</TD><TD>                                return ((ClassScope) scope).getReferenceBinding();</TD></TR><TR CLASS="z"><TD CLASS="l">700</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">701</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="11">702</A></TD><TD>                return null;</TD></TR><TR><TD CLASS="l">703</TD><TD>        }</TD></TR><TR><TD CLASS="l">704</TD><TD> </TD></TR><TR><TD CLASS="l">705</TD><TD>        public final SourceTypeBinding enclosingTypeBinding() {</TD></TR><TR CLASS="z"><TD CLASS="l">706</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">707</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">708</TD><TD>                        if (scope instanceof ClassScope)</TD></TR><TR CLASS="z"><TD CLASS="l">709</TD><TD>                                return ((ClassScope) scope).getReferenceBinding();</TD></TR><TR CLASS="z"><TD CLASS="l">710</TD><TD>                        else if (scope instanceof CompilationUnitScope)</TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>                                return ((CompilationUnitScope) scope).referenceContext.compilationUnitBinding;</TD></TR><TR CLASS="z"><TD CLASS="l">712</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">713</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="12">714</A></TD><TD>                return null;</TD></TR><TR><TD CLASS="l">715</TD><TD>        }</TD></TR><TR><TD CLASS="l">716</TD><TD> </TD></TR><TR><TD CLASS="l">717</TD><TD>        public final LookupEnvironment environment() {</TD></TR><TR CLASS="z"><TD CLASS="l">718</TD><TD>                Scope scope, unitScope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">719</TD><TD>                while ((scope = unitScope.parent) != null)</TD></TR><TR CLASS="z"><TD CLASS="l">720</TD><TD>                        unitScope = scope;</TD></TR><TR CLASS="z"><TD CLASS="l">721</TD><TD>                return ((CompilationUnitScope) unitScope).environment;</TD></TR><TR><TD CLASS="l">722</TD><TD>        }</TD></TR><TR><TD CLASS="l">723</TD><TD> </TD></TR><TR><TD CLASS="l">724</TD><TD>        // abstract method lookup lookup (since maybe missing default abstract methods)</TD></TR><TR><TD CLASS="l">725</TD><TD>        protected MethodBinding findDefaultAbstractMethod(</TD></TR><TR><TD CLASS="l">726</TD><TD>                ReferenceBinding receiverType,</TD></TR><TR><TD CLASS="l">727</TD><TD>                char[] selector,</TD></TR><TR><TD CLASS="l">728</TD><TD>                TypeBinding[] argumentTypes,</TD></TR><TR><TD CLASS="l">729</TD><TD>                InvocationSite invocationSite,</TD></TR><TR><TD CLASS="l"><A NAME="14">730</A></TD><TD>                ReferenceBinding classHierarchyStart,</TD></TR><TR><TD CLASS="l">731</TD><TD>                ObjectVector found,</TD></TR><TR><TD CLASS="l">732</TD><TD>                MethodBinding concreteMatch) {</TD></TR><TR><TD CLASS="l">733</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">734</TD><TD>                int startFoundSize = found.size;</TD></TR><TR CLASS="z"><TD CLASS="l">735</TD><TD>                ReferenceBinding currentType = classHierarchyStart;</TD></TR><TR CLASS="z"><TD CLASS="l">736</TD><TD>                while (currentType != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">737</TD><TD>                        findMethodInSuperInterfaces(currentType, selector, found);</TD></TR><TR CLASS="z"><TD CLASS="l">738</TD><TD>                        currentType = currentType.superclass();</TD></TR><TR><TD CLASS="l">739</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">740</TD><TD>                MethodBinding[] candidates = null;</TD></TR><TR CLASS="z"><TD CLASS="l">741</TD><TD>                int candidatesCount = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">742</TD><TD>                MethodBinding problemMethod = null;</TD></TR><TR CLASS="z"><TD CLASS="l">743</TD><TD>                int foundSize = found.size;</TD></TR><TR CLASS="z"><TD CLASS="l">744</TD><TD>                if (foundSize &gt; startFoundSize) {</TD></TR><TR><TD CLASS="l">745</TD><TD>                        // argument type compatibility check</TD></TR><TR CLASS="z"><TD CLASS="l">746</TD><TD>                        for (int i = startFoundSize; i &lt; foundSize; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">747</TD><TD>                                MethodBinding methodBinding = (MethodBinding) found.elementAt(i);</TD></TR><TR CLASS="z"><TD CLASS="l">748</TD><TD>                                MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">749</TD><TD>                                if (compatibleMethod != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">750</TD><TD>                                        if (compatibleMethod.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">751</TD><TD>                                                if (candidatesCount == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">752</TD><TD>                                                        candidates = new MethodBinding[foundSize - startFoundSize + 1];</TD></TR><TR CLASS="z"><TD CLASS="l">753</TD><TD>                                                        if (concreteMatch != null)</TD></TR><TR CLASS="z"><TD CLASS="l">754</TD><TD>                                                                candidates[candidatesCount++] = concreteMatch;</TD></TR><TR><TD CLASS="l">755</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">756</TD><TD>                                                candidates[candidatesCount++] = compatibleMethod;</TD></TR><TR CLASS="z"><TD CLASS="l">757</TD><TD>                                        } else if (problemMethod == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">758</TD><TD>                                                problemMethod = compatibleMethod;</TD></TR><TR><TD CLASS="l">759</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">760</TD><TD>                                }</TD></TR><TR><TD CLASS="l">761</TD><TD>                        }</TD></TR><TR><TD CLASS="l">762</TD><TD>                }</TD></TR><TR><TD CLASS="l">763</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">764</TD><TD>                if (candidatesCount &lt; 2) {</TD></TR><TR CLASS="z"><TD CLASS="l">765</TD><TD>                        if (concreteMatch == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">766</TD><TD>                                if (candidatesCount == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">767</TD><TD>                                        return problemMethod; // can be null</TD></TR><TR CLASS="z"><TD CLASS="l">768</TD><TD>                                concreteMatch = candidates[0];</TD></TR><TR><TD CLASS="l">769</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">770</TD><TD>                        compilationUnitScope().recordTypeReferences(concreteMatch.thrownExceptions);</TD></TR><TR CLASS="z"><TD CLASS="l">771</TD><TD>                        return concreteMatch;</TD></TR><TR><TD CLASS="l">772</TD><TD>                }</TD></TR><TR><TD CLASS="l">773</TD><TD>                // no need to check for visibility - interface methods are public</TD></TR><TR CLASS="z"><TD CLASS="l">774</TD><TD>                if (compilerOptions().complianceLevel &gt;= ClassFileConstants.JDK1_4)</TD></TR><TR CLASS="z"><TD CLASS="l">775</TD><TD>                        return mostSpecificMethodBinding(candidates, candidatesCount, argumentTypes, invocationSite, receiverType);</TD></TR><TR CLASS="z"><TD CLASS="l">776</TD><TD>                return mostSpecificInterfaceMethodBinding(candidates, candidatesCount, invocationSite);</TD></TR><TR><TD CLASS="l"><A NAME="15">777</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">778</TD><TD> </TD></TR><TR><TD CLASS="l">779</TD><TD>        // Internal use only</TD></TR><TR><TD CLASS="l">780</TD><TD>        public ReferenceBinding findDirectMemberType(char[] typeName, ReferenceBinding enclosingType) {</TD></TR><TR CLASS="z"><TD CLASS="l">781</TD><TD>                if ((enclosingType.tagBits &amp; TagBits.HasNoMemberTypes) != 0)</TD></TR><TR CLASS="z"><TD CLASS="l">782</TD><TD>                        return null; // know it has no member types (nor inherited member types)</TD></TR><TR><TD CLASS="l">783</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">784</TD><TD>                ReferenceBinding enclosingReceiverType = enclosingReceiverType();</TD></TR><TR CLASS="z"><TD CLASS="l">785</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">786</TD><TD>                unitScope.recordReference(enclosingType, typeName);</TD></TR><TR CLASS="z"><TD CLASS="l">787</TD><TD>                ReferenceBinding memberType = enclosingType.getMemberType(typeName);</TD></TR><TR CLASS="z"><TD CLASS="l">788</TD><TD>                if (memberType != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">789</TD><TD>                        unitScope.recordTypeReference(memberType);</TD></TR><TR CLASS="z"><TD CLASS="l">790</TD><TD>                        if (enclosingReceiverType == null</TD></TR><TR CLASS="z"><TD CLASS="l">791</TD><TD>                                ? memberType.canBeSeenBy(getCurrentPackage())</TD></TR><TR CLASS="z"><TD CLASS="l">792</TD><TD>                                : memberType.canBeSeenBy(enclosingType, enclosingReceiverType))</TD></TR><TR CLASS="z"><TD CLASS="l">793</TD><TD>                                        return memberType;</TD></TR><TR CLASS="z"><TD CLASS="l">794</TD><TD>                        return new ProblemReferenceBinding(typeName, memberType, ProblemReasons.NotVisible);</TD></TR><TR><TD CLASS="l">795</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">796</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">797</TD><TD>        }</TD></TR><TR><TD CLASS="l">798</TD><TD> </TD></TR><TR><TD CLASS="l">799</TD><TD>        // Internal use only</TD></TR><TR><TD CLASS="l">800</TD><TD>        public MethodBinding findExactMethod(</TD></TR><TR><TD CLASS="l">801</TD><TD>                ReferenceBinding receiverType,</TD></TR><TR><TD CLASS="l"><A NAME="16">802</A></TD><TD>                char[] selector,</TD></TR><TR><TD CLASS="l">803</TD><TD>                TypeBinding[] argumentTypes,</TD></TR><TR><TD CLASS="l">804</TD><TD>                InvocationSite invocationSite) {</TD></TR><TR><TD CLASS="l">805</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">806</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">807</TD><TD>                unitScope.recordTypeReferences(argumentTypes);</TD></TR><TR CLASS="z"><TD CLASS="l">808</TD><TD>                MethodBinding exactMethod = (receiverType!=null) ?</TD></TR><TR CLASS="z"><TD CLASS="l">809</TD><TD>                        receiverType.getExactMethod(selector, argumentTypes, unitScope) :</TD></TR><TR CLASS="z"><TD CLASS="l">810</TD><TD>                                unitScope.referenceContext.compilationUnitBinding.getExactMethod(selector, argumentTypes, unitScope);</TD></TR><TR CLASS="z"><TD CLASS="l">811</TD><TD>                if (exactMethod != null &amp;&amp; exactMethod.typeVariables == Binding.NO_TYPE_VARIABLES &amp;&amp; !exactMethod.isBridge()) {</TD></TR><TR><TD CLASS="l">812</TD><TD>                        // must find both methods for this case: &lt;S extends A&gt; void foo() {}  and  &lt;N extends B&gt; N foo() { return null; }</TD></TR><TR><TD CLASS="l">813</TD><TD>                        // or find an inherited method when the exact match is to a bridge method</TD></TR><TR CLASS="z"><TD CLASS="l">814</TD><TD>                        unitScope.recordTypeReferences(exactMethod.thrownExceptions);</TD></TR><TR><TD CLASS="l">815</TD><TD>                        // special treatment for Object.getClass() in 1.5 mode (substitute parameterized return type)</TD></TR><TR CLASS="z"><TD CLASS="l">816</TD><TD>                        if (receiverType!=null &amp;&amp; receiverType.isInterface() || exactMethod.canBeSeenBy(receiverType, invocationSite, this)) {</TD></TR><TR><TD CLASS="l">817</TD><TD>//                                if (receiverType.id != T_JavaLangObject</TD></TR><TR><TD CLASS="l">818</TD><TD>//                                        &amp;&amp; argumentTypes == Binding.NO_PARAMETERS</TD></TR><TR><TD CLASS="l">819</TD><TD>//                                    &amp;&amp; CharOperation.equals(selector, GETCLASS)</TD></TR><TR><TD CLASS="l">820</TD><TD>//                                    &amp;&amp; exactMethod.returnType.isParameterizedType()/*1.5*/) {</TD></TR><TR><TD CLASS="l">821</TD><TD>//                                                return ParameterizedMethodBinding.instantiateGetClass(receiverType, exactMethod, this);</TD></TR><TR><TD CLASS="l">822</TD><TD>//                            }</TD></TR><TR><TD CLASS="l">823</TD><TD>//                                // targeting a generic method could find an exact match with variable return type</TD></TR><TR><TD CLASS="l">824</TD><TD>//                                if (invocationSite.genericTypeArguments() != null) {</TD></TR><TR><TD CLASS="l">825</TD><TD>//                                        exactMethod = computeCompatibleMethod(exactMethod, argumentTypes, invocationSite);</TD></TR><TR><TD CLASS="l">826</TD><TD>//                                }</TD></TR><TR CLASS="z"><TD CLASS="l">827</TD><TD>                                return exactMethod;</TD></TR><TR><TD CLASS="l">828</TD><TD>                        }</TD></TR><TR><TD CLASS="l">829</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">830</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">831</TD><TD>        }</TD></TR><TR><TD CLASS="l">832</TD><TD> </TD></TR><TR><TD CLASS="l">833</TD><TD>        // Internal use only</TD></TR><TR><TD CLASS="l">834</TD><TD>        /*        Answer the field binding that corresponds to fieldName.</TD></TR><TR><TD CLASS="l">835</TD><TD>                Start the lookup at the receiverType.</TD></TR><TR><TD CLASS="l">836</TD><TD>                InvocationSite implements</TD></TR><TR><TD CLASS="l">837</TD><TD>                        isSuperAccess(); this is used to determine if the discovered field is visible.</TD></TR><TR><TD CLASS="l">838</TD><TD>                Only fields defined by the receiverType or its supertypes are answered;</TD></TR><TR><TD CLASS="l">839</TD><TD>                a field of an enclosing type will not be found using this API.</TD></TR><TR><TD CLASS="l">840</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="17">841</A></TD><TD>                If no visible field is discovered, null is answered.</TD></TR><TR><TD CLASS="l">842</TD><TD>        */</TD></TR><TR><TD CLASS="l">843</TD><TD>        public FieldBinding findField(TypeBinding receiverType, char[] fieldName, InvocationSite invocationSite, boolean needResolve) {</TD></TR><TR><TD CLASS="l">844</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">845</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">846</TD><TD>                unitScope.recordTypeReference(receiverType);</TD></TR><TR><TD CLASS="l">847</TD><TD> </TD></TR><TR><TD CLASS="l">848</TD><TD>                checkArrayField: {</TD></TR><TR><TD CLASS="l">849</TD><TD>                        TypeBinding leafType;</TD></TR><TR CLASS="z"><TD CLASS="l">850</TD><TD>                        switch (receiverType.kind()) {</TD></TR><TR><TD CLASS="l">851</TD><TD>                                case Binding.BASE_TYPE :</TD></TR><TR CLASS="z"><TD CLASS="l">852</TD><TD>                                        return null;</TD></TR><TR><TD CLASS="l">853</TD><TD>                                case Binding.WILDCARD_TYPE :</TD></TR><TR><TD CLASS="l">854</TD><TD>                                case Binding.TYPE_PARAMETER : // capture</TD></TR><TR CLASS="z"><TD CLASS="l">855</TD><TD>                                        TypeBinding receiverErasure = receiverType.erasure();</TD></TR><TR CLASS="z"><TD CLASS="l">856</TD><TD>                                        if (!receiverErasure.isArrayType())</TD></TR><TR CLASS="z"><TD CLASS="l">857</TD><TD>                                                break checkArrayField;</TD></TR><TR CLASS="z"><TD CLASS="l">858</TD><TD>                                        leafType = receiverErasure.leafComponentType();</TD></TR><TR CLASS="z"><TD CLASS="l">859</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">860</TD><TD>//                                case Binding.ARRAY_TYPE :</TD></TR><TR><TD CLASS="l">861</TD><TD>//                                        leafType = receiverType.leafComponentType();</TD></TR><TR><TD CLASS="l">862</TD><TD>//                                        break;</TD></TR><TR><TD CLASS="l">863</TD><TD>                                default:</TD></TR><TR CLASS="z"><TD CLASS="l">864</TD><TD>                                        break checkArrayField;</TD></TR><TR><TD CLASS="l">865</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">866</TD><TD>                        if (leafType instanceof ReferenceBinding)</TD></TR><TR CLASS="z"><TD CLASS="l">867</TD><TD>                                if (!((ReferenceBinding) leafType).canBeSeenBy(this))</TD></TR><TR CLASS="z"><TD CLASS="l">868</TD><TD>                                        return new ProblemFieldBinding((ReferenceBinding)leafType, fieldName, ProblemReasons.ReceiverTypeNotVisible);</TD></TR><TR CLASS="z"><TD CLASS="l">869</TD><TD>                        if (CharOperation.equals(fieldName, LENGTH))</TD></TR><TR CLASS="z"><TD CLASS="l">870</TD><TD>                                return ArrayBinding.ArrayLength;</TD></TR><TR CLASS="z"><TD CLASS="l">871</TD><TD>                        return null;</TD></TR><TR><TD CLASS="l">872</TD><TD>                }</TD></TR><TR><TD CLASS="l">873</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">874</TD><TD>                ReferenceBinding currentType = (ReferenceBinding) receiverType;</TD></TR><TR CLASS="z"><TD CLASS="l">875</TD><TD>                if (!currentType.canBeSeenBy(this))</TD></TR><TR CLASS="z"><TD CLASS="l">876</TD><TD>                        return new ProblemFieldBinding(currentType, fieldName, ProblemReasons.ReceiverTypeNotVisible);</TD></TR><TR><TD CLASS="l">877</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">878</TD><TD>                FieldBinding field = currentType.getField(fieldName, needResolve);</TD></TR><TR CLASS="z"><TD CLASS="l">879</TD><TD>                if (field != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">880</TD><TD>                        if (invocationSite == null</TD></TR><TR CLASS="z"><TD CLASS="l">881</TD><TD>                                ? field.canBeSeenBy(getCurrentPackage())</TD></TR><TR CLASS="z"><TD CLASS="l">882</TD><TD>                                : field.canBeSeenBy(currentType, invocationSite, this))</TD></TR><TR CLASS="z"><TD CLASS="l">883</TD><TD>                                        return field;</TD></TR><TR CLASS="z"><TD CLASS="l">884</TD><TD>                        return new ProblemFieldBinding(field /* closest match*/, field.declaringClass, fieldName, ProblemReasons.NotVisible);</TD></TR><TR><TD CLASS="l">885</TD><TD>                }</TD></TR><TR><TD CLASS="l">886</TD><TD>                // collect all superinterfaces of receiverType until the field is found in a supertype</TD></TR><TR CLASS="z"><TD CLASS="l">887</TD><TD>                ReferenceBinding[] interfacesToVisit = null;</TD></TR><TR CLASS="z"><TD CLASS="l">888</TD><TD>                int nextPosition = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">889</TD><TD>                FieldBinding visibleField = null;</TD></TR><TR CLASS="z"><TD CLASS="l">890</TD><TD>                boolean keepLooking = true;</TD></TR><TR CLASS="z"><TD CLASS="l">891</TD><TD>                FieldBinding notVisibleField = null;</TD></TR><TR><TD CLASS="l">892</TD><TD>                // we could hold onto the not visible field for extra error reporting</TD></TR><TR CLASS="z"><TD CLASS="l">893</TD><TD>                while (keepLooking) {</TD></TR><TR><TD CLASS="l">894</TD><TD>                        if (JavaScriptCore.IS_ECMASCRIPT4)</TD></TR><TR><TD CLASS="l">895</TD><TD>                        {</TD></TR><TR><TD CLASS="l">896</TD><TD>                                ReferenceBinding[] itsInterfaces = currentType.superInterfaces();</TD></TR><TR><TD CLASS="l">897</TD><TD>                                if (itsInterfaces == null) { // needed for statically imported types which don't know their hierarchy yet</TD></TR><TR><TD CLASS="l">898</TD><TD>                                        ((SourceTypeBinding) currentType).classScope.connectTypeHierarchy();</TD></TR><TR><TD CLASS="l">899</TD><TD>                                        itsInterfaces = currentType.superInterfaces();</TD></TR><TR><TD CLASS="l">900</TD><TD>                                }</TD></TR><TR><TD CLASS="l">901</TD><TD>                                if (itsInterfaces != null &amp;&amp; itsInterfaces != Binding.NO_SUPERINTERFACES) {</TD></TR><TR><TD CLASS="l">902</TD><TD>                                        if (interfacesToVisit == null) {</TD></TR><TR><TD CLASS="l">903</TD><TD>                                                interfacesToVisit = itsInterfaces;</TD></TR><TR><TD CLASS="l">904</TD><TD>                                                nextPosition = interfacesToVisit.length;</TD></TR><TR><TD CLASS="l">905</TD><TD>                                        } else {</TD></TR><TR><TD CLASS="l">906</TD><TD>                                                int itsLength = itsInterfaces.length;</TD></TR><TR><TD CLASS="l">907</TD><TD>                                                if (nextPosition + itsLength &gt;= interfacesToVisit.length)</TD></TR><TR><TD CLASS="l">908</TD><TD>                                                        System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);</TD></TR><TR><TD CLASS="l">909</TD><TD>                                                nextInterface : for (int a = 0; a &lt; itsLength; a++) {</TD></TR><TR><TD CLASS="l">910</TD><TD>                                                        ReferenceBinding next = itsInterfaces[a];</TD></TR><TR><TD CLASS="l">911</TD><TD>                                                        for (int b = 0; b &lt; nextPosition; b++)</TD></TR><TR><TD CLASS="l">912</TD><TD>                                                                if (next == interfacesToVisit[b]) continue nextInterface;</TD></TR><TR><TD CLASS="l">913</TD><TD>                                                        interfacesToVisit[nextPosition++] = next;</TD></TR><TR><TD CLASS="l">914</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">915</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">916</TD><TD>                                }</TD></TR><TR><TD CLASS="l">917</TD><TD> </TD></TR><TR><TD CLASS="l">918</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">919</TD><TD>                        if ((currentType = currentType.superclass()) == null)</TD></TR><TR CLASS="z"><TD CLASS="l">920</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">921</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">922</TD><TD>                        unitScope.recordTypeReference(currentType);</TD></TR><TR CLASS="z"><TD CLASS="l">923</TD><TD>                        if ((field = currentType.getField(fieldName, needResolve)) != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">924</TD><TD>                                keepLooking = false;</TD></TR><TR CLASS="z"><TD CLASS="l">925</TD><TD>                                if (field.canBeSeenBy(receiverType, invocationSite, this)) {</TD></TR><TR CLASS="z"><TD CLASS="l">926</TD><TD>                                        if (visibleField == null)</TD></TR><TR CLASS="z"><TD CLASS="l">927</TD><TD>                                                visibleField = field;</TD></TR><TR><TD CLASS="l">928</TD><TD>                                        else</TD></TR><TR CLASS="z"><TD CLASS="l">929</TD><TD>                                                return new ProblemFieldBinding(visibleField /* closest match*/, visibleField.declaringClass, fieldName, ProblemReasons.Ambiguous);</TD></TR><TR><TD CLASS="l">930</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">931</TD><TD>                                        if (notVisibleField == null)</TD></TR><TR CLASS="z"><TD CLASS="l">932</TD><TD>                                                notVisibleField = field;</TD></TR><TR><TD CLASS="l">933</TD><TD>                                }</TD></TR><TR><TD CLASS="l">934</TD><TD>                        }</TD></TR><TR><TD CLASS="l">935</TD><TD>                }</TD></TR><TR><TD CLASS="l">936</TD><TD> </TD></TR><TR><TD CLASS="l">937</TD><TD>                // walk all visible interfaces to find ambiguous references</TD></TR><TR><TD CLASS="l">938</TD><TD>                if (JavaScriptCore.IS_ECMASCRIPT4 &amp;&amp; interfacesToVisit != null) {</TD></TR><TR><TD CLASS="l">939</TD><TD>                        ProblemFieldBinding ambiguous = null;</TD></TR><TR><TD CLASS="l">940</TD><TD>                        done : for (int i = 0; i &lt; nextPosition; i++) {</TD></TR><TR><TD CLASS="l">941</TD><TD>                                ReferenceBinding anInterface = interfacesToVisit[i];</TD></TR><TR><TD CLASS="l">942</TD><TD>                                unitScope.recordTypeReference(anInterface);</TD></TR><TR><TD CLASS="l">943</TD><TD>                                if ((field = anInterface.getField(fieldName, true /*resolve*/)) != null) {</TD></TR><TR><TD CLASS="l">944</TD><TD>                                        if (visibleField == null) {</TD></TR><TR><TD CLASS="l">945</TD><TD>                                                visibleField = field;</TD></TR><TR><TD CLASS="l">946</TD><TD>                                        } else {</TD></TR><TR><TD CLASS="l">947</TD><TD>                                                ambiguous = new ProblemFieldBinding(visibleField /* closest match*/, visibleField.declaringClass, fieldName, ProblemReasons.Ambiguous);</TD></TR><TR><TD CLASS="l">948</TD><TD>                                                break done;</TD></TR><TR><TD CLASS="l">949</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">950</TD><TD>                                } else {</TD></TR><TR><TD CLASS="l">951</TD><TD>                                        ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();</TD></TR><TR><TD CLASS="l">952</TD><TD>                                        if (itsInterfaces != null &amp;&amp; itsInterfaces != Binding.NO_SUPERINTERFACES) {</TD></TR><TR><TD CLASS="l">953</TD><TD>                                                int itsLength = itsInterfaces.length;</TD></TR><TR><TD CLASS="l">954</TD><TD>                                                if (nextPosition + itsLength &gt;= interfacesToVisit.length)</TD></TR><TR><TD CLASS="l">955</TD><TD>                                                        System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);</TD></TR><TR><TD CLASS="l">956</TD><TD>                                                nextInterface : for (int a = 0; a &lt; itsLength; a++) {</TD></TR><TR><TD CLASS="l">957</TD><TD>                                                        ReferenceBinding next = itsInterfaces[a];</TD></TR><TR><TD CLASS="l">958</TD><TD>                                                        for (int b = 0; b &lt; nextPosition; b++)</TD></TR><TR><TD CLASS="l">959</TD><TD>                                                                if (next == interfacesToVisit[b]) continue nextInterface;</TD></TR><TR><TD CLASS="l">960</TD><TD>                                                        interfacesToVisit[nextPosition++] = next;</TD></TR><TR><TD CLASS="l">961</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">962</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">963</TD><TD>                                }</TD></TR><TR><TD CLASS="l">964</TD><TD>                        }</TD></TR><TR><TD CLASS="l">965</TD><TD>                        if (ambiguous != null)</TD></TR><TR><TD CLASS="l">966</TD><TD>                                return ambiguous;</TD></TR><TR><TD CLASS="l">967</TD><TD>                }</TD></TR><TR><TD CLASS="l">968</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">969</TD><TD>                if (visibleField != null)</TD></TR><TR CLASS="z"><TD CLASS="l">970</TD><TD>                        return visibleField;</TD></TR><TR CLASS="z"><TD CLASS="l">971</TD><TD>                if (notVisibleField != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">972</TD><TD>                        return new ProblemFieldBinding(notVisibleField, currentType, fieldName, ProblemReasons.NotVisible);</TD></TR><TR><TD CLASS="l">973</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">974</TD><TD>                return null;</TD></TR><TR><TD CLASS="l"><A NAME="18">975</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">976</TD><TD> </TD></TR><TR><TD CLASS="l">977</TD><TD>        // Internal use only</TD></TR><TR><TD CLASS="l">978</TD><TD>        public ReferenceBinding findMemberType(char[] typeName, ReferenceBinding enclosingType) {</TD></TR><TR CLASS="z"><TD CLASS="l">979</TD><TD>                if ((enclosingType.tagBits &amp; TagBits.HasNoMemberTypes) != 0)</TD></TR><TR CLASS="z"><TD CLASS="l">980</TD><TD>                        return null; // know it has no member types (nor inherited member types)</TD></TR><TR><TD CLASS="l">981</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">982</TD><TD>                ReferenceBinding enclosingSourceType = enclosingSourceType();</TD></TR><TR CLASS="z"><TD CLASS="l">983</TD><TD>                PackageBinding currentPackage = getCurrentPackage();</TD></TR><TR CLASS="z"><TD CLASS="l">984</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">985</TD><TD>                unitScope.recordReference(enclosingType, typeName);</TD></TR><TR CLASS="z"><TD CLASS="l">986</TD><TD>                ReferenceBinding memberType = enclosingType.getMemberType(typeName);</TD></TR><TR CLASS="z"><TD CLASS="l">987</TD><TD>                if (memberType != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">988</TD><TD>                        unitScope.recordTypeReference(memberType);</TD></TR><TR CLASS="z"><TD CLASS="l">989</TD><TD>                        if (enclosingSourceType == null</TD></TR><TR CLASS="z"><TD CLASS="l">990</TD><TD>                                ? memberType.canBeSeenBy(currentPackage)</TD></TR><TR CLASS="z"><TD CLASS="l">991</TD><TD>                                : memberType.canBeSeenBy(enclosingType, enclosingSourceType))</TD></TR><TR CLASS="z"><TD CLASS="l">992</TD><TD>                                        return memberType;</TD></TR><TR CLASS="z"><TD CLASS="l">993</TD><TD>                        return new ProblemReferenceBinding(typeName, memberType, ProblemReasons.NotVisible);</TD></TR><TR><TD CLASS="l">994</TD><TD>                }</TD></TR><TR><TD CLASS="l">995</TD><TD> </TD></TR><TR><TD CLASS="l">996</TD><TD>                // collect all superinterfaces of receiverType until the memberType is found in a supertype</TD></TR><TR CLASS="z"><TD CLASS="l">997</TD><TD>                ReferenceBinding currentType = enclosingType;</TD></TR><TR CLASS="z"><TD CLASS="l">998</TD><TD>                ReferenceBinding[] interfacesToVisit = null;</TD></TR><TR CLASS="z"><TD CLASS="l">999</TD><TD>                int nextPosition = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1000</TD><TD>                ReferenceBinding visibleMemberType = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1001</TD><TD>                boolean keepLooking = true;</TD></TR><TR CLASS="z"><TD CLASS="l">1002</TD><TD>                ReferenceBinding notVisible = null;</TD></TR><TR><TD CLASS="l">1003</TD><TD>                // we could hold onto the not visible field for extra error reporting</TD></TR><TR CLASS="z"><TD CLASS="l">1004</TD><TD>                while (keepLooking) {</TD></TR><TR CLASS="z"><TD CLASS="l">1005</TD><TD>                        ReferenceBinding[] itsInterfaces = currentType.superInterfaces();</TD></TR><TR CLASS="z"><TD CLASS="l">1006</TD><TD>                        if (itsInterfaces == null) { // needed for statically imported types which don't know their hierarchy yet</TD></TR><TR CLASS="z"><TD CLASS="l">1007</TD><TD>                                ReferenceBinding sourceType = currentType.isParameterizedType()</TD></TR><TR CLASS="z"><TD CLASS="l">1008</TD><TD>                                        ? ((ParameterizedTypeBinding) currentType).genericType()</TD></TR><TR CLASS="z"><TD CLASS="l">1009</TD><TD>                                        : currentType;</TD></TR><TR CLASS="z"><TD CLASS="l">1010</TD><TD>                                if (sourceType.isHierarchyBeingConnected())</TD></TR><TR CLASS="z"><TD CLASS="l">1011</TD><TD>                                        return null; // looking for an undefined member type in its own superclass ref</TD></TR><TR CLASS="z"><TD CLASS="l">1012</TD><TD>                                ((SourceTypeBinding) sourceType).classScope.connectTypeHierarchy();</TD></TR><TR CLASS="z"><TD CLASS="l">1013</TD><TD>                                itsInterfaces = currentType.superInterfaces();</TD></TR><TR><TD CLASS="l">1014</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1015</TD><TD>                        if (itsInterfaces != null &amp;&amp; itsInterfaces != Binding.NO_SUPERINTERFACES) {</TD></TR><TR CLASS="z"><TD CLASS="l">1016</TD><TD>                                if (interfacesToVisit == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1017</TD><TD>                                        interfacesToVisit = itsInterfaces;</TD></TR><TR CLASS="z"><TD CLASS="l">1018</TD><TD>                                        nextPosition = interfacesToVisit.length;</TD></TR><TR><TD CLASS="l">1019</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1020</TD><TD>                                        int itsLength = itsInterfaces.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1021</TD><TD>                                        if (nextPosition + itsLength &gt;= interfacesToVisit.length)</TD></TR><TR CLASS="z"><TD CLASS="l">1022</TD><TD>                                                System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1023</TD><TD>                                        nextInterface : for (int a = 0; a &lt; itsLength; a++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1024</TD><TD>                                                ReferenceBinding next = itsInterfaces[a];</TD></TR><TR CLASS="z"><TD CLASS="l">1025</TD><TD>                                                for (int b = 0; b &lt; nextPosition; b++)</TD></TR><TR CLASS="z"><TD CLASS="l">1026</TD><TD>                                                        if (next == interfacesToVisit[b]) continue nextInterface;</TD></TR><TR CLASS="z"><TD CLASS="l">1027</TD><TD>                                                interfacesToVisit[nextPosition++] = next;</TD></TR><TR><TD CLASS="l">1028</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1029</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1030</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1031</TD><TD>                        if ((currentType = currentType.superclass()) == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1032</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">1033</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1034</TD><TD>                        unitScope.recordReference(currentType, typeName);</TD></TR><TR CLASS="z"><TD CLASS="l">1035</TD><TD>                        if ((memberType = currentType.getMemberType(typeName)) != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1036</TD><TD>                                unitScope.recordTypeReference(memberType);</TD></TR><TR CLASS="z"><TD CLASS="l">1037</TD><TD>                                keepLooking = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1038</TD><TD>                                if (enclosingSourceType == null</TD></TR><TR CLASS="z"><TD CLASS="l">1039</TD><TD>                                        ? memberType.canBeSeenBy(currentPackage)</TD></TR><TR CLASS="z"><TD CLASS="l">1040</TD><TD>                                        : memberType.canBeSeenBy(enclosingType, enclosingSourceType)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1041</TD><TD>                                                if (visibleMemberType == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1042</TD><TD>                                                        visibleMemberType = memberType;</TD></TR><TR><TD CLASS="l">1043</TD><TD>                                                else</TD></TR><TR CLASS="z"><TD CLASS="l">1044</TD><TD>                                                        return new ProblemReferenceBinding(typeName, visibleMemberType, ProblemReasons.Ambiguous);</TD></TR><TR><TD CLASS="l">1045</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1046</TD><TD>                                        notVisible = memberType;</TD></TR><TR><TD CLASS="l">1047</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1048</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1049</TD><TD>                }</TD></TR><TR><TD CLASS="l">1050</TD><TD>                // walk all visible interfaces to find ambiguous references</TD></TR><TR CLASS="z"><TD CLASS="l">1051</TD><TD>                if (interfacesToVisit != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1052</TD><TD>                        ProblemReferenceBinding ambiguous = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1053</TD><TD>                        done : for (int i = 0; i &lt; nextPosition; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1054</TD><TD>                                ReferenceBinding anInterface = interfacesToVisit[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1055</TD><TD>                                unitScope.recordReference(anInterface, typeName);</TD></TR><TR CLASS="z"><TD CLASS="l">1056</TD><TD>                                if ((memberType = anInterface.getMemberType(typeName)) != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1057</TD><TD>                                        unitScope.recordTypeReference(memberType);</TD></TR><TR CLASS="z"><TD CLASS="l">1058</TD><TD>                                        if (visibleMemberType == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1059</TD><TD>                                                visibleMemberType = memberType;</TD></TR><TR><TD CLASS="l">1060</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1061</TD><TD>                                                ambiguous = new ProblemReferenceBinding(typeName, visibleMemberType, ProblemReasons.Ambiguous);</TD></TR><TR CLASS="z"><TD CLASS="l">1062</TD><TD>                                                break done;</TD></TR><TR><TD CLASS="l">1063</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1064</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1065</TD><TD>                                        ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();</TD></TR><TR CLASS="z"><TD CLASS="l">1066</TD><TD>                                        if (itsInterfaces != null &amp;&amp; itsInterfaces != Binding.NO_SUPERINTERFACES) {</TD></TR><TR CLASS="z"><TD CLASS="l">1067</TD><TD>                                                int itsLength = itsInterfaces.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1068</TD><TD>                                                if (nextPosition + itsLength &gt;= interfacesToVisit.length)</TD></TR><TR CLASS="z"><TD CLASS="l">1069</TD><TD>                                                        System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1070</TD><TD>                                                nextInterface : for (int a = 0; a &lt; itsLength; a++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1071</TD><TD>                                                        ReferenceBinding next = itsInterfaces[a];</TD></TR><TR CLASS="z"><TD CLASS="l">1072</TD><TD>                                                        for (int b = 0; b &lt; nextPosition; b++)</TD></TR><TR CLASS="z"><TD CLASS="l">1073</TD><TD>                                                                if (next == interfacesToVisit[b]) continue nextInterface;</TD></TR><TR CLASS="z"><TD CLASS="l">1074</TD><TD>                                                        interfacesToVisit[nextPosition++] = next;</TD></TR><TR><TD CLASS="l">1075</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1076</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1077</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1078</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1079</TD><TD>                        if (ambiguous != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1080</TD><TD>                                return ambiguous;</TD></TR><TR><TD CLASS="l">1081</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1082</TD><TD>                if (visibleMemberType != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1083</TD><TD>                        return visibleMemberType;</TD></TR><TR CLASS="z"><TD CLASS="l">1084</TD><TD>                if (notVisible != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1085</TD><TD>                        return new ProblemReferenceBinding(typeName, notVisible, ProblemReasons.NotVisible);</TD></TR><TR CLASS="z"><TD CLASS="l">1086</TD><TD>                return null;</TD></TR><TR><TD CLASS="l"><A NAME="19">1087</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1088</TD><TD> </TD></TR><TR><TD CLASS="l">1089</TD><TD>        // Internal use only - use findMethod()</TD></TR><TR><TD CLASS="l">1090</TD><TD>        public MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite) {</TD></TR><TR CLASS="z"><TD CLASS="l">1091</TD><TD>                ReferenceBinding currentType = receiverType;</TD></TR><TR CLASS="z"><TD CLASS="l">1092</TD><TD>                ObjectVector found = new ObjectVector(3);</TD></TR><TR CLASS="z"><TD CLASS="l">1093</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">1094</TD><TD>                unitScope.recordTypeReferences(argumentTypes);</TD></TR><TR><TD CLASS="l">1095</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1096</TD><TD>                if (receiverType==null)</TD></TR><TR><TD CLASS="l">1097</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1098</TD><TD>                        MethodBinding methodBinding = unitScope.referenceContext.compilationUnitBinding.getExactMethod(selector,argumentTypes, unitScope);</TD></TR><TR CLASS="z"><TD CLASS="l">1099</TD><TD>                        if (methodBinding==null)</TD></TR><TR CLASS="z"><TD CLASS="l">1100</TD><TD>                                methodBinding= new ProblemMethodBinding(selector, argumentTypes, ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">1101</TD><TD>                        return methodBinding;</TD></TR><TR><TD CLASS="l">1102</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1103</TD><TD>                boolean receiverTypeIsInterface = receiverType.isInterface();</TD></TR><TR><TD CLASS="l">1104</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1105</TD><TD>                if (receiverTypeIsInterface) {</TD></TR><TR CLASS="z"><TD CLASS="l">1106</TD><TD>                        unitScope.recordTypeReference(receiverType);</TD></TR><TR CLASS="z"><TD CLASS="l">1107</TD><TD>                        MethodBinding[] receiverMethods = receiverType.getMethods(selector);</TD></TR><TR CLASS="z"><TD CLASS="l">1108</TD><TD>                        if (receiverMethods.length &gt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1109</TD><TD>                                found.addAll(receiverMethods);</TD></TR><TR CLASS="z"><TD CLASS="l">1110</TD><TD>                        findMethodInSuperInterfaces(receiverType, selector, found);</TD></TR><TR CLASS="z"><TD CLASS="l">1111</TD><TD>                        currentType = getJavaLangObject();</TD></TR><TR><TD CLASS="l">1112</TD><TD>                }</TD></TR><TR><TD CLASS="l">1113</TD><TD> </TD></TR><TR><TD CLASS="l">1114</TD><TD>                // superclass lookup</TD></TR><TR CLASS="z"><TD CLASS="l">1115</TD><TD>                long complianceLevel = compilerOptions().complianceLevel;</TD></TR><TR CLASS="z"><TD CLASS="l">1116</TD><TD>                boolean isCompliant14 = complianceLevel &gt;= ClassFileConstants.JDK1_4;</TD></TR><TR CLASS="z"><TD CLASS="l">1117</TD><TD>                boolean isCompliant15 = complianceLevel &gt;= ClassFileConstants.JDK1_5;</TD></TR><TR CLASS="z"><TD CLASS="l">1118</TD><TD>                ReferenceBinding classHierarchyStart = currentType;</TD></TR><TR CLASS="z"><TD CLASS="l">1119</TD><TD>                while (currentType != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1120</TD><TD>                        unitScope.recordTypeReference(currentType);</TD></TR><TR CLASS="z"><TD CLASS="l">1121</TD><TD>                        MethodBinding[] currentMethods = currentType.getMethods(selector);</TD></TR><TR CLASS="z"><TD CLASS="l">1122</TD><TD>                        int currentLength = currentMethods.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1123</TD><TD>                        if (currentLength &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1124</TD><TD>                                if (isCompliant14 &amp;&amp; (receiverTypeIsInterface || found.size &gt; 0)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1125</TD><TD>                                        nextMethod: for (int i = 0, l = currentLength; i &lt; l; i++) { // currentLength can be modified inside the loop</TD></TR><TR CLASS="z"><TD CLASS="l">1126</TD><TD>                                                MethodBinding currentMethod = currentMethods[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1127</TD><TD>                                                if (currentMethod == null) continue nextMethod;</TD></TR><TR CLASS="z"><TD CLASS="l">1128</TD><TD>                                                if (receiverTypeIsInterface &amp;&amp; !currentMethod.isPublic()) { // only public methods from Object are visible to interface receiverTypes</TD></TR><TR CLASS="z"><TD CLASS="l">1129</TD><TD>                                                        currentLength--;</TD></TR><TR CLASS="z"><TD CLASS="l">1130</TD><TD>                                                        currentMethods[i] = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1131</TD><TD>                                                        continue nextMethod;</TD></TR><TR><TD CLASS="l">1132</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1133</TD><TD> </TD></TR><TR><TD CLASS="l">1134</TD><TD>                                                // if 1.4 compliant, must filter out redundant protected methods from superclasses</TD></TR><TR><TD CLASS="l">1135</TD><TD>                                                // protected method need to be checked only - default access is already dealt with in #canBeSeen implementation</TD></TR><TR><TD CLASS="l">1136</TD><TD>                                                // when checking that p.C -&gt; q.B -&gt; p.A cannot see default access members from A through B.</TD></TR><TR><TD CLASS="l">1137</TD><TD>                                                // if ((currentMethod.modifiers &amp; AccProtected) == 0) continue nextMethod;</TD></TR><TR><TD CLASS="l">1138</TD><TD>                                                // BUT we can also ignore any overridden method since we already know the better match (fixes 80028)</TD></TR><TR CLASS="z"><TD CLASS="l">1139</TD><TD>                                                for (int j = 0, max = found.size; j &lt; max; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1140</TD><TD>                                                        MethodBinding matchingMethod = (MethodBinding) found.elementAt(j);</TD></TR><TR CLASS="z"><TD CLASS="l">1141</TD><TD>                                                        if (currentMethod.areParametersEqual(matchingMethod)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1142</TD><TD>                                                                if (isCompliant15) {</TD></TR><TR CLASS="z"><TD CLASS="l">1143</TD><TD>                                                                        if (matchingMethod.typeVariables != Binding.NO_TYPE_VARIABLES &amp;&amp; invocationSite.genericTypeArguments() == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1144</TD><TD>                                                                                continue nextMethod; // keep inherited substituted methods to detect anonymous errors</TD></TR><TR CLASS="z"><TD CLASS="l">1145</TD><TD>                                                                        if (matchingMethod.hasSubstitutedParameters() &amp;&amp; !currentMethod.original().areParametersEqual(matchingMethod.original()))</TD></TR><TR CLASS="z"><TD CLASS="l">1146</TD><TD>                                                                                continue nextMethod; // keep inherited substituted methods to detect anonymous errors</TD></TR><TR CLASS="z"><TD CLASS="l">1147</TD><TD>                                                                        if (matchingMethod.isBridge() &amp;&amp; !currentMethod.isBridge())</TD></TR><TR CLASS="z"><TD CLASS="l">1148</TD><TD>                                                                                continue nextMethod; // keep inherited methods to find concrete method over a bridge method</TD></TR><TR><TD CLASS="l">1149</TD><TD>                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1150</TD><TD>                                                                currentLength--;</TD></TR><TR CLASS="z"><TD CLASS="l">1151</TD><TD>                                                                currentMethods[i] = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1152</TD><TD>                                                                continue nextMethod;</TD></TR><TR><TD CLASS="l">1153</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1154</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1155</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1156</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1157</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1158</TD><TD>                                if (currentLength &gt; 0) {</TD></TR><TR><TD CLASS="l">1159</TD><TD>                                        // append currentMethods, filtering out null entries</TD></TR><TR CLASS="z"><TD CLASS="l">1160</TD><TD>                                        if (currentMethods.length == currentLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">1161</TD><TD>                                                found.addAll(currentMethods);</TD></TR><TR><TD CLASS="l">1162</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1163</TD><TD>                                                for (int i = 0, max = currentMethods.length; i &lt; max; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1164</TD><TD>                                                        MethodBinding currentMethod = currentMethods[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1165</TD><TD>                                                        if (currentMethod != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1166</TD><TD>                                                                found.add(currentMethod);</TD></TR><TR><TD CLASS="l">1167</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1168</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1169</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1170</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1171</TD><TD>                        currentType = currentType.superclass();</TD></TR><TR><TD CLASS="l">1172</TD><TD>                }</TD></TR><TR><TD CLASS="l">1173</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1174</TD><TD>                if (found.size==0 &amp;&amp; (receiverType==null || receiverType instanceof CompilationUnitBinding))</TD></TR><TR><TD CLASS="l">1175</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1176</TD><TD>                        Binding binding = getTypeOrPackage(selector, Binding.METHOD);</TD></TR><TR CLASS="z"><TD CLASS="l">1177</TD><TD>                        if (binding instanceof MethodBinding)</TD></TR><TR><TD CLASS="l">1178</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1179</TD><TD>                                ((MethodBinding) binding).ensureBindingsAreComplete();</TD></TR><TR CLASS="z"><TD CLASS="l">1180</TD><TD>                                found.add(binding);</TD></TR><TR><TD CLASS="l">1181</TD><TD>                }</TD></TR><TR><TD CLASS="l">1182</TD><TD>                }</TD></TR><TR><TD CLASS="l">1183</TD><TD>                // if found several candidates, then eliminate those not matching argument types</TD></TR><TR CLASS="z"><TD CLASS="l">1184</TD><TD>                int foundSize = found.size;</TD></TR><TR CLASS="z"><TD CLASS="l">1185</TD><TD>                MethodBinding[] candidates = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1186</TD><TD>                int candidatesCount = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1187</TD><TD>                MethodBinding problemMethod = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1188</TD><TD>                boolean searchForDefaultAbstractMethod = isCompliant14 &amp;&amp; ! receiverTypeIsInterface &amp;&amp; (receiverType.isAbstract() || receiverType.isTypeVariable());</TD></TR><TR CLASS="z"><TD CLASS="l">1189</TD><TD>                if (foundSize &gt; 0) {</TD></TR><TR><TD CLASS="l">1190</TD><TD>                        // argument type compatibility check</TD></TR><TR CLASS="z"><TD CLASS="l">1191</TD><TD>                        for (int i = 0; i &lt; foundSize; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1192</TD><TD>                                MethodBinding methodBinding = (MethodBinding) found.elementAt(i);</TD></TR><TR CLASS="z"><TD CLASS="l">1193</TD><TD>                                MethodBinding compatibleMethod = methodBinding;//computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">1194</TD><TD>                                if (compatibleMethod != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1195</TD><TD>                                        if (compatibleMethod.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1196</TD><TD>                                                if (foundSize == 1 &amp;&amp; compatibleMethod.canBeSeenBy(receiverType, invocationSite, this)) {</TD></TR><TR><TD CLASS="l">1197</TD><TD>                                                        // return the single visible match now</TD></TR><TR CLASS="z"><TD CLASS="l">1198</TD><TD>                                                        if (searchForDefaultAbstractMethod)</TD></TR><TR CLASS="z"><TD CLASS="l">1199</TD><TD>                                                                return findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, compatibleMethod);</TD></TR><TR CLASS="z"><TD CLASS="l">1200</TD><TD>                                                        unitScope.recordTypeReferences(compatibleMethod.thrownExceptions);</TD></TR><TR CLASS="z"><TD CLASS="l">1201</TD><TD>                                                        return compatibleMethod;</TD></TR><TR><TD CLASS="l">1202</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1203</TD><TD>                                                if (candidatesCount == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1204</TD><TD>                                                        candidates = new MethodBinding[foundSize];</TD></TR><TR CLASS="z"><TD CLASS="l">1205</TD><TD>                                                candidates[candidatesCount++] = compatibleMethod;</TD></TR><TR CLASS="z"><TD CLASS="l">1206</TD><TD>                                        } else if (problemMethod == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1207</TD><TD>                                                problemMethod = compatibleMethod;</TD></TR><TR><TD CLASS="l">1208</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1209</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1210</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1211</TD><TD>                }</TD></TR><TR><TD CLASS="l">1212</TD><TD> </TD></TR><TR><TD CLASS="l">1213</TD><TD>                // no match was found</TD></TR><TR CLASS="z"><TD CLASS="l">1214</TD><TD>                if (candidatesCount == 0) {</TD></TR><TR><TD CLASS="l">1215</TD><TD>                        // abstract classes may get a match in interfaces; for non abstract</TD></TR><TR><TD CLASS="l">1216</TD><TD>                        // classes, reduces secondary errors since missing interface method</TD></TR><TR><TD CLASS="l">1217</TD><TD>                        // error is already reported</TD></TR><TR CLASS="z"><TD CLASS="l">1218</TD><TD>                        MethodBinding interfaceMethod =</TD></TR><TR CLASS="z"><TD CLASS="l">1219</TD><TD>                                findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, null);</TD></TR><TR CLASS="z"><TD CLASS="l">1220</TD><TD>                        if (interfaceMethod != null) return interfaceMethod;</TD></TR><TR CLASS="z"><TD CLASS="l">1221</TD><TD>                        if (found.size == 0) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">1222</TD><TD>                        if (problemMethod != null) return problemMethod;</TD></TR><TR><TD CLASS="l">1223</TD><TD> </TD></TR><TR><TD CLASS="l">1224</TD><TD>                        // still no match; try to find a close match when the parameter</TD></TR><TR><TD CLASS="l">1225</TD><TD>                        // order is wrong or missing some parameters</TD></TR><TR><TD CLASS="l">1226</TD><TD> </TD></TR><TR><TD CLASS="l">1227</TD><TD> </TD></TR><TR><TD CLASS="l">1228</TD><TD>                        // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=69471</TD></TR><TR><TD CLASS="l">1229</TD><TD>                        // bad guesses are foo(), when argument types have been supplied</TD></TR><TR><TD CLASS="l">1230</TD><TD>                        // and foo(X, Y), when the argument types are (int, float, Y)</TD></TR><TR><TD CLASS="l">1231</TD><TD>                        // so answer the method with the most argType matches and least parameter type mismatches</TD></TR><TR CLASS="z"><TD CLASS="l">1232</TD><TD>                        int bestArgMatches = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">1233</TD><TD>                        MethodBinding bestGuess = (MethodBinding) found.elementAt(0); // if no good match so just use the first one found</TD></TR><TR CLASS="z"><TD CLASS="l">1234</TD><TD>                        int argLength = argumentTypes.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1235</TD><TD>                        foundSize = found.size;</TD></TR><TR CLASS="z"><TD CLASS="l">1236</TD><TD>                        nextMethod : for (int i = 0; i &lt; foundSize; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1237</TD><TD>                                MethodBinding methodBinding = (MethodBinding) found.elementAt(i);</TD></TR><TR CLASS="z"><TD CLASS="l">1238</TD><TD>                                TypeBinding[] params = methodBinding.parameters;</TD></TR><TR CLASS="z"><TD CLASS="l">1239</TD><TD>                                int paramLength = params.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1240</TD><TD>                                int argMatches = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1241</TD><TD>                                next: for (int a = 0; a &lt; argLength; a++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1242</TD><TD>                                        TypeBinding arg = argumentTypes[a];</TD></TR><TR CLASS="z"><TD CLASS="l">1243</TD><TD>                                        for (int p = a == 0 ? 0 : a - 1; p &lt; paramLength &amp;&amp; p &lt; a + 1; p++) { // look one slot before &amp; after to see if the type matches</TD></TR><TR CLASS="z"><TD CLASS="l">1244</TD><TD>                                                if (params[p] == arg) {</TD></TR><TR CLASS="z"><TD CLASS="l">1245</TD><TD>                                                        argMatches++;</TD></TR><TR CLASS="z"><TD CLASS="l">1246</TD><TD>                                                        continue next;</TD></TR><TR><TD CLASS="l">1247</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1248</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1249</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1250</TD><TD>                                if (argMatches &lt; bestArgMatches)</TD></TR><TR CLASS="z"><TD CLASS="l">1251</TD><TD>                                        continue nextMethod;</TD></TR><TR CLASS="z"><TD CLASS="l">1252</TD><TD>                                if (argMatches == bestArgMatches) {</TD></TR><TR CLASS="z"><TD CLASS="l">1253</TD><TD>                                        int diff1 = paramLength &lt; argLength ? 2 * (argLength - paramLength) : paramLength - argLength;</TD></TR><TR CLASS="z"><TD CLASS="l">1254</TD><TD>                                        int bestLength = bestGuess.parameters.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1255</TD><TD>                                        int diff2 = bestLength &lt; argLength ? 2 * (argLength - bestLength) : bestLength - argLength;</TD></TR><TR CLASS="z"><TD CLASS="l">1256</TD><TD>                                        if (diff1 &gt;= diff2)</TD></TR><TR CLASS="z"><TD CLASS="l">1257</TD><TD>                                                continue nextMethod;</TD></TR><TR><TD CLASS="l">1258</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1259</TD><TD>                                bestArgMatches = argMatches;</TD></TR><TR CLASS="z"><TD CLASS="l">1260</TD><TD>                                bestGuess = methodBinding;</TD></TR><TR><TD CLASS="l">1261</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1262</TD><TD>                        return bestGuess;</TD></TR><TR><TD CLASS="l">1263</TD><TD>//                        return new ProblemMethodBinding(bestGuess, bestGuess.selector, argumentTypes, ProblemReasons.NotFound);</TD></TR><TR><TD CLASS="l">1264</TD><TD>                }</TD></TR><TR><TD CLASS="l">1265</TD><TD> </TD></TR><TR><TD CLASS="l">1266</TD><TD>                // tiebreak using visibility check</TD></TR><TR CLASS="z"><TD CLASS="l">1267</TD><TD>                int visiblesCount = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1268</TD><TD>                if (receiverTypeIsInterface) {</TD></TR><TR CLASS="z"><TD CLASS="l">1269</TD><TD>                        if (candidatesCount == 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1270</TD><TD>                                unitScope.recordTypeReferences(candidates[0].thrownExceptions);</TD></TR><TR CLASS="z"><TD CLASS="l">1271</TD><TD>                                return candidates[0];</TD></TR><TR><TD CLASS="l">1272</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1273</TD><TD>                        visiblesCount = candidatesCount;</TD></TR><TR><TD CLASS="l">1274</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1275</TD><TD>                        for (int i = 0; i &lt; candidatesCount; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1276</TD><TD>                                MethodBinding methodBinding = candidates[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1277</TD><TD>                                if (methodBinding.canBeSeenBy(receiverType, invocationSite,</TD></TR><TR CLASS="z"><TD CLASS="l">1278</TD><TD>                                                this)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1279</TD><TD>                                        if (visiblesCount != i) {</TD></TR><TR CLASS="z"><TD CLASS="l">1280</TD><TD>                                                candidates[i] = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1281</TD><TD>                                                candidates[visiblesCount] = methodBinding;</TD></TR><TR><TD CLASS="l">1282</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1283</TD><TD>                                        visiblesCount++;</TD></TR><TR><TD CLASS="l">1284</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1285</TD><TD> </TD></TR><TR><TD CLASS="l">1286</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1287</TD><TD>                        if (visiblesCount == 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">1288</TD><TD>                                if (searchForDefaultAbstractMethod)</TD></TR><TR CLASS="z"><TD CLASS="l">1289</TD><TD>                                        return findDefaultAbstractMethod(receiverType, selector,</TD></TR><TR CLASS="z"><TD CLASS="l">1290</TD><TD>                                                        argumentTypes, invocationSite, classHierarchyStart,</TD></TR><TR CLASS="z"><TD CLASS="l">1291</TD><TD>                                                        found, candidates[0]);</TD></TR><TR CLASS="z"><TD CLASS="l">1292</TD><TD>                                unitScope.recordTypeReferences(candidates[0].thrownExceptions);</TD></TR><TR CLASS="z"><TD CLASS="l">1293</TD><TD>                                return candidates[0];</TD></TR><TR><TD CLASS="l">1294</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1295</TD><TD>                        if (visiblesCount == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1296</TD><TD>                                MethodBinding interfaceMethod = findDefaultAbstractMethod(</TD></TR><TR CLASS="z"><TD CLASS="l">1297</TD><TD>                                                receiverType, selector, argumentTypes, invocationSite,</TD></TR><TR CLASS="z"><TD CLASS="l">1298</TD><TD>                                                classHierarchyStart, found, null);</TD></TR><TR CLASS="z"><TD CLASS="l">1299</TD><TD>                                if (interfaceMethod != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1300</TD><TD>                                        return interfaceMethod;</TD></TR><TR CLASS="z"><TD CLASS="l">1301</TD><TD>                                return new ProblemMethodBinding(candidates[0],</TD></TR><TR CLASS="z"><TD CLASS="l">1302</TD><TD>                                                candidates[0].selector, candidates[0].parameters,</TD></TR><TR CLASS="z"><TD CLASS="l">1303</TD><TD>                                                ProblemReasons.NotVisible);</TD></TR><TR><TD CLASS="l">1304</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1305</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1306</TD><TD>                if (complianceLevel &lt;= ClassFileConstants.JDK1_3) {</TD></TR><TR CLASS="z"><TD CLASS="l">1307</TD><TD>                        ReferenceBinding declaringClass = candidates[0].declaringClass;</TD></TR><TR CLASS="z"><TD CLASS="l">1308</TD><TD>                        return !declaringClass.isInterface()</TD></TR><TR CLASS="z"><TD CLASS="l">1309</TD><TD>                                ? mostSpecificClassMethodBinding(candidates, visiblesCount, invocationSite)</TD></TR><TR CLASS="z"><TD CLASS="l">1310</TD><TD>                                : mostSpecificInterfaceMethodBinding(candidates, visiblesCount, invocationSite);</TD></TR><TR><TD CLASS="l">1311</TD><TD>                }</TD></TR><TR><TD CLASS="l">1312</TD><TD> </TD></TR><TR><TD CLASS="l">1313</TD><TD>                // check for duplicate parameterized methods</TD></TR><TR CLASS="z"><TD CLASS="l">1314</TD><TD>                if (compilerOptions().sourceLevel &gt;= ClassFileConstants.JDK1_5) {</TD></TR><TR CLASS="z"><TD CLASS="l">1315</TD><TD>                        for (int i = 0; i &lt; visiblesCount; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1316</TD><TD>                                MethodBinding current = candidates[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1317</TD><TD>                                if (current instanceof ParameterizedGenericMethodBinding)</TD></TR><TR CLASS="z"><TD CLASS="l">1318</TD><TD>                                        current = ((ParameterizedGenericMethodBinding) current).originalMethod;</TD></TR><TR CLASS="z"><TD CLASS="l">1319</TD><TD>                                if (current instanceof ParameterizedMethodBinding)</TD></TR><TR CLASS="z"><TD CLASS="l">1320</TD><TD>                                        for (int j = i + 1; j &lt; visiblesCount; j++)</TD></TR><TR CLASS="z"><TD CLASS="l">1321</TD><TD>                                                if (current.declaringClass == candidates[j].declaringClass &amp;&amp; current.areParametersEqual(candidates[j]))</TD></TR><TR CLASS="z"><TD CLASS="l">1322</TD><TD>                                                        return new ProblemMethodBinding(candidates[i], candidates[i].selector, candidates[i].parameters, ProblemReasons.Ambiguous);</TD></TR><TR><TD CLASS="l">1323</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1324</TD><TD>                }</TD></TR><TR><TD CLASS="l">1325</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1326</TD><TD>                MethodBinding mostSpecificMethod = mostSpecificMethodBinding(candidates, visiblesCount, argumentTypes, invocationSite, receiverType);</TD></TR><TR CLASS="z"><TD CLASS="l">1327</TD><TD>                if (searchForDefaultAbstractMethod) { // search interfaces for a better match</TD></TR><TR CLASS="z"><TD CLASS="l">1328</TD><TD>                        if (mostSpecificMethod.isValidBinding())</TD></TR><TR><TD CLASS="l">1329</TD><TD>                                // see if there is a better match in the interfaces - see AutoBoxingTest 99</TD></TR><TR CLASS="z"><TD CLASS="l">1330</TD><TD>                                return findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, mostSpecificMethod);</TD></TR><TR><TD CLASS="l">1331</TD><TD>                        // see if there is a match in the interfaces - see LookupTest#84</TD></TR><TR CLASS="z"><TD CLASS="l">1332</TD><TD>                        MethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, null);</TD></TR><TR CLASS="z"><TD CLASS="l">1333</TD><TD>                        if (interfaceMethod != null &amp;&amp; interfaceMethod.isValidBinding() /* else return the same error as before */)</TD></TR><TR CLASS="z"><TD CLASS="l">1334</TD><TD>                                return interfaceMethod;</TD></TR><TR><TD CLASS="l">1335</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1336</TD><TD>                return mostSpecificMethod;</TD></TR><TR><TD CLASS="l">1337</TD><TD>        }</TD></TR><TR><TD CLASS="l">1338</TD><TD> </TD></TR><TR><TD CLASS="l">1339</TD><TD>        // Internal use only</TD></TR><TR><TD CLASS="l">1340</TD><TD>        public MethodBinding findMethodForArray(</TD></TR><TR><TD CLASS="l">1341</TD><TD>                ArrayBinding receiverType,</TD></TR><TR><TD CLASS="l"><A NAME="1a">1342</A></TD><TD>                char[] selector,</TD></TR><TR><TD CLASS="l">1343</TD><TD>                TypeBinding[] argumentTypes,</TD></TR><TR><TD CLASS="l">1344</TD><TD>                InvocationSite invocationSite) {</TD></TR><TR><TD CLASS="l">1345</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1346</TD><TD>                TypeBinding leafType = receiverType.leafComponentType();</TD></TR><TR CLASS="z"><TD CLASS="l">1347</TD><TD>                if (leafType instanceof ReferenceBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">1348</TD><TD>                        if (!((ReferenceBinding) leafType).canBeSeenBy(this))</TD></TR><TR CLASS="z"><TD CLASS="l">1349</TD><TD>                                return new ProblemMethodBinding(selector, Binding.NO_PARAMETERS, (ReferenceBinding)leafType, ProblemReasons.ReceiverTypeNotVisible);</TD></TR><TR><TD CLASS="l">1350</TD><TD>                }</TD></TR><TR><TD CLASS="l">1351</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1352</TD><TD>                ReferenceBinding object = getJavaLangObject();</TD></TR><TR CLASS="z"><TD CLASS="l">1353</TD><TD>                MethodBinding methodBinding = object.getExactMethod(selector, argumentTypes, null);</TD></TR><TR CLASS="z"><TD CLASS="l">1354</TD><TD>                if (methodBinding != null) {</TD></TR><TR><TD CLASS="l">1355</TD><TD>                        // handle the method clone() specially... cannot be protected or throw exceptions</TD></TR><TR CLASS="z"><TD CLASS="l">1356</TD><TD>                        if (argumentTypes == Binding.NO_PARAMETERS) {</TD></TR><TR CLASS="z"><TD CLASS="l">1357</TD><TD>                            switch (selector[0]) {</TD></TR><TR><TD CLASS="l">1358</TD><TD>                                case 'c':</TD></TR><TR CLASS="z"><TD CLASS="l">1359</TD><TD>                                    if (CharOperation.equals(selector, CLONE)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1360</TD><TD>                                                        return new UpdatedMethodBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1361</TD><TD>                                                                compilerOptions().targetJDK &gt;= ClassFileConstants.JDK1_4 ? (TypeBinding)receiverType : (TypeBinding)object, // remember its array type for codegen purpose on target&gt;=1.4.0</TD></TR><TR CLASS="z"><TD CLASS="l">1362</TD><TD>                                                                (methodBinding.modifiers &amp; ~ClassFileConstants.AccProtected) | ClassFileConstants.AccPublic,</TD></TR><TR CLASS="z"><TD CLASS="l">1363</TD><TD>                                                                CLONE,</TD></TR><TR CLASS="z"><TD CLASS="l">1364</TD><TD>                                                                methodBinding.returnType,</TD></TR><TR CLASS="z"><TD CLASS="l">1365</TD><TD>                                                                argumentTypes,</TD></TR><TR CLASS="z"><TD CLASS="l">1366</TD><TD>                                                                null,</TD></TR><TR CLASS="z"><TD CLASS="l">1367</TD><TD>                                                                object);</TD></TR><TR><TD CLASS="l">1368</TD><TD>                                    }</TD></TR><TR><TD CLASS="l">1369</TD><TD>                                    break;</TD></TR><TR><TD CLASS="l">1370</TD><TD>                                case 'g':</TD></TR><TR CLASS="z"><TD CLASS="l">1371</TD><TD>                                    if (CharOperation.equals(selector, GETCLASS) &amp;&amp; methodBinding.returnType.isParameterizedType()/*1.5*/) {</TD></TR><TR CLASS="z"><TD CLASS="l">1372</TD><TD>                                                        return ParameterizedMethodBinding.instantiateGetClass(receiverType, methodBinding, this);</TD></TR><TR><TD CLASS="l">1373</TD><TD>                                    }</TD></TR><TR><TD CLASS="l">1374</TD><TD>                                    break;</TD></TR><TR><TD CLASS="l">1375</TD><TD>                            }</TD></TR><TR><TD CLASS="l">1376</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1377</TD><TD>                        if (methodBinding.canBeSeenBy(receiverType, invocationSite, this))</TD></TR><TR CLASS="z"><TD CLASS="l">1378</TD><TD>                                return methodBinding;</TD></TR><TR><TD CLASS="l">1379</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1380</TD><TD>                methodBinding = findMethod(object, selector, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">1381</TD><TD>                if (methodBinding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1382</TD><TD>                        return new ProblemMethodBinding(selector, argumentTypes, ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1b">1383</A></TD><TD>                return methodBinding;</TD></TR><TR><TD CLASS="l">1384</TD><TD>        }</TD></TR><TR><TD CLASS="l">1385</TD><TD> </TD></TR><TR><TD CLASS="l">1386</TD><TD>        protected void findMethodInSuperInterfaces(ReferenceBinding currentType, char[] selector, ObjectVector found) {</TD></TR><TR CLASS="z"><TD CLASS="l">1387</TD><TD>                ReferenceBinding[] itsInterfaces = currentType.superInterfaces();</TD></TR><TR CLASS="z"><TD CLASS="l">1388</TD><TD>                if (itsInterfaces != null &amp;&amp; itsInterfaces != Binding.NO_SUPERINTERFACES) {</TD></TR><TR CLASS="z"><TD CLASS="l">1389</TD><TD>                        ReferenceBinding[] interfacesToVisit = itsInterfaces;</TD></TR><TR CLASS="z"><TD CLASS="l">1390</TD><TD>                        int nextPosition = interfacesToVisit.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1391</TD><TD>                        for (int i = 0; i &lt; nextPosition; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1392</TD><TD>                                currentType = interfacesToVisit[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1393</TD><TD>                                compilationUnitScope().recordTypeReference(currentType);</TD></TR><TR CLASS="z"><TD CLASS="l">1394</TD><TD>                                MethodBinding[] currentMethods = currentType.getMethods(selector);</TD></TR><TR CLASS="z"><TD CLASS="l">1395</TD><TD>                                if (currentMethods.length &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1396</TD><TD>                                        int foundSize = found.size;</TD></TR><TR CLASS="z"><TD CLASS="l">1397</TD><TD>                                        if (foundSize &gt; 0) {</TD></TR><TR><TD CLASS="l">1398</TD><TD>                                                // its possible to walk the same superinterface from different classes in the hierarchy</TD></TR><TR CLASS="z"><TD CLASS="l">1399</TD><TD>                                                next : for (int c = 0, l = currentMethods.length; c &lt; l; c++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1400</TD><TD>                                                        MethodBinding current = currentMethods[c];</TD></TR><TR CLASS="z"><TD CLASS="l">1401</TD><TD>                                                        for (int f = 0; f &lt; foundSize; f++)</TD></TR><TR CLASS="z"><TD CLASS="l">1402</TD><TD>                                                                if (current == found.elementAt(f)) continue next;</TD></TR><TR CLASS="z"><TD CLASS="l">1403</TD><TD>                                                        found.add(current);</TD></TR><TR><TD CLASS="l">1404</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1405</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1406</TD><TD>                                        found.addAll(currentMethods);</TD></TR><TR><TD CLASS="l">1407</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1408</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1409</TD><TD>                                if ((itsInterfaces = currentType.superInterfaces()) != null &amp;&amp; itsInterfaces != Binding.NO_SUPERINTERFACES) {</TD></TR><TR CLASS="z"><TD CLASS="l">1410</TD><TD>                                        int itsLength = itsInterfaces.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1411</TD><TD>                                        if (nextPosition + itsLength &gt;= interfacesToVisit.length)</TD></TR><TR CLASS="z"><TD CLASS="l">1412</TD><TD>                                                System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1413</TD><TD>                                        nextInterface : for (int a = 0; a &lt; itsLength; a++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1414</TD><TD>                                                ReferenceBinding next = itsInterfaces[a];</TD></TR><TR CLASS="z"><TD CLASS="l">1415</TD><TD>                                                for (int b = 0; b &lt; nextPosition; b++)</TD></TR><TR CLASS="z"><TD CLASS="l">1416</TD><TD>                                                        if (next == interfacesToVisit[b]) continue nextInterface;</TD></TR><TR CLASS="z"><TD CLASS="l">1417</TD><TD>                                                interfacesToVisit[nextPosition++] = next;</TD></TR><TR><TD CLASS="l">1418</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1419</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1420</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1421</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1422</TD><TD>        }</TD></TR><TR><TD CLASS="l">1423</TD><TD> </TD></TR><TR><TD CLASS="l">1424</TD><TD>        // Internal use only</TD></TR><TR><TD CLASS="l">1425</TD><TD>        public  Binding findBinding(</TD></TR><TR><TD CLASS="l">1426</TD><TD>                char[] typeName,</TD></TR><TR><TD CLASS="l"><A NAME="13">1427</A></TD><TD>                int mask,</TD></TR><TR><TD CLASS="l">1428</TD><TD>                PackageBinding declarationPackage,</TD></TR><TR><TD CLASS="l">1429</TD><TD>                PackageBinding invocationPackage, boolean searchEnvironment) {</TD></TR><TR><TD CLASS="l">1430</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1431</TD><TD>                compilationUnitScope().recordReference(declarationPackage.compoundName, typeName);</TD></TR><TR CLASS="z"><TD CLASS="l">1432</TD><TD>                Binding typeBinding = </TD></TR><TR CLASS="z"><TD CLASS="l">1433</TD><TD>                        (searchEnvironment) ? declarationPackage.getBinding(typeName,mask) :</TD></TR><TR CLASS="z"><TD CLASS="l">1434</TD><TD>                        declarationPackage.getBinding0(typeName, mask);</TD></TR><TR CLASS="z"><TD CLASS="l">1435</TD><TD>                if (typeBinding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1436</TD><TD>                        return null;</TD></TR><TR><TD CLASS="l">1437</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1438</TD><TD>                if (typeBinding.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1439</TD><TD>                        if (declarationPackage != invocationPackage &amp;&amp; typeBinding instanceof ReferenceBinding</TD></TR><TR CLASS="z"><TD CLASS="l">1440</TD><TD>                                        &amp;&amp; !((ReferenceBinding)typeBinding).canBeSeenBy(invocationPackage))</TD></TR><TR CLASS="z"><TD CLASS="l">1441</TD><TD>                                return new ProblemReferenceBinding(typeName,(ReferenceBinding) typeBinding, ProblemReasons.NotVisible);</TD></TR><TR><TD CLASS="l">1442</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1443</TD><TD>                return typeBinding;</TD></TR><TR><TD CLASS="l">1444</TD><TD>        }</TD></TR><TR><TD CLASS="l">1445</TD><TD> </TD></TR><TR><TD CLASS="l">1446</TD><TD>        // Internal use only</TD></TR><TR><TD CLASS="l">1447</TD><TD>        public ReferenceBinding findType(</TD></TR><TR><TD CLASS="l"><A NAME="1c">1448</A></TD><TD>                char[] typeName,</TD></TR><TR><TD CLASS="l">1449</TD><TD>                PackageBinding declarationPackage,</TD></TR><TR><TD CLASS="l">1450</TD><TD>                PackageBinding invocationPackage) {</TD></TR><TR><TD CLASS="l">1451</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1452</TD><TD>                return (ReferenceBinding)findBinding(typeName, Binding.TYPE|Binding.PACKAGE, declarationPackage, invocationPackage, true);</TD></TR><TR><TD CLASS="l"><A NAME="1d">1453</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1454</TD><TD> </TD></TR><TR><TD CLASS="l">1455</TD><TD>        public LocalVariableBinding findVariable(char[] variable) {</TD></TR><TR><TD CLASS="l">1456</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1457</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">1458</TD><TD>        }</TD></TR><TR><TD CLASS="l">1459</TD><TD> </TD></TR><TR><TD CLASS="l">1460</TD><TD>        /* API</TD></TR><TR><TD CLASS="l">1461</TD><TD>         *</TD></TR><TR><TD CLASS="l">1462</TD><TD>         *        Answer the binding that corresponds to the argument name.</TD></TR><TR><TD CLASS="l">1463</TD><TD>         *        flag is a mask of the following values VARIABLE (= FIELD or LOCAL), TYPE, PACKAGE.</TD></TR><TR><TD CLASS="l">1464</TD><TD>         *        Only bindings corresponding to the mask can be answered.</TD></TR><TR><TD CLASS="l">1465</TD><TD>         *</TD></TR><TR><TD CLASS="l">1466</TD><TD>         *        For example, getBinding(&#34;foo&#34;, VARIABLE, site) will answer</TD></TR><TR><TD CLASS="l">1467</TD><TD>         *        the binding for the field or local named &#34;foo&#34; (or an error binding if none exists).</TD></TR><TR><TD CLASS="l">1468</TD><TD>         *        If a type named &#34;foo&#34; exists, it will not be detected (and an error binding will be answered)</TD></TR><TR><TD CLASS="l">1469</TD><TD>         *</TD></TR><TR><TD CLASS="l">1470</TD><TD>         *        The VARIABLE mask has precedence over the TYPE mask.</TD></TR><TR><TD CLASS="l">1471</TD><TD>         *</TD></TR><TR><TD CLASS="l">1472</TD><TD>         *        If the VARIABLE mask is not set, neither fields nor locals will be looked for.</TD></TR><TR><TD CLASS="l">1473</TD><TD>         *</TD></TR><TR><TD CLASS="l">1474</TD><TD>         *        InvocationSite implements:</TD></TR><TR><TD CLASS="l">1475</TD><TD>         *                isSuperAccess(); this is used to determine if the discovered field is visible.</TD></TR><TR><TD CLASS="l"><A NAME="1f">1476</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">1477</TD><TD>         *        Limitations: cannot request FIELD independently of LOCAL, or vice versa</TD></TR><TR><TD CLASS="l">1478</TD><TD>         */</TD></TR><TR><TD CLASS="l">1479</TD><TD>        public Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve) {</TD></TR><TR CLASS="z"><TD CLASS="l">1480</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">1481</TD><TD>                LookupEnvironment env = unitScope.environment;</TD></TR><TR><TD CLASS="l">1482</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1483</TD><TD>                        env.missingClassFileLocation = invocationSite;</TD></TR><TR CLASS="z"><TD CLASS="l">1484</TD><TD>                        Binding binding = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1485</TD><TD>                        FieldBinding problemField = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1486</TD><TD>                        if ((mask &amp; Binding.VARIABLE) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1487</TD><TD>                                boolean insideStaticContext = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1488</TD><TD>                                boolean insideConstructorCall = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1489</TD><TD>                                boolean insideTypeAnnotation = false;</TD></TR><TR><TD CLASS="l">1490</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1491</TD><TD>                                FieldBinding foundField = null;</TD></TR><TR><TD CLASS="l">1492</TD><TD>                                // can be a problem field which is answered if a valid field is not found</TD></TR><TR CLASS="z"><TD CLASS="l">1493</TD><TD>                                ProblemFieldBinding foundInsideProblem = null;</TD></TR><TR><TD CLASS="l">1494</TD><TD>                                // inside Constructor call or inside static context</TD></TR><TR CLASS="z"><TD CLASS="l">1495</TD><TD>                                Scope scope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">1496</TD><TD>                                int depth = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1497</TD><TD>                                int foundDepth = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1498</TD><TD>                                ReferenceBinding foundActualReceiverType = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1499</TD><TD>                                done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found</TD></TR><TR CLASS="z"><TD CLASS="l">1500</TD><TD>                                        switch (scope.kind) {</TD></TR><TR><TD CLASS="l">1501</TD><TD>                                                case METHOD_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1502</TD><TD>                                                        MethodScope methodScope = (MethodScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">1503</TD><TD>                                                        insideStaticContext |= methodScope.isStatic;</TD></TR><TR CLASS="z"><TD CLASS="l">1504</TD><TD>                                                        insideConstructorCall |= methodScope.isConstructorCall;</TD></TR><TR CLASS="z"><TD CLASS="l">1505</TD><TD>                                                        insideTypeAnnotation = methodScope.insideTypeAnnotation;</TD></TR><TR><TD CLASS="l">1506</TD><TD> </TD></TR><TR><TD CLASS="l">1507</TD><TD>                                                        // Fall through... could duplicate the code below to save a cast - questionable optimization</TD></TR><TR><TD CLASS="l">1508</TD><TD>                                                case BLOCK_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1509</TD><TD>                                                        LocalVariableBinding variableBinding = scope.findVariable(name);</TD></TR><TR><TD CLASS="l">1510</TD><TD>                                                        // looks in this scope only</TD></TR><TR CLASS="z"><TD CLASS="l">1511</TD><TD>                                                        if (variableBinding != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1512</TD><TD>                                                                if (foundField != null &amp;&amp; foundField.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">1513</TD><TD>                                                                        return new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1514</TD><TD>                                                                                foundField, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1515</TD><TD>                                                                                foundField.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1516</TD><TD>                                                                                name,</TD></TR><TR CLASS="z"><TD CLASS="l">1517</TD><TD>                                                                                ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR CLASS="z"><TD CLASS="l">1518</TD><TD>                                                                if (depth &gt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1519</TD><TD>                                                                        invocationSite.setDepth(depth);</TD></TR><TR CLASS="z"><TD CLASS="l">1520</TD><TD>                                                                return variableBinding;</TD></TR><TR><TD CLASS="l">1521</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1522</TD><TD>                                                        break;</TD></TR><TR><TD CLASS="l">1523</TD><TD>                                                case CLASS_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1524</TD><TD>                                                        ClassScope classScope = (ClassScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">1525</TD><TD>                                                        ReferenceBinding receiverType = classScope.enclosingReceiverType();</TD></TR><TR CLASS="z"><TD CLASS="l">1526</TD><TD>                                                        if (!insideTypeAnnotation) {</TD></TR><TR CLASS="z"><TD CLASS="l">1527</TD><TD>                                                                FieldBinding fieldBinding = classScope.findField(receiverType, name, invocationSite, needResolve);</TD></TR><TR><TD CLASS="l">1528</TD><TD>                                                                // Use next line instead if willing to enable protected access accross inner types</TD></TR><TR><TD CLASS="l">1529</TD><TD>                                                                // FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);</TD></TR><TR><TD CLASS="l">1530</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1531</TD><TD>                                                                if (fieldBinding != null) { // skip it if we did not find anything</TD></TR><TR CLASS="z"><TD CLASS="l">1532</TD><TD>                                                                        if (fieldBinding.problemId() == ProblemReasons.Ambiguous) {</TD></TR><TR CLASS="z"><TD CLASS="l">1533</TD><TD>                                                                                if (foundField == null || foundField.problemId() == ProblemReasons.NotVisible)</TD></TR><TR><TD CLASS="l">1534</TD><TD>                                                                                        // supercedes any potential InheritedNameHidesEnclosingName problem</TD></TR><TR CLASS="z"><TD CLASS="l">1535</TD><TD>                                                                                        return fieldBinding;</TD></TR><TR><TD CLASS="l">1536</TD><TD>                                                                                // make the user qualify the field, likely wants the first inherited field (javac generates an ambiguous error instead)</TD></TR><TR CLASS="z"><TD CLASS="l">1537</TD><TD>                                                                                return new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1538</TD><TD>                                                                                        foundField, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1539</TD><TD>                                                                                        foundField.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1540</TD><TD>                                                                                        name,</TD></TR><TR CLASS="z"><TD CLASS="l">1541</TD><TD>                                                                                        ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR><TD CLASS="l">1542</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">1543</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1544</TD><TD>                                                                        ProblemFieldBinding insideProblem = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1545</TD><TD>                                                                        if (fieldBinding.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1546</TD><TD>                                                                                if (!fieldBinding.isStatic()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1547</TD><TD>                                                                                        if (insideConstructorCall) {</TD></TR><TR CLASS="z"><TD CLASS="l">1548</TD><TD>                                                                                                insideProblem =</TD></TR><TR CLASS="z"><TD CLASS="l">1549</TD><TD>                                                                                                        new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1550</TD><TD>                                                                                                                fieldBinding, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1551</TD><TD>                                                                                                                fieldBinding.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1552</TD><TD>                                                                                                                name,</TD></TR><TR CLASS="z"><TD CLASS="l">1553</TD><TD>                                                                                                                ProblemReasons.NonStaticReferenceInConstructorInvocation);</TD></TR><TR CLASS="z"><TD CLASS="l">1554</TD><TD>                                                                                        } else if (insideStaticContext) {</TD></TR><TR CLASS="z"><TD CLASS="l">1555</TD><TD>                                                                                                insideProblem =</TD></TR><TR CLASS="z"><TD CLASS="l">1556</TD><TD>                                                                                                        new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1557</TD><TD>                                                                                                                fieldBinding, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1558</TD><TD>                                                                                                                fieldBinding.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1559</TD><TD>                                                                                                                name,</TD></TR><TR CLASS="z"><TD CLASS="l">1560</TD><TD>                                                                                                                ProblemReasons.NonStaticReferenceInStaticContext);</TD></TR><TR><TD CLASS="l">1561</TD><TD>                                                                                        }</TD></TR><TR><TD CLASS="l">1562</TD><TD>                                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1563</TD><TD>                                                                                if (receiverType == fieldBinding.declaringClass || compilerOptions().complianceLevel &gt;= ClassFileConstants.JDK1_4) {</TD></TR><TR><TD CLASS="l">1564</TD><TD>                                                                                        // found a valid field in the 'immediate' scope (ie. not inherited)</TD></TR><TR><TD CLASS="l">1565</TD><TD>                                                                                        // OR in 1.4 mode (inherited shadows enclosing)</TD></TR><TR CLASS="z"><TD CLASS="l">1566</TD><TD>                                                                                        if (foundField == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1567</TD><TD>                                                                                                if (depth &gt; 0){</TD></TR><TR CLASS="z"><TD CLASS="l">1568</TD><TD>                                                                                                        invocationSite.setDepth(depth);</TD></TR><TR CLASS="z"><TD CLASS="l">1569</TD><TD>                                                                                                        invocationSite.setActualReceiverType(receiverType);</TD></TR><TR><TD CLASS="l">1570</TD><TD>                                                                                                }</TD></TR><TR><TD CLASS="l">1571</TD><TD>                                                                                                // return the fieldBinding if it is not declared in a superclass of the scope's binding (that is, inherited)</TD></TR><TR CLASS="z"><TD CLASS="l">1572</TD><TD>                                                                                                return insideProblem == null ? fieldBinding : insideProblem;</TD></TR><TR><TD CLASS="l">1573</TD><TD>                                                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1574</TD><TD>                                                                                        if (foundField.isValidBinding())</TD></TR><TR><TD CLASS="l">1575</TD><TD>                                                                                                // if a valid field was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)</TD></TR><TR CLASS="z"><TD CLASS="l">1576</TD><TD>                                                                                                if (foundField.declaringClass != fieldBinding.declaringClass)</TD></TR><TR><TD CLASS="l">1577</TD><TD>                                                                                                        // ie. have we found the same field - do not trust field identity yet</TD></TR><TR CLASS="z"><TD CLASS="l">1578</TD><TD>                                                                                                        return new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1579</TD><TD>                                                                                                                foundField, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1580</TD><TD>                                                                                                                foundField.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1581</TD><TD>                                                                                                                name,</TD></TR><TR CLASS="z"><TD CLASS="l">1582</TD><TD>                                                                                                                ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR><TD CLASS="l">1583</TD><TD>                                                                                }</TD></TR><TR><TD CLASS="l">1584</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">1585</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1586</TD><TD>                                                                        if (foundField == null || (foundField.problemId() == ProblemReasons.NotVisible &amp;&amp; fieldBinding.problemId() != ProblemReasons.NotVisible)) {</TD></TR><TR><TD CLASS="l">1587</TD><TD>                                                                                // only remember the fieldBinding if its the first one found or the previous one was not visible &amp; fieldBinding is...</TD></TR><TR CLASS="z"><TD CLASS="l">1588</TD><TD>                                                                                foundDepth = depth;</TD></TR><TR CLASS="z"><TD CLASS="l">1589</TD><TD>                                                                                foundActualReceiverType = receiverType;</TD></TR><TR CLASS="z"><TD CLASS="l">1590</TD><TD>                                                                                foundInsideProblem = insideProblem;</TD></TR><TR CLASS="z"><TD CLASS="l">1591</TD><TD>                                                                                foundField = fieldBinding;</TD></TR><TR><TD CLASS="l">1592</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">1593</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1594</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1595</TD><TD>                                                        insideTypeAnnotation = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1596</TD><TD>                                                        depth++;</TD></TR><TR CLASS="z"><TD CLASS="l">1597</TD><TD>                                                        insideStaticContext |= receiverType.isStatic();</TD></TR><TR><TD CLASS="l">1598</TD><TD>                                                        // 1EX5I8Z - accessing outer fields within a constructor call is permitted</TD></TR><TR><TD CLASS="l">1599</TD><TD>                                                        // in order to do so, we change the flag as we exit from the type, not the method</TD></TR><TR><TD CLASS="l">1600</TD><TD>                                                        // itself, because the class scope is used to retrieve the fields.</TD></TR><TR CLASS="z"><TD CLASS="l">1601</TD><TD>                                                        MethodScope enclosingMethodScope = scope.methodScope();</TD></TR><TR CLASS="z"><TD CLASS="l">1602</TD><TD>                                                        insideConstructorCall = enclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;</TD></TR><TR CLASS="z"><TD CLASS="l">1603</TD><TD>                                                        break;</TD></TR><TR><TD CLASS="l">1604</TD><TD>                                                case WITH_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1605</TD><TD>                                                        WithScope withScope = (WithScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">1606</TD><TD>                                                        TypeBinding withType = withScope.referenceContext;</TD></TR><TR CLASS="z"><TD CLASS="l">1607</TD><TD>                                                        FieldBinding fieldBinding = withScope.findField(withType, name, invocationSite, needResolve);</TD></TR><TR><TD CLASS="l">1608</TD><TD>                                                        // Use next line instead if willing to enable protected access accross inner types</TD></TR><TR><TD CLASS="l">1609</TD><TD>                                                        // FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);</TD></TR><TR><TD CLASS="l">1610</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1611</TD><TD>                                                        if (fieldBinding != null) { // skip it if we did not find anything</TD></TR><TR CLASS="z"><TD CLASS="l">1612</TD><TD>                                                                if (fieldBinding.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1613</TD><TD>                                                                        return fieldBinding;</TD></TR><TR><TD CLASS="l">1614</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1615</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1616</TD><TD>                                                        break;</TD></TR><TR><TD CLASS="l">1617</TD><TD>                                                        case COMPILATION_UNIT_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1618</TD><TD>                                                        if ( (mask &amp; (Binding.FIELD|Binding.VARIABLE)) &gt;0)</TD></TR><TR><TD CLASS="l">1619</TD><TD>                                                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1620</TD><TD>                                                                variableBinding = scope.findVariable(name);</TD></TR><TR><TD CLASS="l">1621</TD><TD>                                                        // looks in this scope only</TD></TR><TR CLASS="z"><TD CLASS="l">1622</TD><TD>                                                                if (variableBinding != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1623</TD><TD>                                                                        if (foundField != null &amp;&amp; foundField.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">1624</TD><TD>                                                                                return new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1625</TD><TD>                                                                                foundField, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1626</TD><TD>                                                                                foundField.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1627</TD><TD>                                                                                name,</TD></TR><TR CLASS="z"><TD CLASS="l">1628</TD><TD>                                                                                ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR CLASS="z"><TD CLASS="l">1629</TD><TD>                                                                        if (depth &gt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1630</TD><TD>                                                                                invocationSite.setDepth(depth);</TD></TR><TR CLASS="z"><TD CLASS="l">1631</TD><TD>                                                                        return variableBinding;</TD></TR><TR><TD CLASS="l">1632</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1633</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1634</TD><TD>                                                                if(unitScope.classScope()!=null) {</TD></TR><TR><TD CLASS="l">1635</TD><TD>                                                                        //ReferenceBinding bind = env.getType(new char[][]{unitScope.superTypeName});</TD></TR><TR><TD CLASS="l">1636</TD><TD>                                                                        //if(bind==null) break done;</TD></TR><TR CLASS="z"><TD CLASS="l">1637</TD><TD>                                                                        foundField = (unitScope.classScope()).findField(unitScope.superBinding, name, invocationSite, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1638</TD><TD>                                                                        if(foundField!=null &amp;&amp; foundField.isValidBinding()) {</TD></TR><TR><TD CLASS="l">1639</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1640</TD><TD>                                                                                return foundField;</TD></TR><TR><TD CLASS="l">1641</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">1642</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1643</TD><TD> </TD></TR><TR><TD CLASS="l">1644</TD><TD> </TD></TR><TR><TD CLASS="l">1645</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1646</TD><TD>                                                        }else if  ( (mask &amp; (Binding.METHOD)) &gt;0){</TD></TR><TR CLASS="z"><TD CLASS="l">1647</TD><TD>                                                                MethodBinding methodBinding = (unitScope.classScope()).findMethod(unitScope.superBinding, name, new TypeBinding[0], invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">1648</TD><TD>                                                                if(methodBinding!=null &amp;&amp; methodBinding.isValidBinding()) return methodBinding;</TD></TR><TR><TD CLASS="l">1649</TD><TD> </TD></TR><TR><TD CLASS="l">1650</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1651</TD><TD> </TD></TR><TR><TD CLASS="l">1652</TD><TD>                                                        break done;</TD></TR><TR CLASS="z"><TD CLASS="l">1653</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1654</TD><TD>                                        scope = scope.parent;</TD></TR><TR><TD CLASS="l">1655</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1656</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1657</TD><TD>                                if (foundInsideProblem != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1658</TD><TD>                                        return foundInsideProblem;</TD></TR><TR CLASS="z"><TD CLASS="l">1659</TD><TD>                                if (foundField != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1660</TD><TD>                                        if (foundField.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1661</TD><TD>                                                if (foundDepth &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1662</TD><TD>                                                        invocationSite.setDepth(foundDepth);</TD></TR><TR CLASS="z"><TD CLASS="l">1663</TD><TD>                                                        invocationSite.setActualReceiverType(foundActualReceiverType);</TD></TR><TR><TD CLASS="l">1664</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1665</TD><TD>                                                return foundField;</TD></TR><TR><TD CLASS="l">1666</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1667</TD><TD>                                        problemField = foundField;</TD></TR><TR CLASS="z"><TD CLASS="l">1668</TD><TD>                                        foundField = null;</TD></TR><TR><TD CLASS="l">1669</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1670</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1671</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1672</TD><TD>                        if ( (mask&amp;Binding.METHOD)!=0)</TD></TR><TR><TD CLASS="l">1673</TD><TD>                        {</TD></TR><TR><TD CLASS="l">1674</TD><TD>                                </TD></TR><TR CLASS="z"><TD CLASS="l">1675</TD><TD>                                Scope scope = this;</TD></TR><TR><TD CLASS="l">1676</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1677</TD><TD>                                done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found</TD></TR><TR CLASS="z"><TD CLASS="l">1678</TD><TD>                                        switch (scope.kind) {</TD></TR><TR><TD CLASS="l">1679</TD><TD>                                                case METHOD_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1680</TD><TD>                                                        MethodScope methodScope = (MethodScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">1681</TD><TD>                                                        binding = methodScope.findMethod(name, Binding.NO_PARAMETERS,true);</TD></TR><TR CLASS="z"><TD CLASS="l">1682</TD><TD>                                                        if (binding!=null)</TD></TR><TR CLASS="z"><TD CLASS="l">1683</TD><TD>                                                                return binding;</TD></TR><TR><TD CLASS="l">1684</TD><TD>                                                        break;</TD></TR><TR><TD CLASS="l">1685</TD><TD>                                                case WITH_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1686</TD><TD>                                                        WithScope withScope = (WithScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">1687</TD><TD>                                                        ReferenceBinding withType = withScope.referenceContext;</TD></TR><TR><TD CLASS="l">1688</TD><TD>                                                        // retrieve an exact visible match (if possible)</TD></TR><TR><TD CLASS="l">1689</TD><TD>                                                        // compilationUnitScope().recordTypeReference(receiverType);   not needed since receiver is the source type</TD></TR><TR CLASS="z"><TD CLASS="l">1690</TD><TD>                                                        MethodBinding methBinding = withScope.findExactMethod(withType, name, Binding.NO_PARAMETERS, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">1691</TD><TD>                                                        if (methBinding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1692</TD><TD>                                                                methBinding = withScope.findMethod(withType,name, Binding.NO_PARAMETERS, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">1693</TD><TD>                                                        if (methBinding != null) { // skip it if we did not find anything</TD></TR><TR CLASS="z"><TD CLASS="l">1694</TD><TD>                                                                        if (methBinding.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1695</TD><TD>                                                                                        return methBinding;</TD></TR><TR><TD CLASS="l">1696</TD><TD>                                                                                }</TD></TR><TR><TD CLASS="l">1697</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1698</TD><TD>                                                        break;</TD></TR><TR><TD CLASS="l">1699</TD><TD>                                                case CLASS_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1700</TD><TD>                                                        ClassScope classScope = (ClassScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">1701</TD><TD>                                                        ReferenceBinding receiverType = classScope.enclosingReceiverType();</TD></TR><TR CLASS="z"><TD CLASS="l">1702</TD><TD>                                                        break;</TD></TR><TR><TD CLASS="l">1703</TD><TD>                                                case COMPILATION_UNIT_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1704</TD><TD>                                                        CompilationUnitScope compilationUnitScope = (CompilationUnitScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">1705</TD><TD>                                                        CompilationUnitBinding compilationUnitBinding = compilationUnitScope.enclosingCompilationUnit();</TD></TR><TR CLASS="z"><TD CLASS="l">1706</TD><TD>                                                         receiverType = compilationUnitBinding;</TD></TR><TR CLASS="z"><TD CLASS="l">1707</TD><TD>                                                                MethodBinding methodBinding =</TD></TR><TR CLASS="z"><TD CLASS="l">1708</TD><TD>                                                                                  compilationUnitScope.findExactMethod(receiverType, name, Binding.NO_PARAMETERS, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">1709</TD><TD>                                                                if (methodBinding != null) { // skip it if we did not find anything</TD></TR><TR CLASS="z"><TD CLASS="l">1710</TD><TD>                                                                                        return methodBinding;</TD></TR><TR><TD CLASS="l">1711</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1712</TD><TD> </TD></TR><TR><TD CLASS="l">1713</TD><TD>                                                        break done;</TD></TR><TR CLASS="z"><TD CLASS="l">1714</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1715</TD><TD>                                        scope = scope.parent;</TD></TR><TR><TD CLASS="l">1716</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1717</TD><TD> </TD></TR><TR><TD CLASS="l">1718</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1719</TD><TD>                        // We did not find a local or instance variable.</TD></TR><TR CLASS="z"><TD CLASS="l">1720</TD><TD>                        if ((mask &amp; Binding.TYPE|Binding.VARIABLE|Binding.METHOD) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1721</TD><TD>                                if ((mask &amp; Binding.TYPE) != 0 &amp;&amp; (binding = getBaseType(name)) != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1722</TD><TD>                                        return binding;</TD></TR><TR CLASS="z"><TD CLASS="l">1723</TD><TD>                                binding = getTypeOrPackage(name,  mask);// (mask &amp; Binding.PACKAGE) == 0 ? Binding.TYPE : Binding.TYPE | Binding.PACKAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">1724</TD><TD>                                if (binding.isValidBinding() || mask == Binding.TYPE)</TD></TR><TR CLASS="z"><TD CLASS="l">1725</TD><TD>                                        return binding;</TD></TR><TR><TD CLASS="l">1726</TD><TD>                                // answer the problem type binding if we are only looking for a type</TD></TR><TR CLASS="z"><TD CLASS="l">1727</TD><TD>                        } else if ((mask &amp; Binding.PACKAGE) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1728</TD><TD>                                unitScope.recordSimpleReference(name);</TD></TR><TR CLASS="z"><TD CLASS="l">1729</TD><TD>                                if ((binding = env.getTopLevelPackage(name)) != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1730</TD><TD>                                        return binding;</TD></TR><TR><TD CLASS="l">1731</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1732</TD><TD>                        if (problemField != null) return problemField;</TD></TR><TR CLASS="z"><TD CLASS="l">1733</TD><TD>                        if (binding != null &amp;&amp; binding.problemId() != ProblemReasons.NotFound)</TD></TR><TR CLASS="z"><TD CLASS="l">1734</TD><TD>                                return binding; // answer the better problem binding</TD></TR><TR CLASS="z"><TD CLASS="l">1735</TD><TD>                        return new ProblemBinding(name, enclosingTypeBinding(), ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">1736</TD><TD>                } catch (AbortCompilation e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1737</TD><TD>                        e.updateContext(invocationSite, referenceCompilationUnit().compilationResult);</TD></TR><TR CLASS="z"><TD CLASS="l">1738</TD><TD>                        throw e;</TD></TR><TR CLASS="z"><TD CLASS="l">1739</TD><TD>                } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1740</TD><TD>                        env.missingClassFileLocation = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1741</TD><TD>                }</TD></TR><TR><TD CLASS="l">1742</TD><TD>        }</TD></TR><TR><TD CLASS="l">1743</TD><TD> </TD></TR><TR><TD CLASS="l">1744</TD><TD>        /* API</TD></TR><TR><TD CLASS="l">1745</TD><TD>         *</TD></TR><TR><TD CLASS="l">1746</TD><TD>         *        Answer the binding that corresponds to the argument name.</TD></TR><TR><TD CLASS="l">1747</TD><TD>         *        flag is a mask of the following values VARIABLE (= FIELD or LOCAL), TYPE, PACKAGE.</TD></TR><TR><TD CLASS="l">1748</TD><TD>         *        Only bindings corresponding to the mask can be answered.</TD></TR><TR><TD CLASS="l">1749</TD><TD>         *</TD></TR><TR><TD CLASS="l">1750</TD><TD>         *        For example, getBinding(&#34;foo&#34;, VARIABLE, site) will answer</TD></TR><TR><TD CLASS="l">1751</TD><TD>         *        the binding for the field or local named &#34;foo&#34; (or an error binding if none exists).</TD></TR><TR><TD CLASS="l">1752</TD><TD>         *        If a type named &#34;foo&#34; exists, it will not be detected (and an error binding will be answered)</TD></TR><TR><TD CLASS="l">1753</TD><TD>         *</TD></TR><TR><TD CLASS="l">1754</TD><TD>         *        The VARIABLE mask has precedence over the TYPE mask.</TD></TR><TR><TD CLASS="l">1755</TD><TD>         *</TD></TR><TR><TD CLASS="l">1756</TD><TD>         *        If the VARIABLE mask is not set, neither fields nor locals will be looked for.</TD></TR><TR><TD CLASS="l">1757</TD><TD>         *</TD></TR><TR><TD CLASS="l">1758</TD><TD>         *        InvocationSite implements:</TD></TR><TR><TD CLASS="l">1759</TD><TD>         *                isSuperAccess(); this is used to determine if the discovered field is visible.</TD></TR><TR><TD CLASS="l"><A NAME="36">1760</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">1761</TD><TD>         *        Limitations: cannot request FIELD independently of LOCAL, or vice versa</TD></TR><TR><TD CLASS="l">1762</TD><TD>         */</TD></TR><TR><TD CLASS="l">1763</TD><TD>        public Binding getLocalBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve) {</TD></TR><TR CLASS="z"><TD CLASS="l">1764</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR><TD CLASS="l">1765</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1766</TD><TD>                        Binding binding = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1767</TD><TD>                        FieldBinding problemField = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1768</TD><TD>                        if ((mask &amp; Binding.VARIABLE) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1769</TD><TD>                                boolean insideStaticContext = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1770</TD><TD>                                boolean insideConstructorCall = false;</TD></TR><TR><TD CLASS="l">1771</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1772</TD><TD>                                FieldBinding foundField = null;</TD></TR><TR><TD CLASS="l">1773</TD><TD>                                // can be a problem field which is answered if a valid field is not found</TD></TR><TR CLASS="z"><TD CLASS="l">1774</TD><TD>                                ProblemFieldBinding foundInsideProblem = null;</TD></TR><TR><TD CLASS="l">1775</TD><TD>                                // inside Constructor call or inside static context</TD></TR><TR CLASS="z"><TD CLASS="l">1776</TD><TD>                                Scope scope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">1777</TD><TD>                                int depth = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1778</TD><TD>                                int foundDepth = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1779</TD><TD>                                ReferenceBinding foundActualReceiverType = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1780</TD><TD>                                done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found</TD></TR><TR CLASS="z"><TD CLASS="l">1781</TD><TD>                                        switch (scope.kind) {</TD></TR><TR><TD CLASS="l">1782</TD><TD>                                                case METHOD_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1783</TD><TD>                                                        MethodScope methodScope = (MethodScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">1784</TD><TD>                                                        insideStaticContext |= methodScope.isStatic;</TD></TR><TR CLASS="z"><TD CLASS="l">1785</TD><TD>                                                        insideConstructorCall |= methodScope.isConstructorCall;</TD></TR><TR><TD CLASS="l">1786</TD><TD> </TD></TR><TR><TD CLASS="l">1787</TD><TD>                                                        // Fall through... could duplicate the code below to save a cast - questionable optimization</TD></TR><TR><TD CLASS="l">1788</TD><TD>                                                case BLOCK_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1789</TD><TD>                                                        LocalVariableBinding variableBinding = scope.findVariable(name);</TD></TR><TR><TD CLASS="l">1790</TD><TD>                                                        // looks in this scope only</TD></TR><TR CLASS="z"><TD CLASS="l">1791</TD><TD>                                                        if (variableBinding != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1792</TD><TD>                                                                if (foundField != null &amp;&amp; foundField.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">1793</TD><TD>                                                                        return new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1794</TD><TD>                                                                                foundField, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1795</TD><TD>                                                                                foundField.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1796</TD><TD>                                                                                name,</TD></TR><TR CLASS="z"><TD CLASS="l">1797</TD><TD>                                                                                ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR CLASS="z"><TD CLASS="l">1798</TD><TD>                                                                if (depth &gt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1799</TD><TD>                                                                        invocationSite.setDepth(depth);</TD></TR><TR CLASS="z"><TD CLASS="l">1800</TD><TD>                                                                return variableBinding;</TD></TR><TR><TD CLASS="l">1801</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1802</TD><TD>                                                        break;</TD></TR><TR><TD CLASS="l">1803</TD><TD>                                                case CLASS_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1804</TD><TD>                                                        ClassScope classScope = (ClassScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">1805</TD><TD>                                                        ReferenceBinding receiverType = classScope.enclosingReceiverType();</TD></TR><TR CLASS="z"><TD CLASS="l">1806</TD><TD>                                                        FieldBinding fieldBinding = classScope.findField(receiverType, name, invocationSite, needResolve);</TD></TR><TR><TD CLASS="l">1807</TD><TD>                                                        // Use next line instead if willing to enable protected access accross inner types</TD></TR><TR><TD CLASS="l">1808</TD><TD>                                                        // FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);</TD></TR><TR><TD CLASS="l">1809</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1810</TD><TD>                                                        if (fieldBinding != null) { // skip it if we did not find anything</TD></TR><TR CLASS="z"><TD CLASS="l">1811</TD><TD>                                                                if (fieldBinding.problemId() == ProblemReasons.Ambiguous) {</TD></TR><TR CLASS="z"><TD CLASS="l">1812</TD><TD>                                                                        if (foundField == null || foundField.problemId() == ProblemReasons.NotVisible)</TD></TR><TR><TD CLASS="l">1813</TD><TD>                                                                                // supercedes any potential InheritedNameHidesEnclosingName problem</TD></TR><TR CLASS="z"><TD CLASS="l">1814</TD><TD>                                                                                return fieldBinding;</TD></TR><TR><TD CLASS="l">1815</TD><TD>                                                                        // make the user qualify the field, likely wants the first inherited field (javac generates an ambiguous error instead)</TD></TR><TR CLASS="z"><TD CLASS="l">1816</TD><TD>                                                                        return new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1817</TD><TD>                                                                                foundField, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1818</TD><TD>                                                                                foundField.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1819</TD><TD>                                                                                name,</TD></TR><TR CLASS="z"><TD CLASS="l">1820</TD><TD>                                                                                ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR><TD CLASS="l">1821</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1822</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1823</TD><TD>                                                                ProblemFieldBinding insideProblem = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1824</TD><TD>                                                                if (fieldBinding.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1825</TD><TD>                                                                        if (!fieldBinding.isStatic()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1826</TD><TD>                                                                                if (insideConstructorCall) {</TD></TR><TR CLASS="z"><TD CLASS="l">1827</TD><TD>                                                                                        insideProblem =</TD></TR><TR CLASS="z"><TD CLASS="l">1828</TD><TD>                                                                                                new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1829</TD><TD>                                                                                                        fieldBinding, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1830</TD><TD>                                                                                                        fieldBinding.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1831</TD><TD>                                                                                                        name,</TD></TR><TR CLASS="z"><TD CLASS="l">1832</TD><TD>                                                                                                        ProblemReasons.NonStaticReferenceInConstructorInvocation);</TD></TR><TR CLASS="z"><TD CLASS="l">1833</TD><TD>                                                                                } else if (insideStaticContext) {</TD></TR><TR CLASS="z"><TD CLASS="l">1834</TD><TD>                                                                                        insideProblem =</TD></TR><TR CLASS="z"><TD CLASS="l">1835</TD><TD>                                                                                                new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1836</TD><TD>                                                                                                        fieldBinding, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1837</TD><TD>                                                                                                        fieldBinding.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1838</TD><TD>                                                                                                        name,</TD></TR><TR CLASS="z"><TD CLASS="l">1839</TD><TD>                                                                                                        ProblemReasons.NonStaticReferenceInStaticContext);</TD></TR><TR><TD CLASS="l">1840</TD><TD>                                                                                }</TD></TR><TR><TD CLASS="l">1841</TD><TD>                                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1842</TD><TD>                                                                        if (receiverType == fieldBinding.declaringClass || compilerOptions().complianceLevel &gt;= ClassFileConstants.JDK1_4) {</TD></TR><TR><TD CLASS="l">1843</TD><TD>                                                                                // found a valid field in the 'immediate' scope (ie. not inherited)</TD></TR><TR><TD CLASS="l">1844</TD><TD>                                                                                // OR in 1.4 mode (inherited shadows enclosing)</TD></TR><TR CLASS="z"><TD CLASS="l">1845</TD><TD>                                                                                if (foundField == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1846</TD><TD>                                                                                        if (depth &gt; 0){</TD></TR><TR CLASS="z"><TD CLASS="l">1847</TD><TD>                                                                                                invocationSite.setDepth(depth);</TD></TR><TR CLASS="z"><TD CLASS="l">1848</TD><TD>                                                                                                invocationSite.setActualReceiverType(receiverType);</TD></TR><TR><TD CLASS="l">1849</TD><TD>                                                                                        }</TD></TR><TR><TD CLASS="l">1850</TD><TD>                                                                                        // return the fieldBinding if it is not declared in a superclass of the scope's binding (that is, inherited)</TD></TR><TR CLASS="z"><TD CLASS="l">1851</TD><TD>                                                                                        return insideProblem == null ? fieldBinding : insideProblem;</TD></TR><TR><TD CLASS="l">1852</TD><TD>                                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1853</TD><TD>                                                                                if (foundField.isValidBinding())</TD></TR><TR><TD CLASS="l">1854</TD><TD>                                                                                        // if a valid field was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)</TD></TR><TR CLASS="z"><TD CLASS="l">1855</TD><TD>                                                                                        if (foundField.declaringClass != fieldBinding.declaringClass)</TD></TR><TR><TD CLASS="l">1856</TD><TD>                                                                                                // ie. have we found the same field - do not trust field identity yet</TD></TR><TR CLASS="z"><TD CLASS="l">1857</TD><TD>                                                                                                return new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1858</TD><TD>                                                                                                        foundField, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1859</TD><TD>                                                                                                        foundField.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1860</TD><TD>                                                                                                        name,</TD></TR><TR CLASS="z"><TD CLASS="l">1861</TD><TD>                                                                                                        ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR><TD CLASS="l">1862</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">1863</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1864</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1865</TD><TD>                                                                if (foundField == null || (foundField.problemId() == ProblemReasons.NotVisible &amp;&amp; fieldBinding.problemId() != ProblemReasons.NotVisible)) {</TD></TR><TR><TD CLASS="l">1866</TD><TD>                                                                        // only remember the fieldBinding if its the first one found or the previous one was not visible &amp; fieldBinding is...</TD></TR><TR CLASS="z"><TD CLASS="l">1867</TD><TD>                                                                        foundDepth = depth;</TD></TR><TR CLASS="z"><TD CLASS="l">1868</TD><TD>                                                                        foundActualReceiverType = receiverType;</TD></TR><TR CLASS="z"><TD CLASS="l">1869</TD><TD>                                                                        foundInsideProblem = insideProblem;</TD></TR><TR CLASS="z"><TD CLASS="l">1870</TD><TD>                                                                        foundField = fieldBinding;</TD></TR><TR><TD CLASS="l">1871</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1872</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1873</TD><TD>                                                        depth++;</TD></TR><TR CLASS="z"><TD CLASS="l">1874</TD><TD>                                                        insideStaticContext |= receiverType.isStatic();</TD></TR><TR><TD CLASS="l">1875</TD><TD>                                                        // 1EX5I8Z - accessing outer fields within a constructor call is permitted</TD></TR><TR><TD CLASS="l">1876</TD><TD>                                                        // in order to do so, we change the flag as we exit from the type, not the method</TD></TR><TR><TD CLASS="l">1877</TD><TD>                                                        // itself, because the class scope is used to retrieve the fields.</TD></TR><TR CLASS="z"><TD CLASS="l">1878</TD><TD>                                                        MethodScope enclosingMethodScope = scope.methodScope();</TD></TR><TR CLASS="z"><TD CLASS="l">1879</TD><TD>                                                        insideConstructorCall = enclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;</TD></TR><TR CLASS="z"><TD CLASS="l">1880</TD><TD>                                                        break;</TD></TR><TR><TD CLASS="l">1881</TD><TD>                                                case WITH_SCOPE :</TD></TR><TR><TD CLASS="l">1882</TD><TD>                                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1883</TD><TD>                                                        WithScope withScope = (WithScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">1884</TD><TD>                                                        TypeBinding withType = withScope.referenceContext;</TD></TR><TR CLASS="z"><TD CLASS="l">1885</TD><TD>                                                        FieldBinding withBinding = withScope.findField(withType, name, invocationSite, needResolve);</TD></TR><TR><TD CLASS="l">1886</TD><TD>                                                        // Use next line instead if willing to enable protected access accross inner types</TD></TR><TR><TD CLASS="l">1887</TD><TD>                                                        // FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);</TD></TR><TR><TD CLASS="l">1888</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1889</TD><TD>                                                        if (withBinding != null) { // skip it if we did not find anything</TD></TR><TR CLASS="z"><TD CLASS="l">1890</TD><TD>                                                                if (withBinding.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1891</TD><TD>                                                                        return withBinding;</TD></TR><TR><TD CLASS="l">1892</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1893</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1894</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1895</TD><TD>                                                        break;</TD></TR><TR><TD CLASS="l">1896</TD><TD>                                                        case COMPILATION_UNIT_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">1897</TD><TD>                                                        if ( (mask &amp; (Binding.FIELD|Binding.VARIABLE)) &gt;0)</TD></TR><TR><TD CLASS="l">1898</TD><TD>                                                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1899</TD><TD>                                                                variableBinding = scope.findVariable(name);</TD></TR><TR><TD CLASS="l">1900</TD><TD>                                                        // looks in this scope only</TD></TR><TR CLASS="z"><TD CLASS="l">1901</TD><TD>                                                                if (variableBinding != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1902</TD><TD>                                                                        if (foundField != null &amp;&amp; foundField.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">1903</TD><TD>                                                                                return new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">1904</TD><TD>                                                                                foundField, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">1905</TD><TD>                                                                                foundField.declaringClass,</TD></TR><TR CLASS="z"><TD CLASS="l">1906</TD><TD>                                                                                name,</TD></TR><TR CLASS="z"><TD CLASS="l">1907</TD><TD>                                                                                ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR CLASS="z"><TD CLASS="l">1908</TD><TD>                                                                        if (depth &gt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1909</TD><TD>                                                                                invocationSite.setDepth(depth);</TD></TR><TR CLASS="z"><TD CLASS="l">1910</TD><TD>                                                                        return variableBinding;</TD></TR><TR><TD CLASS="l">1911</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1912</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1913</TD><TD>                                                                if(unitScope.classScope()!=null) {</TD></TR><TR><TD CLASS="l">1914</TD><TD>                                                                        //ReferenceBinding bind = env.getType(new char[][]{unitScope.superTypeName});</TD></TR><TR><TD CLASS="l">1915</TD><TD>                                                                        //if(bind==null) break done;</TD></TR><TR CLASS="z"><TD CLASS="l">1916</TD><TD>                                                                        foundField = (unitScope.classScope()).findField(unitScope.superBinding, name, invocationSite, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1917</TD><TD>                                                                        if(foundField!=null &amp;&amp; foundField.isValidBinding()) {</TD></TR><TR><TD CLASS="l">1918</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1919</TD><TD>                                                                                return foundField;</TD></TR><TR><TD CLASS="l">1920</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">1921</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">1922</TD><TD> </TD></TR><TR><TD CLASS="l">1923</TD><TD> </TD></TR><TR><TD CLASS="l">1924</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1925</TD><TD>                                                        }else if  ( (mask &amp; (Binding.METHOD)) &gt;0){</TD></TR><TR CLASS="z"><TD CLASS="l">1926</TD><TD>                                                                MethodBinding methodBinding = (unitScope.classScope()).findMethod(unitScope.superBinding, name, new TypeBinding[0], invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">1927</TD><TD>                                                                if(methodBinding!=null &amp;&amp; methodBinding.isValidBinding()) return methodBinding;</TD></TR><TR><TD CLASS="l">1928</TD><TD> </TD></TR><TR><TD CLASS="l">1929</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">1930</TD><TD> </TD></TR><TR><TD CLASS="l">1931</TD><TD>                                                        break done;</TD></TR><TR CLASS="z"><TD CLASS="l">1932</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1933</TD><TD>                                        scope = scope.parent;</TD></TR><TR><TD CLASS="l">1934</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1935</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1936</TD><TD>                                if (foundInsideProblem != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1937</TD><TD>                                        return foundInsideProblem;</TD></TR><TR CLASS="z"><TD CLASS="l">1938</TD><TD>                                if (foundField != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1939</TD><TD>                                        if (foundField.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1940</TD><TD>                                                if (foundDepth &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1941</TD><TD>                                                        invocationSite.setDepth(foundDepth);</TD></TR><TR CLASS="z"><TD CLASS="l">1942</TD><TD>                                                        invocationSite.setActualReceiverType(foundActualReceiverType);</TD></TR><TR><TD CLASS="l">1943</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1944</TD><TD>                                                return foundField;</TD></TR><TR><TD CLASS="l">1945</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1946</TD><TD>                                        problemField = foundField;</TD></TR><TR CLASS="z"><TD CLASS="l">1947</TD><TD>                                        foundField = null;</TD></TR><TR><TD CLASS="l">1948</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1949</TD><TD> </TD></TR><TR><TD CLASS="l">1950</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1951</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1952</TD><TD>                        if ( (mask&amp;Binding.METHOD)!=0)</TD></TR><TR><TD CLASS="l">1953</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1954</TD><TD>                                MethodBinding methodBinding = findMethod(null, name, Binding.NO_PARAMETERS, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">1955</TD><TD>                                if (methodBinding!=null &amp;&amp; methodBinding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">1956</TD><TD>                                        return methodBinding;</TD></TR><TR><TD CLASS="l">1957</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1958</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1959</TD><TD>                        if (problemField != null) return problemField;</TD></TR><TR CLASS="z"><TD CLASS="l">1960</TD><TD>                        if (binding != null &amp;&amp; binding.problemId() != ProblemReasons.NotFound)</TD></TR><TR CLASS="z"><TD CLASS="l">1961</TD><TD>                                return binding; // answer the better problem binding</TD></TR><TR CLASS="z"><TD CLASS="l">1962</TD><TD>                        return new ProblemBinding(name, enclosingTypeBinding(), ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">1963</TD><TD>                } catch (AbortCompilation e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1964</TD><TD>                        e.updateContext(invocationSite, referenceCompilationUnit().compilationResult);</TD></TR><TR CLASS="z"><TD CLASS="l">1965</TD><TD>                        throw e;</TD></TR><TR><TD CLASS="l">1966</TD><TD>                } finally {</TD></TR><TR><TD CLASS="l"><A NAME="20">1967</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">1968</TD><TD>        }</TD></TR><TR><TD CLASS="l">1969</TD><TD> </TD></TR><TR><TD CLASS="l">1970</TD><TD>        public MethodBinding getConstructor(ReferenceBinding receiverType, TypeBinding[] argumentTypes, InvocationSite invocationSite) {</TD></TR><TR CLASS="z"><TD CLASS="l">1971</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">1972</TD><TD>                LookupEnvironment env = unitScope.environment;</TD></TR><TR><TD CLASS="l">1973</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1974</TD><TD>                        env.missingClassFileLocation = invocationSite;</TD></TR><TR CLASS="z"><TD CLASS="l">1975</TD><TD>                        unitScope.recordTypeReference(receiverType);</TD></TR><TR CLASS="z"><TD CLASS="l">1976</TD><TD>                        unitScope.recordTypeReferences(argumentTypes);</TD></TR><TR CLASS="z"><TD CLASS="l">1977</TD><TD>                        MethodBinding methodBinding = receiverType.getExactConstructor(argumentTypes);</TD></TR><TR CLASS="z"><TD CLASS="l">1978</TD><TD>                        if (methodBinding != null &amp;&amp; methodBinding.canBeSeenBy(invocationSite, this)) {</TD></TR><TR><TD CLASS="l">1979</TD><TD>                            // targeting a non generic constructor with type arguments ?</TD></TR><TR CLASS="z"><TD CLASS="l">1980</TD><TD>                            if (invocationSite.genericTypeArguments() != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1981</TD><TD>                                    methodBinding = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">1982</TD><TD>                                return methodBinding;</TD></TR><TR><TD CLASS="l">1983</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1984</TD><TD>                        MethodBinding[] methods = receiverType.getMethods(TypeConstants.INIT);</TD></TR><TR CLASS="z"><TD CLASS="l">1985</TD><TD>                        if (methods == Binding.NO_METHODS)</TD></TR><TR><TD CLASS="l">1986</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1987</TD><TD>                                return new MethodBinding(0, TypeConstants.INIT, TypeBinding.UNKNOWN, null, null,receiverType);</TD></TR><TR><TD CLASS="l">1988</TD><TD> </TD></TR><TR><TD CLASS="l">1989</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1990</TD><TD>                        MethodBinding[] compatible = new MethodBinding[methods.length];</TD></TR><TR CLASS="z"><TD CLASS="l">1991</TD><TD>                        int compatibleIndex = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1992</TD><TD>                        MethodBinding problemMethod = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1993</TD><TD>                        for (int i = 0, length = methods.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1994</TD><TD>                                MethodBinding compatibleMethod = computeCompatibleMethod(methods[i], argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">1995</TD><TD>                                if (compatibleMethod != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1996</TD><TD>                                        if (compatibleMethod.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">1997</TD><TD>                                                compatible[compatibleIndex++] = compatibleMethod;</TD></TR><TR CLASS="z"><TD CLASS="l">1998</TD><TD>                                        else if (problemMethod == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1999</TD><TD>                                                problemMethod = compatibleMethod;</TD></TR><TR><TD CLASS="l">2000</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2001</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2002</TD><TD>                        if (compatibleIndex == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2003</TD><TD>                                if (problemMethod == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2004</TD><TD>                                        return new ProblemMethodBinding(TypeConstants.INIT, argumentTypes, ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2005</TD><TD>                                return problemMethod;</TD></TR><TR><TD CLASS="l">2006</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2007</TD><TD>                        // need a more descriptive error... cannot convert from X to Y</TD></TR><TR><TD CLASS="l">2008</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2009</TD><TD>                        MethodBinding[] visible = new MethodBinding[compatibleIndex];</TD></TR><TR CLASS="z"><TD CLASS="l">2010</TD><TD>                        int visibleIndex = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">2011</TD><TD>                        for (int i = 0; i &lt; compatibleIndex; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2012</TD><TD>                                MethodBinding method = compatible[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2013</TD><TD>                                if (method.canBeSeenBy(invocationSite, this))</TD></TR><TR CLASS="z"><TD CLASS="l">2014</TD><TD>                                        visible[visibleIndex++] = method;</TD></TR><TR><TD CLASS="l">2015</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2016</TD><TD>                        if (visibleIndex == 1) return visible[0];</TD></TR><TR CLASS="z"><TD CLASS="l">2017</TD><TD>                        if (visibleIndex == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">2018</TD><TD>                                return new ProblemMethodBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2019</TD><TD>                                        compatible[0],</TD></TR><TR CLASS="z"><TD CLASS="l">2020</TD><TD>                                        TypeConstants.INIT,</TD></TR><TR CLASS="z"><TD CLASS="l">2021</TD><TD>                                        compatible[0].parameters,</TD></TR><TR CLASS="z"><TD CLASS="l">2022</TD><TD>                                        ProblemReasons.NotVisible);</TD></TR><TR><TD CLASS="l">2023</TD><TD>                        // all of visible are from the same declaringClass, even before 1.4 we can call this method instead of mostSpecificClassMethodBinding</TD></TR><TR CLASS="z"><TD CLASS="l">2024</TD><TD>                        return mostSpecificMethodBinding(visible, visibleIndex, argumentTypes, invocationSite, receiverType);</TD></TR><TR CLASS="z"><TD CLASS="l">2025</TD><TD>                } catch (AbortCompilation e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2026</TD><TD>                        e.updateContext(invocationSite, referenceCompilationUnit().compilationResult);</TD></TR><TR CLASS="z"><TD CLASS="l">2027</TD><TD>                        throw e;</TD></TR><TR CLASS="z"><TD CLASS="l">2028</TD><TD>                } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">2029</TD><TD>                        env.missingClassFileLocation = null;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="21">2030</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">2031</TD><TD>        }</TD></TR><TR><TD CLASS="l">2032</TD><TD> </TD></TR><TR><TD CLASS="l">2033</TD><TD>        public final PackageBinding getCurrentPackage() {</TD></TR><TR CLASS="z"><TD CLASS="l">2034</TD><TD>                Scope scope, unitScope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">2035</TD><TD>                while ((scope = unitScope.parent) != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2036</TD><TD>                        unitScope = scope;</TD></TR><TR CLASS="z"><TD CLASS="l">2037</TD><TD>                return ((CompilationUnitScope) unitScope).getDefaultPackage();</TD></TR><TR><TD CLASS="l">2038</TD><TD>        }</TD></TR><TR><TD CLASS="l">2039</TD><TD> </TD></TR><TR><TD CLASS="l">2040</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="22">2041</A></TD><TD>         * Returns the modifiers of the innermost enclosing declaration.</TD></TR><TR><TD CLASS="l">2042</TD><TD>         * @return modifiers</TD></TR><TR><TD CLASS="l">2043</TD><TD>         */</TD></TR><TR><TD CLASS="l">2044</TD><TD>        public int getDeclarationModifiers(){</TD></TR><TR CLASS="z"><TD CLASS="l">2045</TD><TD>                switch(this.kind){</TD></TR><TR><TD CLASS="l">2046</TD><TD>                        case Scope.BLOCK_SCOPE :</TD></TR><TR><TD CLASS="l">2047</TD><TD>                        case Scope.METHOD_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2048</TD><TD>                                MethodScope methodScope = methodScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2049</TD><TD>                                if (!methodScope.isInsideInitializer()){</TD></TR><TR><TD CLASS="l">2050</TD><TD>                                        // check method modifiers to see if deprecated</TD></TR><TR CLASS="z"><TD CLASS="l">2051</TD><TD>                                        MethodBinding context = ((AbstractMethodDeclaration)methodScope.referenceContext).binding;</TD></TR><TR CLASS="z"><TD CLASS="l">2052</TD><TD>                                        if (context != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2053</TD><TD>                                                return context.modifiers;</TD></TR><TR><TD CLASS="l">2054</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2055</TD><TD>                                        SourceTypeBinding type = ((BlockScope) this).referenceType().binding;</TD></TR><TR><TD CLASS="l">2056</TD><TD> </TD></TR><TR><TD CLASS="l">2057</TD><TD>                                        // inside field declaration ? check field modifier to see if deprecated</TD></TR><TR CLASS="z"><TD CLASS="l">2058</TD><TD>                                        if (methodScope.initializedField != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2059</TD><TD>                                                return methodScope.initializedField.modifiers;</TD></TR><TR CLASS="z"><TD CLASS="l">2060</TD><TD>                                        if (type != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2061</TD><TD>                                                return type.modifiers;</TD></TR><TR><TD CLASS="l">2062</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2063</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">2064</TD><TD>                        case Scope.CLASS_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2065</TD><TD>                                ReferenceBinding context = ((ClassScope)this).referenceType().binding;</TD></TR><TR CLASS="z"><TD CLASS="l">2066</TD><TD>                                if (context != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2067</TD><TD>                                        return context.modifiers;</TD></TR><TR><TD CLASS="l">2068</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">2069</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="23">2070</A></TD><TD>                return -1;</TD></TR><TR><TD CLASS="l">2071</TD><TD>        }</TD></TR><TR><TD CLASS="l">2072</TD><TD> </TD></TR><TR><TD CLASS="l">2073</TD><TD>        public FieldBinding getField(TypeBinding receiverType, char[] fieldName, InvocationSite invocationSite) {</TD></TR><TR CLASS="z"><TD CLASS="l">2074</TD><TD>                LookupEnvironment env = environment();</TD></TR><TR><TD CLASS="l">2075</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">2076</TD><TD>                        env.missingClassFileLocation = invocationSite;</TD></TR><TR CLASS="z"><TD CLASS="l">2077</TD><TD>                        FieldBinding field = findField(receiverType, fieldName, invocationSite, true /*resolve*/);</TD></TR><TR CLASS="z"><TD CLASS="l">2078</TD><TD>                        if (field != null) return field;</TD></TR><TR><TD CLASS="l">2079</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2080</TD><TD>                        return new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2081</TD><TD>                                receiverType instanceof ReferenceBinding ? (ReferenceBinding) receiverType : null,</TD></TR><TR CLASS="z"><TD CLASS="l">2082</TD><TD>                                fieldName,</TD></TR><TR CLASS="z"><TD CLASS="l">2083</TD><TD>                                ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2084</TD><TD>                } catch (AbortCompilation e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2085</TD><TD>                        e.updateContext(invocationSite, referenceCompilationUnit().compilationResult);</TD></TR><TR CLASS="z"><TD CLASS="l">2086</TD><TD>                        throw e;</TD></TR><TR CLASS="z"><TD CLASS="l">2087</TD><TD>                } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">2088</TD><TD>                        env.missingClassFileLocation = null;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="24">2089</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">2090</TD><TD>        }</TD></TR><TR><TD CLASS="l">2091</TD><TD> </TD></TR><TR><TD CLASS="l">2092</TD><TD>        public Binding getFieldOrMethod( TypeBinding receiverType, char[] fieldName, InvocationSite invocationSite ) {</TD></TR><TR CLASS="z"><TD CLASS="l">2093</TD><TD>                LookupEnvironment env = environment();</TD></TR><TR><TD CLASS="l">2094</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">2095</TD><TD>                        env.missingClassFileLocation = invocationSite;</TD></TR><TR><TD CLASS="l">2096</TD><TD>                        //first look for field</TD></TR><TR CLASS="z"><TD CLASS="l">2097</TD><TD>                        FieldBinding field = findField(receiverType, fieldName, invocationSite, true /*resolve*/);</TD></TR><TR CLASS="z"><TD CLASS="l">2098</TD><TD>                        if (field != null) return field;</TD></TR><TR><TD CLASS="l">2099</TD><TD> </TD></TR><TR><TD CLASS="l">2100</TD><TD> </TD></TR><TR><TD CLASS="l">2101</TD><TD>                        /* not sure if this fix is correct, but reciever type is [sometimes] coming in as &#34;BaseTypeBinding&#34; and causing a classcastexception */</TD></TR><TR CLASS="z"><TD CLASS="l">2102</TD><TD>                        MethodBinding method = findMethod( receiverType instanceof ReferenceBinding?(ReferenceBinding)receiverType:null, fieldName, new TypeBinding[0], invocationSite );</TD></TR><TR CLASS="z"><TD CLASS="l">2103</TD><TD>                        if( method != null )</TD></TR><TR><TD CLASS="l">2104</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2105</TD><TD>                                if (!method.isValidBinding())</TD></TR><TR><TD CLASS="l">2106</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">2107</TD><TD>                                        if (method.problemId()!=ProblemReasons.NotFound)</TD></TR><TR CLASS="z"><TD CLASS="l">2108</TD><TD>                                                return method;</TD></TR><TR><TD CLASS="l">2109</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2110</TD><TD>                                else</TD></TR><TR CLASS="z"><TD CLASS="l">2111</TD><TD>                                        return method;</TD></TR><TR><TD CLASS="l">2112</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2113</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2114</TD><TD>                        return new ProblemFieldBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2115</TD><TD>                                receiverType instanceof ReferenceBinding ? (ReferenceBinding) receiverType : null,</TD></TR><TR CLASS="z"><TD CLASS="l">2116</TD><TD>                                fieldName,</TD></TR><TR CLASS="z"><TD CLASS="l">2117</TD><TD>                                ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2118</TD><TD>                } catch (AbortCompilation e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2119</TD><TD>                        e.updateContext(invocationSite, referenceCompilationUnit().compilationResult);</TD></TR><TR CLASS="z"><TD CLASS="l">2120</TD><TD>                        throw e;</TD></TR><TR CLASS="z"><TD CLASS="l">2121</TD><TD>                } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">2122</TD><TD>                        env.missingClassFileLocation = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2123</TD><TD>                }</TD></TR><TR><TD CLASS="l">2124</TD><TD>        }</TD></TR><TR><TD CLASS="l">2125</TD><TD> </TD></TR><TR><TD CLASS="l">2126</TD><TD>        /* API</TD></TR><TR><TD CLASS="l">2127</TD><TD>         *</TD></TR><TR><TD CLASS="l">2128</TD><TD>         *        Answer the method binding that corresponds to selector, argumentTypes.</TD></TR><TR><TD CLASS="l">2129</TD><TD>         *        Start the lookup at the enclosing type of the receiver.</TD></TR><TR><TD CLASS="l">2130</TD><TD>         *        InvocationSite implements</TD></TR><TR><TD CLASS="l">2131</TD><TD>         *                isSuperAccess(); this is used to determine if the discovered method is visible.</TD></TR><TR><TD CLASS="l">2132</TD><TD>         *                setDepth(int); this is used to record the depth of the discovered method</TD></TR><TR><TD CLASS="l">2133</TD><TD>         *                        relative to the enclosing type of the receiver. (If the method is defined</TD></TR><TR><TD CLASS="l">2134</TD><TD>         *                        in the enclosing type of the receiver, the depth is 0; in the next enclosing</TD></TR><TR><TD CLASS="l">2135</TD><TD>         *                        type, the depth is 1; and so on</TD></TR><TR><TD CLASS="l">2136</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="25">2137</A></TD><TD>         *        If no visible method is discovered, an error binding is answered.</TD></TR><TR><TD CLASS="l">2138</TD><TD>         */</TD></TR><TR><TD CLASS="l">2139</TD><TD>        public MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite) {</TD></TR><TR><TD CLASS="l">2140</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2141</TD><TD>                boolean insideStaticContext = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2142</TD><TD>                boolean insideConstructorCall = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2143</TD><TD>                boolean insideTypeAnnotation = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2144</TD><TD>                MethodBinding foundMethod = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2145</TD><TD>                MethodBinding foundProblem = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2146</TD><TD>                boolean foundProblemVisible = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2147</TD><TD>                Scope scope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">2148</TD><TD>                int depth = 0;</TD></TR><TR><TD CLASS="l">2149</TD><TD>                // in 1.4 mode (inherited visible shadows enclosing)</TD></TR><TR><TD CLASS="l">2150</TD><TD>                CompilerOptions options;</TD></TR><TR CLASS="z"><TD CLASS="l">2151</TD><TD>                boolean inheritedHasPrecedence = (options = compilerOptions()).complianceLevel &gt;= ClassFileConstants.JDK1_4;</TD></TR><TR><TD CLASS="l">2152</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2153</TD><TD>                done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found</TD></TR><TR CLASS="z"><TD CLASS="l">2154</TD><TD>                        switch (scope.kind) {</TD></TR><TR><TD CLASS="l">2155</TD><TD>                                case METHOD_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2156</TD><TD>                                        MethodScope methodScope = (MethodScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">2157</TD><TD>                                        insideStaticContext |= methodScope.isStatic;</TD></TR><TR CLASS="z"><TD CLASS="l">2158</TD><TD>                                        insideConstructorCall |= methodScope.isConstructorCall;</TD></TR><TR CLASS="z"><TD CLASS="l">2159</TD><TD>                                        insideTypeAnnotation = methodScope.insideTypeAnnotation;</TD></TR><TR CLASS="z"><TD CLASS="l">2160</TD><TD>                                        MethodBinding binding = methodScope.findMethod(selector,argumentTypes,true);</TD></TR><TR CLASS="z"><TD CLASS="l">2161</TD><TD>                                        if (binding!=null)</TD></TR><TR CLASS="z"><TD CLASS="l">2162</TD><TD>                                                return binding;</TD></TR><TR CLASS="z"><TD CLASS="l">2163</TD><TD>                                        LocalVariableBinding variable = methodScope.findVariable(selector);</TD></TR><TR><TD CLASS="l">2164</TD><TD>                                        if (variable!=null)</TD></TR><TR><TD CLASS="l">2165</TD><TD>                                        {</TD></TR><TR><TD CLASS="l">2166</TD><TD>                                                </TD></TR><TR><TD CLASS="l">2167</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2168</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">2169</TD><TD>                                case WITH_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2170</TD><TD>                                        WithScope withScope = (WithScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">2171</TD><TD>                                        ReferenceBinding withType = withScope.referenceContext;</TD></TR><TR><TD CLASS="l">2172</TD><TD>                                        // retrieve an exact visible match (if possible)</TD></TR><TR><TD CLASS="l">2173</TD><TD>                                        // compilationUnitScope().recordTypeReference(receiverType);   not needed since receiver is the source type</TD></TR><TR CLASS="z"><TD CLASS="l">2174</TD><TD>                                        MethodBinding methBinding = withScope.findExactMethod(withType, selector, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">2175</TD><TD>                                        if (methBinding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2176</TD><TD>                                                methBinding = withScope.findMethod(withType, selector, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">2177</TD><TD>                                        if (methBinding != null) { // skip it if we did not find anything</TD></TR><TR CLASS="z"><TD CLASS="l">2178</TD><TD>                                                        if (methBinding.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2179</TD><TD>                                                                        return methBinding;</TD></TR><TR><TD CLASS="l">2180</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">2181</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2182</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">2183</TD><TD>                                case CLASS_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2184</TD><TD>                                        ClassScope classScope = (ClassScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">2185</TD><TD>                                        ReferenceBinding receiverType = classScope.enclosingReceiverType();</TD></TR><TR CLASS="z"><TD CLASS="l">2186</TD><TD>                                        if (!insideTypeAnnotation) {</TD></TR><TR><TD CLASS="l">2187</TD><TD>                                                // retrieve an exact visible match (if possible)</TD></TR><TR><TD CLASS="l">2188</TD><TD>                                                // compilationUnitScope().recordTypeReference(receiverType);   not needed since receiver is the source type</TD></TR><TR CLASS="z"><TD CLASS="l">2189</TD><TD>                                                MethodBinding methodBinding = classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">2190</TD><TD>                                                if (methodBinding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2191</TD><TD>                                                        methodBinding = classScope.findMethod(receiverType, selector, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">2192</TD><TD>                                                if (methodBinding != null) { // skip it if we did not find anything</TD></TR><TR CLASS="z"><TD CLASS="l">2193</TD><TD>                                                        if (foundMethod == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2194</TD><TD>                                                                if (methodBinding.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2195</TD><TD>                                                                        if (!methodBinding.isStatic() &amp;&amp; (insideConstructorCall || insideStaticContext)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2196</TD><TD>                                                                                if (foundProblem != null &amp;&amp; foundProblem.problemId() != ProblemReasons.NotVisible)</TD></TR><TR CLASS="z"><TD CLASS="l">2197</TD><TD>                                                                                        return foundProblem; // takes precedence</TD></TR><TR CLASS="z"><TD CLASS="l">2198</TD><TD>                                                                                return new ProblemMethodBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2199</TD><TD>                                                                                        methodBinding, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">2200</TD><TD>                                                                                        methodBinding.selector,</TD></TR><TR CLASS="z"><TD CLASS="l">2201</TD><TD>                                                                                        methodBinding.parameters,</TD></TR><TR CLASS="z"><TD CLASS="l">2202</TD><TD>                                                                                        insideConstructorCall</TD></TR><TR CLASS="z"><TD CLASS="l">2203</TD><TD>                                                                                                ? ProblemReasons.NonStaticReferenceInConstructorInvocation</TD></TR><TR CLASS="z"><TD CLASS="l">2204</TD><TD>                                                                                                : ProblemReasons.NonStaticReferenceInStaticContext);</TD></TR><TR><TD CLASS="l">2205</TD><TD>                                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2206</TD><TD>                                                                        if (inheritedHasPrecedence</TD></TR><TR CLASS="z"><TD CLASS="l">2207</TD><TD>                                                                                        || receiverType == methodBinding.declaringClass</TD></TR><TR CLASS="z"><TD CLASS="l">2208</TD><TD>                                                                                        || (receiverType.getMethods(selector)) != Binding.NO_METHODS) {</TD></TR><TR><TD CLASS="l">2209</TD><TD>                                                                                // found a valid method in the 'immediate' scope (ie. not inherited)</TD></TR><TR><TD CLASS="l">2210</TD><TD>                                                                                // OR in 1.4 mode (inherited visible shadows enclosing)</TD></TR><TR><TD CLASS="l">2211</TD><TD>                                                                                // OR the receiverType implemented a method with the correct name</TD></TR><TR><TD CLASS="l">2212</TD><TD>                                                                                // return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)</TD></TR><TR CLASS="z"><TD CLASS="l">2213</TD><TD>                                                                                if (foundProblemVisible) {</TD></TR><TR CLASS="z"><TD CLASS="l">2214</TD><TD>                                                                                        return foundProblem;</TD></TR><TR><TD CLASS="l">2215</TD><TD>                                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2216</TD><TD>                                                                                if (depth &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2217</TD><TD>                                                                                        invocationSite.setDepth(depth);</TD></TR><TR CLASS="z"><TD CLASS="l">2218</TD><TD>                                                                                        invocationSite.setActualReceiverType(receiverType);</TD></TR><TR><TD CLASS="l">2219</TD><TD>                                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2220</TD><TD>                                                                                return methodBinding;</TD></TR><TR><TD CLASS="l">2221</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">2222</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2223</TD><TD>                                                                        if (foundProblem == null || foundProblem.problemId() == ProblemReasons.NotVisible) {</TD></TR><TR CLASS="z"><TD CLASS="l">2224</TD><TD>                                                                                if (foundProblem != null) foundProblem = null;</TD></TR><TR><TD CLASS="l">2225</TD><TD>                                                                                // only remember the methodBinding if its the first one found</TD></TR><TR><TD CLASS="l">2226</TD><TD>                                                                                // remember that private methods are visible if defined directly by an enclosing class</TD></TR><TR CLASS="z"><TD CLASS="l">2227</TD><TD>                                                                                if (depth &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2228</TD><TD>                                                                                        invocationSite.setDepth(depth);</TD></TR><TR CLASS="z"><TD CLASS="l">2229</TD><TD>                                                                                        invocationSite.setActualReceiverType(receiverType);</TD></TR><TR><TD CLASS="l">2230</TD><TD>                                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2231</TD><TD>                                                                                foundMethod = methodBinding;</TD></TR><TR><TD CLASS="l">2232</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">2233</TD><TD>                                                                } else { // methodBinding is a problem method</TD></TR><TR CLASS="z"><TD CLASS="l">2234</TD><TD>                                                                        if (methodBinding.problemId() != ProblemReasons.NotVisible &amp;&amp; methodBinding.problemId() != ProblemReasons.NotFound)</TD></TR><TR CLASS="z"><TD CLASS="l">2235</TD><TD>                                                                                return methodBinding; // return the error now</TD></TR><TR CLASS="z"><TD CLASS="l">2236</TD><TD>                                                                        if (foundProblem == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2237</TD><TD>                                                                                foundProblem = methodBinding; // hold onto the first not visible/found error and keep the second not found if first is not visible</TD></TR><TR><TD CLASS="l">2238</TD><TD>                                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2239</TD><TD>                                                                        if (! foundProblemVisible &amp;&amp; methodBinding.problemId() == ProblemReasons.NotFound) {</TD></TR><TR CLASS="z"><TD CLASS="l">2240</TD><TD>                                                                                MethodBinding closestMatch = ((ProblemMethodBinding) methodBinding).closestMatch;</TD></TR><TR CLASS="z"><TD CLASS="l">2241</TD><TD>                                                                                if (closestMatch != null &amp;&amp; closestMatch.canBeSeenBy(receiverType, invocationSite, this)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2242</TD><TD>                                                                                        foundProblem = methodBinding; // hold onto the first not visible/found error and keep the second not found if first is not visible</TD></TR><TR CLASS="z"><TD CLASS="l">2243</TD><TD>                                                                                        foundProblemVisible = true;</TD></TR><TR><TD CLASS="l">2244</TD><TD>                                                                                }</TD></TR><TR><TD CLASS="l">2245</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">2246</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">2247</TD><TD>                                                        } else { // found a valid method so check to see if this is a hiding case</TD></TR><TR CLASS="z"><TD CLASS="l">2248</TD><TD>                                                                if (methodBinding.problemId() == ProblemReasons.Ambiguous</TD></TR><TR CLASS="z"><TD CLASS="l">2249</TD><TD>                                                                        || (foundMethod.declaringClass != methodBinding.declaringClass</TD></TR><TR CLASS="z"><TD CLASS="l">2250</TD><TD>                                                                                &amp;&amp; (receiverType == methodBinding.declaringClass || receiverType.getMethods(selector) != Binding.NO_METHODS)))</TD></TR><TR><TD CLASS="l">2251</TD><TD>                                                                        // ambiguous case -&gt; must qualify the method (javac generates an ambiguous error instead)</TD></TR><TR><TD CLASS="l">2252</TD><TD>                                                                        // otherwise if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)</TD></TR><TR><TD CLASS="l">2253</TD><TD>                                                                        // NOTE: Unlike fields, a non visible method hides a visible method</TD></TR><TR CLASS="z"><TD CLASS="l">2254</TD><TD>                                                                        return new ProblemMethodBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2255</TD><TD>                                                                                methodBinding, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">2256</TD><TD>                                                                                selector,</TD></TR><TR CLASS="z"><TD CLASS="l">2257</TD><TD>                                                                                argumentTypes,</TD></TR><TR CLASS="z"><TD CLASS="l">2258</TD><TD>                                                                                ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR><TD CLASS="l">2259</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2260</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2261</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2262</TD><TD>                                        insideTypeAnnotation = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2263</TD><TD>                                        depth++;</TD></TR><TR CLASS="z"><TD CLASS="l">2264</TD><TD>                                        insideStaticContext |= receiverType.isStatic();</TD></TR><TR><TD CLASS="l">2265</TD><TD>                                        // 1EX5I8Z - accessing outer fields within a constructor call is permitted</TD></TR><TR><TD CLASS="l">2266</TD><TD>                                        // in order to do so, we change the flag as we exit from the type, not the method</TD></TR><TR><TD CLASS="l">2267</TD><TD>                                        // itself, because the class scope is used to retrieve the fields.</TD></TR><TR CLASS="z"><TD CLASS="l">2268</TD><TD>                                        MethodScope enclosingMethodScope = scope.methodScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2269</TD><TD>                                        insideConstructorCall = enclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;</TD></TR><TR CLASS="z"><TD CLASS="l">2270</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">2271</TD><TD>                                case COMPILATION_UNIT_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2272</TD><TD>                                        CompilationUnitScope compilationUnitScope = (CompilationUnitScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">2273</TD><TD>                                        CompilationUnitBinding compilationUnitBinding = compilationUnitScope.enclosingCompilationUnit();</TD></TR><TR CLASS="z"><TD CLASS="l">2274</TD><TD>                                         receiverType = compilationUnitBinding;</TD></TR><TR CLASS="z"><TD CLASS="l">2275</TD><TD>                                                MethodBinding methodBinding =</TD></TR><TR CLASS="z"><TD CLASS="l">2276</TD><TD>                                                        (foundMethod == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2277</TD><TD>                                                                ? compilationUnitScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite)</TD></TR><TR CLASS="z"><TD CLASS="l">2278</TD><TD>                                                                : compilationUnitScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">2279</TD><TD>                                                if (methodBinding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2280</TD><TD>                                                        methodBinding = compilationUnitScope.findMethod(receiverType, selector, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">2281</TD><TD>                                                if (methodBinding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2282</TD><TD>                                                        methodBinding = compilationUnitScope.findMethod(selector, argumentTypes,true);</TD></TR><TR CLASS="z"><TD CLASS="l">2283</TD><TD>                                                if (methodBinding != null) { // skip it if we did not find anything</TD></TR><TR CLASS="z"><TD CLASS="l">2284</TD><TD>                                                        if (methodBinding.problemId() == ProblemReasons.Ambiguous) {</TD></TR><TR CLASS="z"><TD CLASS="l">2285</TD><TD>                                                                if (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible) {</TD></TR><TR><TD CLASS="l">2286</TD><TD>                                                                        // supercedes any potential InheritedNameHidesEnclosingName problem</TD></TR><TR CLASS="z"><TD CLASS="l">2287</TD><TD>                                                                        return methodBinding;</TD></TR><TR><TD CLASS="l">2288</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">2289</TD><TD>                                                                // make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)</TD></TR><TR CLASS="z"><TD CLASS="l">2290</TD><TD>                                                                return new ProblemMethodBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2291</TD><TD>                                                                        methodBinding, // closest match</TD></TR><TR CLASS="z"><TD CLASS="l">2292</TD><TD>                                                                        selector,</TD></TR><TR CLASS="z"><TD CLASS="l">2293</TD><TD>                                                                        argumentTypes,</TD></TR><TR CLASS="z"><TD CLASS="l">2294</TD><TD>                                                                        ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR><TD CLASS="l">2295</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2296</TD><TD>                                                        MethodBinding fuzzyProblem = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2297</TD><TD>                                                        MethodBinding insideProblem = null;</TD></TR><TR><TD CLASS="l">2298</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2299</TD><TD>                                                                if (foundMethod == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2300</TD><TD>                                                                        if (receiverType == methodBinding.declaringClass</TD></TR><TR CLASS="z"><TD CLASS="l">2301</TD><TD>                                                                                || (receiverType.getMethods(selector)) != Binding.NO_METHODS</TD></TR><TR CLASS="z"><TD CLASS="l">2302</TD><TD>                                                                                || ((foundProblem == null || foundProblem.problemId() != ProblemReasons.NotVisible) &amp;&amp; compilerOptions().complianceLevel &gt;= ClassFileConstants.JDK1_4)) {</TD></TR><TR><TD CLASS="l">2303</TD><TD>                                                                                        // found a valid method in the 'immediate' scope (ie. not inherited)</TD></TR><TR><TD CLASS="l">2304</TD><TD>                                                                                        // OR the receiverType implemented a method with the correct name</TD></TR><TR><TD CLASS="l">2305</TD><TD>                                                                                        // OR in 1.4 mode (inherited visible shadows enclosing)</TD></TR><TR CLASS="z"><TD CLASS="l">2306</TD><TD>                                                                                        if (depth &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2307</TD><TD>                                                                                                invocationSite.setDepth(depth);</TD></TR><TR CLASS="z"><TD CLASS="l">2308</TD><TD>                                                                                                invocationSite.setActualReceiverType(receiverType);</TD></TR><TR><TD CLASS="l">2309</TD><TD>                                                                                        }</TD></TR><TR><TD CLASS="l">2310</TD><TD>                                                                                        // return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)</TD></TR><TR CLASS="z"><TD CLASS="l">2311</TD><TD>                                                                                        if (foundProblem != null &amp;&amp; foundProblem.problemId() != ProblemReasons.NotVisible)</TD></TR><TR CLASS="z"><TD CLASS="l">2312</TD><TD>                                                                                                return foundProblem;</TD></TR><TR CLASS="z"><TD CLASS="l">2313</TD><TD>                                                                                        if (insideProblem != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2314</TD><TD>                                                                                                return insideProblem;</TD></TR><TR CLASS="z"><TD CLASS="l">2315</TD><TD>                                                                                        return methodBinding;</TD></TR><TR><TD CLASS="l">2316</TD><TD>                                                                                }</TD></TR><TR><TD CLASS="l">2317</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">2318</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2319</TD><TD>                                                        if (foundMethod == null || (foundMethod.problemId() == ProblemReasons.NotVisible &amp;&amp; methodBinding.problemId() != ProblemReasons.NotVisible)) {</TD></TR><TR><TD CLASS="l">2320</TD><TD>                                                                // only remember the methodBinding if its the first one found or the previous one was not visible &amp; methodBinding is...</TD></TR><TR><TD CLASS="l">2321</TD><TD>                                                                // remember that private methods are visible if defined directly by an enclosing class</TD></TR><TR CLASS="z"><TD CLASS="l">2322</TD><TD>                                                                if (depth &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2323</TD><TD>                                                                        invocationSite.setDepth(depth);</TD></TR><TR CLASS="z"><TD CLASS="l">2324</TD><TD>                                                                        invocationSite.setActualReceiverType(receiverType);</TD></TR><TR><TD CLASS="l">2325</TD><TD>                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2326</TD><TD>                                                                foundProblem = fuzzyProblem;</TD></TR><TR CLASS="z"><TD CLASS="l">2327</TD><TD>                                                                foundProblem = insideProblem;</TD></TR><TR CLASS="z"><TD CLASS="l">2328</TD><TD>                                                                if (fuzzyProblem == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2329</TD><TD>                                                                        foundMethod = methodBinding; // only keep it if no error was found</TD></TR><TR><TD CLASS="l">2330</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2331</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2332</TD><TD>                                        depth++;</TD></TR><TR CLASS="z"><TD CLASS="l">2333</TD><TD>                                        insideStaticContext |= receiverType.isStatic();</TD></TR><TR><TD CLASS="l">2334</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2335</TD><TD>                                        break done;</TD></TR><TR CLASS="z"><TD CLASS="l">2336</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2337</TD><TD>                        scope = scope.parent;</TD></TR><TR><TD CLASS="l">2338</TD><TD>                }</TD></TR><TR><TD CLASS="l">2339</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2340</TD><TD>                if (insideStaticContext &amp;&amp; options.sourceLevel &gt;= ClassFileConstants.JDK1_5) {</TD></TR><TR CLASS="z"><TD CLASS="l">2341</TD><TD>                        if (foundProblem != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2342</TD><TD>                                if (foundProblem.declaringClass != null &amp;&amp; foundProblem.declaringClass.id == TypeIds.T_JavaLangObject)</TD></TR><TR CLASS="z"><TD CLASS="l">2343</TD><TD>                                        return foundProblem; // static imports lose to methods from Object</TD></TR><TR CLASS="z"><TD CLASS="l">2344</TD><TD>                                if (foundProblem.problemId() == ProblemReasons.NotFound &amp;&amp; foundProblemVisible) {</TD></TR><TR CLASS="z"><TD CLASS="l">2345</TD><TD>                                        return foundProblem; // visible method selectors take precedence</TD></TR><TR><TD CLASS="l">2346</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2347</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2348</TD><TD>                }</TD></TR><TR><TD CLASS="l">2349</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2350</TD><TD>                if (foundMethod != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2351</TD><TD>                        invocationSite.setActualReceiverType(foundMethod.declaringClass);</TD></TR><TR CLASS="z"><TD CLASS="l">2352</TD><TD>                        return foundMethod;</TD></TR><TR><TD CLASS="l">2353</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2354</TD><TD>                if (foundProblem != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2355</TD><TD>                        return foundProblem;</TD></TR><TR><TD CLASS="l">2356</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="26">2357</A></TD><TD>                return new ProblemMethodBinding(selector, argumentTypes, ProblemReasons.NotFound);</TD></TR><TR><TD CLASS="l">2358</TD><TD>        }</TD></TR><TR><TD CLASS="l">2359</TD><TD> </TD></TR><TR><TD CLASS="l">2360</TD><TD>        public final ReferenceBinding getJavaIoSerializable() {</TD></TR><TR CLASS="z"><TD CLASS="l">2361</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2362</TD><TD>                unitScope.recordQualifiedReference(JAVA_IO_SERIALIZABLE);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="27">2363</A></TD><TD>                return unitScope.environment.getResolvedType(JAVA_IO_SERIALIZABLE, this);</TD></TR><TR><TD CLASS="l">2364</TD><TD>        }</TD></TR><TR><TD CLASS="l">2365</TD><TD> </TD></TR><TR><TD CLASS="l">2366</TD><TD>        public final ReferenceBinding getJavaLangAnnotationAnnotation() {</TD></TR><TR CLASS="z"><TD CLASS="l">2367</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2368</TD><TD>                unitScope.recordQualifiedReference(JAVA_LANG_ANNOTATION_ANNOTATION);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="29">2369</A></TD><TD>                return unitScope.environment.getResolvedType(JAVA_LANG_ANNOTATION_ANNOTATION, this);</TD></TR><TR><TD CLASS="l">2370</TD><TD>        }</TD></TR><TR><TD CLASS="l">2371</TD><TD> </TD></TR><TR><TD CLASS="l">2372</TD><TD>        public final ReferenceBinding getJavaLangAssertionError() {</TD></TR><TR CLASS="z"><TD CLASS="l">2373</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2374</TD><TD>                unitScope.recordQualifiedReference(JAVA_LANG_ASSERTIONERROR);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2b">2375</A></TD><TD>                return unitScope.environment.getResolvedType(JAVA_LANG_ASSERTIONERROR, this);</TD></TR><TR><TD CLASS="l">2376</TD><TD>        }</TD></TR><TR><TD CLASS="l">2377</TD><TD> </TD></TR><TR><TD CLASS="l">2378</TD><TD>        public final ReferenceBinding getJavaLangClass() {</TD></TR><TR CLASS="z"><TD CLASS="l">2379</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2380</TD><TD>                unitScope.recordQualifiedReference(JAVA_LANG_CLASS);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2c">2381</A></TD><TD>                return unitScope.environment.getResolvedType(JAVA_LANG_CLASS, this);</TD></TR><TR><TD CLASS="l">2382</TD><TD>        }</TD></TR><TR><TD CLASS="l">2383</TD><TD> </TD></TR><TR><TD CLASS="l">2384</TD><TD>        public final ReferenceBinding getJavaLangCloneable() {</TD></TR><TR CLASS="z"><TD CLASS="l">2385</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2d">2386</A></TD><TD>                unitScope.recordQualifiedReference(JAVA_LANG_CLONEABLE);</TD></TR><TR CLASS="z"><TD CLASS="l">2387</TD><TD>                return unitScope.environment.getResolvedType(JAVA_LANG_CLONEABLE, this);</TD></TR><TR><TD CLASS="l">2388</TD><TD>        }</TD></TR><TR><TD CLASS="l">2389</TD><TD>        public final ReferenceBinding getJavaLangEnum() {</TD></TR><TR CLASS="z"><TD CLASS="l">2390</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2391</TD><TD>                unitScope.recordQualifiedReference(JAVA_LANG_ENUM);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="30">2392</A></TD><TD>                return unitScope.environment.getResolvedType(JAVA_LANG_ENUM, this);</TD></TR><TR><TD CLASS="l">2393</TD><TD>        }</TD></TR><TR><TD CLASS="l">2394</TD><TD> </TD></TR><TR><TD CLASS="l">2395</TD><TD>        public final ReferenceBinding getJavaLangIterable() {</TD></TR><TR CLASS="z"><TD CLASS="l">2396</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="32">2397</A></TD><TD>                unitScope.recordQualifiedReference(JAVA_LANG_ITERABLE);</TD></TR><TR CLASS="z"><TD CLASS="l">2398</TD><TD>                return unitScope.environment.getResolvedType(JAVA_LANG_ITERABLE, this);</TD></TR><TR><TD CLASS="l">2399</TD><TD>        }</TD></TR><TR><TD CLASS="l">2400</TD><TD>        public final ReferenceBinding getJavaLangObject() {</TD></TR><TR CLASS="z"><TD CLASS="l">2401</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2402</TD><TD>                unitScope.recordQualifiedReference(JAVA_LANG_OBJECT);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="28">2403</A></TD><TD>                return unitScope.environment.getResolvedType(JAVA_LANG_OBJECT, this);</TD></TR><TR><TD CLASS="l">2404</TD><TD>        }</TD></TR><TR><TD CLASS="l">2405</TD><TD> </TD></TR><TR><TD CLASS="l">2406</TD><TD>        public final ReferenceBinding getJavaLangArray() {</TD></TR><TR CLASS="z"><TD CLASS="l">2407</TD><TD>                compilationUnitScope().recordQualifiedReference(ARRAY);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="34">2408</A></TD><TD>                return environment().getResolvedType(ARRAY, this);</TD></TR><TR><TD CLASS="l">2409</TD><TD>        }</TD></TR><TR><TD CLASS="l">2410</TD><TD> </TD></TR><TR><TD CLASS="l">2411</TD><TD>        public final ReferenceBinding getJavaLangString() {</TD></TR><TR CLASS="z"><TD CLASS="l">2412</TD><TD>                compilationUnitScope().recordQualifiedReference(JAVA_LANG_STRING);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="31">2413</A></TD><TD>                return environment().getResolvedType(JAVA_LANG_STRING, this);</TD></TR><TR><TD CLASS="l">2414</TD><TD>        }</TD></TR><TR><TD CLASS="l">2415</TD><TD> </TD></TR><TR><TD CLASS="l">2416</TD><TD>        public final ReferenceBinding getJavaLangNumber() {</TD></TR><TR CLASS="z"><TD CLASS="l">2417</TD><TD>                compilationUnitScope().recordQualifiedReference(NUMBER);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2f">2418</A></TD><TD>                return environment().getResolvedType(NUMBER, this);</TD></TR><TR><TD CLASS="l">2419</TD><TD>        }</TD></TR><TR><TD CLASS="l">2420</TD><TD> </TD></TR><TR><TD CLASS="l">2421</TD><TD>        public final ReferenceBinding getJavaLangFunction() {</TD></TR><TR CLASS="z"><TD CLASS="l">2422</TD><TD>                compilationUnitScope().recordQualifiedReference(FUNCTION);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2a">2423</A></TD><TD>                return environment().getResolvedType(FUNCTION, this);</TD></TR><TR><TD CLASS="l">2424</TD><TD>        }</TD></TR><TR><TD CLASS="l">2425</TD><TD> </TD></TR><TR><TD CLASS="l">2426</TD><TD>        public final ReferenceBinding getJavaLangBoolean() {</TD></TR><TR CLASS="z"><TD CLASS="l">2427</TD><TD>                compilationUnitScope().recordQualifiedReference(BOOLEAN_OBJECT);</TD></TR><TR CLASS="z"><TD CLASS="l">2428</TD><TD>                return environment().getResolvedType(BOOLEAN_OBJECT, this);</TD></TR><TR><TD CLASS="l"><A NAME="35">2429</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">2430</TD><TD> </TD></TR><TR><TD CLASS="l">2431</TD><TD> </TD></TR><TR><TD CLASS="l">2432</TD><TD>        public final ReferenceBinding getJavaLangThrowable() {</TD></TR><TR CLASS="z"><TD CLASS="l">2433</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2434</TD><TD>                unitScope.recordQualifiedReference(JAVA_LANG_THROWABLE);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2e">2435</A></TD><TD>                return unitScope.environment.getResolvedType(JAVA_LANG_THROWABLE, this);</TD></TR><TR><TD CLASS="l">2436</TD><TD>        }</TD></TR><TR><TD CLASS="l">2437</TD><TD>        </TD></TR><TR><TD CLASS="l">2438</TD><TD>        public final ReferenceBinding getJavaLangError() {</TD></TR><TR CLASS="z"><TD CLASS="l">2439</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2440</TD><TD>                unitScope.recordQualifiedReference(ERROR);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="33">2441</A></TD><TD>                return unitScope.environment.getResolvedType(ERROR, this);</TD></TR><TR><TD CLASS="l">2442</TD><TD>        }</TD></TR><TR><TD CLASS="l">2443</TD><TD>        </TD></TR><TR><TD CLASS="l">2444</TD><TD>        public final ReferenceBinding getJavaLangRegExp() {</TD></TR><TR CLASS="z"><TD CLASS="l">2445</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2446</TD><TD>                unitScope.recordQualifiedReference(REGEXP);</TD></TR><TR CLASS="z"><TD CLASS="l">2447</TD><TD>                return unitScope.environment.getResolvedType(REGEXP, this);</TD></TR><TR><TD CLASS="l">2448</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="37">2449</A></TD><TD> </TD></TR><TR><TD CLASS="l">2450</TD><TD>        /* Answer the type binding corresponding to the typeName argument, relative to the enclosingType.</TD></TR><TR><TD CLASS="l">2451</TD><TD>        */</TD></TR><TR><TD CLASS="l">2452</TD><TD>        public final ReferenceBinding getMemberType(char[] typeName, ReferenceBinding enclosingType) {</TD></TR><TR CLASS="z"><TD CLASS="l">2453</TD><TD>                ReferenceBinding memberType = findMemberType(typeName, enclosingType);</TD></TR><TR CLASS="z"><TD CLASS="l">2454</TD><TD>                if (memberType != null) return memberType;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="38">2455</A></TD><TD>                return new ProblemReferenceBinding(typeName, null, ProblemReasons.NotFound);</TD></TR><TR><TD CLASS="l">2456</TD><TD>        }</TD></TR><TR><TD CLASS="l">2457</TD><TD> </TD></TR><TR><TD CLASS="l">2458</TD><TD>        public MethodBinding getMethod(TypeBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite) {</TD></TR><TR CLASS="z"><TD CLASS="l">2459</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2460</TD><TD>                LookupEnvironment env = unitScope.environment;</TD></TR><TR><TD CLASS="l">2461</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">2462</TD><TD>                        env.missingClassFileLocation = invocationSite;</TD></TR><TR CLASS="z"><TD CLASS="l">2463</TD><TD>                        if (receiverType==null)</TD></TR><TR CLASS="z"><TD CLASS="l">2464</TD><TD>                                return new ProblemMethodBinding(selector, argumentTypes, ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2465</TD><TD>                        switch (receiverType.kind()) {</TD></TR><TR><TD CLASS="l">2466</TD><TD>                                case Binding.BASE_TYPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2467</TD><TD>                                        return new ProblemMethodBinding(selector, argumentTypes, ProblemReasons.NotFound);</TD></TR><TR><TD CLASS="l">2468</TD><TD>//                                case Binding.ARRAY_TYPE :</TD></TR><TR><TD CLASS="l">2469</TD><TD>//                                        unitScope.recordTypeReference(receiverType);</TD></TR><TR><TD CLASS="l">2470</TD><TD>//                                        return findMethodForArray((ArrayBinding) receiverType, selector, argumentTypes, invocationSite);</TD></TR><TR><TD CLASS="l">2471</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2472</TD><TD>                        unitScope.recordTypeReference(receiverType);</TD></TR><TR><TD CLASS="l">2473</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2474</TD><TD>                        ReferenceBinding currentType = (ReferenceBinding) receiverType;</TD></TR><TR CLASS="z"><TD CLASS="l">2475</TD><TD>                        if (!currentType.canBeSeenBy(this))</TD></TR><TR CLASS="z"><TD CLASS="l">2476</TD><TD>                                return new ProblemMethodBinding(selector, argumentTypes, ProblemReasons.ReceiverTypeNotVisible);</TD></TR><TR><TD CLASS="l">2477</TD><TD> </TD></TR><TR><TD CLASS="l">2478</TD><TD>                        // retrieve an exact visible match (if possible)</TD></TR><TR CLASS="z"><TD CLASS="l">2479</TD><TD>                        MethodBinding methodBinding = findExactMethod(currentType, selector, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">2480</TD><TD>                        if (methodBinding != null) return methodBinding;</TD></TR><TR><TD CLASS="l">2481</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2482</TD><TD>                        methodBinding = findMethod(currentType, selector, argumentTypes, invocationSite);</TD></TR><TR CLASS="z"><TD CLASS="l">2483</TD><TD>                        if (methodBinding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2484</TD><TD>                                return new ProblemMethodBinding(selector, argumentTypes, ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2485</TD><TD>                        if (!methodBinding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">2486</TD><TD>                                return methodBinding;</TD></TR><TR><TD CLASS="l">2487</TD><TD> </TD></TR><TR><TD CLASS="l">2488</TD><TD>                        // special treatment for Object.getClass() in 1.5 mode (substitute parameterized return type)</TD></TR><TR CLASS="z"><TD CLASS="l">2489</TD><TD>                        if (receiverType.id != T_JavaLangObject</TD></TR><TR CLASS="z"><TD CLASS="l">2490</TD><TD>                                &amp;&amp; argumentTypes == Binding.NO_PARAMETERS</TD></TR><TR CLASS="z"><TD CLASS="l">2491</TD><TD>                            &amp;&amp; CharOperation.equals(selector, GETCLASS)</TD></TR><TR CLASS="z"><TD CLASS="l">2492</TD><TD>                            &amp;&amp; methodBinding.returnType.isParameterizedType()/*1.5*/) {</TD></TR><TR CLASS="z"><TD CLASS="l">2493</TD><TD>                                        return ParameterizedMethodBinding.instantiateGetClass(receiverType, methodBinding, this);</TD></TR><TR><TD CLASS="l">2494</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">2495</TD><TD>                        return methodBinding;</TD></TR><TR CLASS="z"><TD CLASS="l">2496</TD><TD>                } catch (AbortCompilation e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2497</TD><TD>                        e.updateContext(invocationSite, referenceCompilationUnit().compilationResult);</TD></TR><TR CLASS="z"><TD CLASS="l">2498</TD><TD>                        throw e;</TD></TR><TR CLASS="z"><TD CLASS="l">2499</TD><TD>                } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">2500</TD><TD>                        env.missingClassFileLocation = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2501</TD><TD>                }</TD></TR><TR><TD CLASS="l">2502</TD><TD>        }</TD></TR><TR><TD CLASS="l">2503</TD><TD> </TD></TR><TR><TD CLASS="l">2504</TD><TD>        /* Answer the package from the compoundName or null if it begins with a type.</TD></TR><TR><TD CLASS="l">2505</TD><TD>        * Intended to be used while resolving a qualified type name.</TD></TR><TR><TD CLASS="l">2506</TD><TD>        *</TD></TR><TR><TD CLASS="l"><A NAME="39">2507</A></TD><TD>        * NOTE: If a problem binding is returned, senders should extract the compound name</TD></TR><TR><TD CLASS="l">2508</TD><TD>        * from the binding &amp; not assume the problem applies to the entire compoundName.</TD></TR><TR><TD CLASS="l">2509</TD><TD>        */</TD></TR><TR><TD CLASS="l">2510</TD><TD>        public final Binding getPackage(char[][] compoundName) {</TD></TR><TR CLASS="z"><TD CLASS="l">2511</TD><TD>                compilationUnitScope().recordQualifiedReference(compoundName);</TD></TR><TR CLASS="z"><TD CLASS="l">2512</TD><TD>                Binding binding = getTypeOrPackage(compoundName[0], Binding.TYPE | Binding.PACKAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2513</TD><TD>                if (binding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2514</TD><TD>                        return new ProblemReferenceBinding(compoundName[0], null, ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2515</TD><TD>                if (!binding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">2516</TD><TD>                        return binding;</TD></TR><TR><TD CLASS="l">2517</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2518</TD><TD>                if (!(binding instanceof PackageBinding)) return null; // compoundName does not start with a package</TD></TR><TR><TD CLASS="l">2519</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2520</TD><TD>                int currentIndex = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">2521</TD><TD>                PackageBinding packageBinding = (PackageBinding) binding;</TD></TR><TR CLASS="z"><TD CLASS="l">2522</TD><TD>                while (currentIndex &lt; compoundName.length) {</TD></TR><TR CLASS="z"><TD CLASS="l">2523</TD><TD>                        binding = packageBinding.getTypeOrPackage(compoundName[currentIndex++],  Binding.PACKAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2524</TD><TD>                        if (binding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2525</TD><TD>                                return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2526</TD><TD>                                        CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2527</TD><TD>                                        null,</TD></TR><TR CLASS="z"><TD CLASS="l">2528</TD><TD>                                        ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2529</TD><TD>                        if (!binding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">2530</TD><TD>                                return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2531</TD><TD>                                        CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2532</TD><TD>                                        binding instanceof ReferenceBinding ? ((ReferenceBinding)binding).closestMatch() : null,</TD></TR><TR CLASS="z"><TD CLASS="l">2533</TD><TD>                                        binding.problemId());</TD></TR><TR CLASS="z"><TD CLASS="l">2534</TD><TD>                        if (!(binding instanceof PackageBinding))</TD></TR><TR CLASS="z"><TD CLASS="l">2535</TD><TD>                                return packageBinding;</TD></TR><TR CLASS="z"><TD CLASS="l">2536</TD><TD>                        packageBinding = (PackageBinding) binding;</TD></TR><TR><TD CLASS="l">2537</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2538</TD><TD>                return new ProblemReferenceBinding(compoundName, null, ProblemReasons.NotFound);</TD></TR><TR><TD CLASS="l">2539</TD><TD>        }</TD></TR><TR><TD CLASS="l">2540</TD><TD> </TD></TR><TR><TD CLASS="l">2541</TD><TD>        /* Answer the type binding that corresponds the given name, starting the lookup in the receiver.</TD></TR><TR><TD CLASS="l">2542</TD><TD>        * The name provided is a simple source name (e.g., &#34;Object&#34; , &#34;Point&#34;, ...)</TD></TR><TR><TD CLASS="l">2543</TD><TD>        */</TD></TR><TR><TD CLASS="l">2544</TD><TD>        // The return type of this method could be ReferenceBinding if we did not answer base types.</TD></TR><TR><TD CLASS="l"><A NAME="3a">2545</A></TD><TD>        // NOTE: We could support looking for Base Types last in the search, however any code using</TD></TR><TR><TD CLASS="l">2546</TD><TD>        // this feature would be extraordinarily slow.  Therefore we don't do this</TD></TR><TR><TD CLASS="l">2547</TD><TD>        public final TypeBinding getType(char[] name) {</TD></TR><TR><TD CLASS="l">2548</TD><TD>                // Would like to remove this test and require senders to specially handle base types</TD></TR><TR CLASS="z"><TD CLASS="l">2549</TD><TD>                TypeBinding binding = getBaseType(name);</TD></TR><TR CLASS="z"><TD CLASS="l">2550</TD><TD>                if (binding != null) return binding;</TD></TR><TR CLASS="z"><TD CLASS="l">2551</TD><TD>                return (ReferenceBinding) getTypeOrPackage(name, Binding.TYPE);</TD></TR><TR><TD CLASS="l">2552</TD><TD>        }</TD></TR><TR><TD CLASS="l">2553</TD><TD> </TD></TR><TR><TD CLASS="l">2554</TD><TD>        /* Answer the type binding that corresponds to the given name, starting the lookup in the receiver</TD></TR><TR><TD CLASS="l"><A NAME="3b">2555</A></TD><TD>        * or the packageBinding if provided.</TD></TR><TR><TD CLASS="l">2556</TD><TD>        * The name provided is a simple source name (e.g., &#34;Object&#34; , &#34;Point&#34;, ...)</TD></TR><TR><TD CLASS="l">2557</TD><TD>        */</TD></TR><TR><TD CLASS="l">2558</TD><TD>        public final TypeBinding getType(char[] name, PackageBinding packageBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">2559</TD><TD>                if (packageBinding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2560</TD><TD>                        return getType(name);</TD></TR><TR><TD CLASS="l">2561</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2562</TD><TD>                Binding binding = packageBinding.getTypeOrPackage(name,  Binding.TYPE);</TD></TR><TR CLASS="z"><TD CLASS="l">2563</TD><TD>                if (binding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2564</TD><TD>                        return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2565</TD><TD>                                CharOperation.arrayConcat(packageBinding.compoundName, name),</TD></TR><TR CLASS="z"><TD CLASS="l">2566</TD><TD>                                null,</TD></TR><TR CLASS="z"><TD CLASS="l">2567</TD><TD>                                ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2568</TD><TD>                if (!binding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">2569</TD><TD>                        return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2570</TD><TD>                                CharOperation.arrayConcat(packageBinding.compoundName, name),</TD></TR><TR CLASS="z"><TD CLASS="l">2571</TD><TD>                                binding instanceof ReferenceBinding ? ((ReferenceBinding)binding).closestMatch() : null,</TD></TR><TR CLASS="z"><TD CLASS="l">2572</TD><TD>                                binding.problemId());</TD></TR><TR><TD CLASS="l">2573</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2574</TD><TD>                ReferenceBinding typeBinding = (ReferenceBinding) binding;</TD></TR><TR CLASS="z"><TD CLASS="l">2575</TD><TD>                if (!typeBinding.canBeSeenBy(this))</TD></TR><TR CLASS="z"><TD CLASS="l">2576</TD><TD>                        return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2577</TD><TD>                                CharOperation.arrayConcat(packageBinding.compoundName, name),</TD></TR><TR CLASS="z"><TD CLASS="l">2578</TD><TD>                                typeBinding,</TD></TR><TR CLASS="z"><TD CLASS="l">2579</TD><TD>                                ProblemReasons.NotVisible);</TD></TR><TR CLASS="z"><TD CLASS="l">2580</TD><TD>                return typeBinding;</TD></TR><TR><TD CLASS="l">2581</TD><TD>        }</TD></TR><TR><TD CLASS="l">2582</TD><TD> </TD></TR><TR><TD CLASS="l">2583</TD><TD>        /* Answer the type binding corresponding to the compoundName.</TD></TR><TR><TD CLASS="l">2584</TD><TD>        *</TD></TR><TR><TD CLASS="l"><A NAME="3c">2585</A></TD><TD>        * NOTE: If a problem binding is returned, senders should extract the compound name</TD></TR><TR><TD CLASS="l">2586</TD><TD>        * from the binding &amp; not assume the problem applies to the entire compoundName.</TD></TR><TR><TD CLASS="l">2587</TD><TD>        */</TD></TR><TR><TD CLASS="l">2588</TD><TD>        public final TypeBinding getType(char[][] compoundName, int typeNameLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">2589</TD><TD>                if (typeNameLength == 1) {</TD></TR><TR><TD CLASS="l">2590</TD><TD>                        // Would like to remove this test and require senders to specially handle base types</TD></TR><TR CLASS="z"><TD CLASS="l">2591</TD><TD>                        TypeBinding binding = getBaseType(compoundName[0]);</TD></TR><TR CLASS="z"><TD CLASS="l">2592</TD><TD>                        if (binding != null) return binding;</TD></TR><TR><TD CLASS="l">2593</TD><TD>                }</TD></TR><TR><TD CLASS="l">2594</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2595</TD><TD>                CompilationUnitScope unitScope = compilationUnitScope();</TD></TR><TR CLASS="z"><TD CLASS="l">2596</TD><TD>                unitScope.recordQualifiedReference(compoundName);</TD></TR><TR CLASS="z"><TD CLASS="l">2597</TD><TD>                Binding binding =</TD></TR><TR CLASS="z"><TD CLASS="l">2598</TD><TD>                        getTypeOrPackage(compoundName[0], typeNameLength == 1 ? Binding.TYPE : Binding.TYPE | Binding.PACKAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2599</TD><TD>                if (binding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2600</TD><TD>                        return new ProblemReferenceBinding(compoundName[0], null, ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2601</TD><TD>                if (!binding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">2602</TD><TD>                        return (ReferenceBinding) binding;</TD></TR><TR><TD CLASS="l">2603</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2604</TD><TD>                int currentIndex = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">2605</TD><TD>                boolean checkVisibility = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2606</TD><TD>                if (binding instanceof PackageBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">2607</TD><TD>                        PackageBinding packageBinding = (PackageBinding) binding;</TD></TR><TR CLASS="z"><TD CLASS="l">2608</TD><TD>                        while (currentIndex &lt; typeNameLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">2609</TD><TD>                                binding = packageBinding.getTypeOrPackage(compoundName[currentIndex++], Binding.TYPE); // does not check visibility</TD></TR><TR CLASS="z"><TD CLASS="l">2610</TD><TD>                                if (binding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2611</TD><TD>                                        return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2612</TD><TD>                                                CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2613</TD><TD>                                                null,</TD></TR><TR CLASS="z"><TD CLASS="l">2614</TD><TD>                                                ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2615</TD><TD>                                if (!binding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">2616</TD><TD>                                        return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2617</TD><TD>                                                CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2618</TD><TD>                                                binding instanceof ReferenceBinding ? ((ReferenceBinding)binding).closestMatch() : null,</TD></TR><TR CLASS="z"><TD CLASS="l">2619</TD><TD>                                                binding.problemId());</TD></TR><TR CLASS="z"><TD CLASS="l">2620</TD><TD>                                if (!(binding instanceof PackageBinding))</TD></TR><TR CLASS="z"><TD CLASS="l">2621</TD><TD>                                        break;</TD></TR><TR CLASS="z"><TD CLASS="l">2622</TD><TD>                                packageBinding = (PackageBinding) binding;</TD></TR><TR><TD CLASS="l">2623</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2624</TD><TD>                        if (binding instanceof PackageBinding)</TD></TR><TR CLASS="z"><TD CLASS="l">2625</TD><TD>                                return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2626</TD><TD>                                        CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2627</TD><TD>                                        null,</TD></TR><TR CLASS="z"><TD CLASS="l">2628</TD><TD>                                        ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2629</TD><TD>                        checkVisibility = true;</TD></TR><TR><TD CLASS="l">2630</TD><TD>                }</TD></TR><TR><TD CLASS="l">2631</TD><TD> </TD></TR><TR><TD CLASS="l">2632</TD><TD>                // binding is now a ReferenceBinding</TD></TR><TR CLASS="z"><TD CLASS="l">2633</TD><TD>                ReferenceBinding typeBinding = (ReferenceBinding) binding;</TD></TR><TR CLASS="z"><TD CLASS="l">2634</TD><TD>                unitScope.recordTypeReference(typeBinding);</TD></TR><TR CLASS="z"><TD CLASS="l">2635</TD><TD>                if (checkVisibility) // handles the fall through case</TD></TR><TR CLASS="z"><TD CLASS="l">2636</TD><TD>                        if (!typeBinding.canBeSeenBy(this))</TD></TR><TR CLASS="z"><TD CLASS="l">2637</TD><TD>                                return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2638</TD><TD>                                        CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2639</TD><TD>                                        typeBinding,</TD></TR><TR CLASS="z"><TD CLASS="l">2640</TD><TD>                                        ProblemReasons.NotVisible);</TD></TR><TR><TD CLASS="l">2641</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2642</TD><TD>                while (currentIndex &lt; typeNameLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">2643</TD><TD>                        typeBinding = getMemberType(compoundName[currentIndex++], typeBinding);</TD></TR><TR CLASS="z"><TD CLASS="l">2644</TD><TD>                        if (!typeBinding.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2645</TD><TD>                                if (typeBinding instanceof ProblemReferenceBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">2646</TD><TD>                                        ProblemReferenceBinding problemBinding = (ProblemReferenceBinding) typeBinding;</TD></TR><TR CLASS="z"><TD CLASS="l">2647</TD><TD>                                        return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2648</TD><TD>                                                CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2649</TD><TD>                                                problemBinding.closestMatch(),</TD></TR><TR CLASS="z"><TD CLASS="l">2650</TD><TD>                                                typeBinding.problemId());</TD></TR><TR><TD CLASS="l">2651</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2652</TD><TD>                                return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2653</TD><TD>                                        CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2654</TD><TD>                                        ((ReferenceBinding)binding).closestMatch(),</TD></TR><TR CLASS="z"><TD CLASS="l">2655</TD><TD>                                        typeBinding.problemId());</TD></TR><TR><TD CLASS="l">2656</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2657</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2658</TD><TD>                return typeBinding;</TD></TR><TR><TD CLASS="l">2659</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="3d">2660</A></TD><TD> </TD></TR><TR><TD CLASS="l">2661</TD><TD>        /* Internal use only</TD></TR><TR><TD CLASS="l">2662</TD><TD>        */</TD></TR><TR><TD CLASS="l">2663</TD><TD>        final Binding getTypeOrPackage(char[] name, int mask) {</TD></TR><TR CLASS="z"><TD CLASS="l">2664</TD><TD>                Scope scope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">2665</TD><TD>                Binding foundType = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2666</TD><TD>                boolean insideStaticContext = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2667</TD><TD>                boolean insideTypeAnnotation = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2668</TD><TD>                if ((mask &amp; Binding.TYPE) == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2669</TD><TD>                        Scope next = scope;</TD></TR><TR CLASS="z"><TD CLASS="l">2670</TD><TD>                        while ((next = scope.parent) != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2671</TD><TD>                                scope = next;</TD></TR><TR><TD CLASS="l">2672</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2673</TD><TD>                        done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found</TD></TR><TR CLASS="z"><TD CLASS="l">2674</TD><TD>                                switch (scope.kind) {</TD></TR><TR><TD CLASS="l">2675</TD><TD>                                        case METHOD_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2676</TD><TD>                                                MethodScope methodScope = (MethodScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">2677</TD><TD>                                                AbstractMethodDeclaration methodDecl = methodScope.referenceMethod();</TD></TR><TR CLASS="z"><TD CLASS="l">2678</TD><TD>                                                if (methodDecl != null &amp;&amp; methodDecl.binding != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2679</TD><TD>                                                        TypeVariableBinding typeVariable = methodDecl.binding.getTypeVariable(name);</TD></TR><TR CLASS="z"><TD CLASS="l">2680</TD><TD>                                                        if (typeVariable != null)        return typeVariable;</TD></TR><TR><TD CLASS="l">2681</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2682</TD><TD>                                                insideStaticContext |= methodScope.isStatic;</TD></TR><TR CLASS="z"><TD CLASS="l">2683</TD><TD>                                                insideTypeAnnotation = methodScope.insideTypeAnnotation;</TD></TR><TR><TD CLASS="l">2684</TD><TD>                                        case BLOCK_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2685</TD><TD>                                                ReferenceBinding localType = ((BlockScope) scope).findLocalType(name); // looks in this scope only</TD></TR><TR CLASS="z"><TD CLASS="l">2686</TD><TD>                                                if (localType != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2687</TD><TD>                                                        if (foundType != null &amp;&amp; foundType != localType)</TD></TR><TR CLASS="z"><TD CLASS="l">2688</TD><TD>                                                                return new ProblemReferenceBinding(name, (ReferenceBinding)foundType, ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR CLASS="z"><TD CLASS="l">2689</TD><TD>                                                        return localType;</TD></TR><TR><TD CLASS="l">2690</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2691</TD><TD>                                                break;</TD></TR><TR><TD CLASS="l">2692</TD><TD>                                        case CLASS_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2693</TD><TD>                                                SourceTypeBinding sourceType = ((ClassScope) scope).getReferenceBinding();</TD></TR><TR CLASS="z"><TD CLASS="l">2694</TD><TD>                                                if (scope == this &amp;&amp; (sourceType.tagBits &amp; TagBits.TypeVariablesAreConnected) == 0) {</TD></TR><TR><TD CLASS="l">2695</TD><TD>                                                        // type variables take precedence over the source type, ex. class X &lt;X&gt; extends X == class X &lt;Y&gt; extends Y</TD></TR><TR><TD CLASS="l">2696</TD><TD>                                                        // but not when we step out to the enclosing type</TD></TR><TR CLASS="z"><TD CLASS="l">2697</TD><TD>                                                        TypeVariableBinding typeVariable = sourceType.getTypeVariable(name);</TD></TR><TR CLASS="z"><TD CLASS="l">2698</TD><TD>                                                        if (typeVariable != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2699</TD><TD>                                                                return typeVariable;</TD></TR><TR CLASS="z"><TD CLASS="l">2700</TD><TD>                                                        if (CharOperation.equals(name, sourceType.sourceName))</TD></TR><TR CLASS="z"><TD CLASS="l">2701</TD><TD>                                                                return sourceType;</TD></TR><TR CLASS="z"><TD CLASS="l">2702</TD><TD>                                                        insideStaticContext |= sourceType.isStatic();</TD></TR><TR CLASS="z"><TD CLASS="l">2703</TD><TD>                                                        break;</TD></TR><TR><TD CLASS="l">2704</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2705</TD><TD>                                                // member types take precedence over type variables</TD></TR><TR CLASS="z"><TD CLASS="l">2706</TD><TD>                                                if (!insideTypeAnnotation) {</TD></TR><TR><TD CLASS="l">2707</TD><TD>                                                        // 6.5.5.1 - member types have precedence over top-level type in same unit</TD></TR><TR CLASS="z"><TD CLASS="l">2708</TD><TD>                                                        ReferenceBinding memberType = findMemberType(name, sourceType);</TD></TR><TR CLASS="z"><TD CLASS="l">2709</TD><TD>                                                        if (memberType != null) { // skip it if we did not find anything</TD></TR><TR CLASS="z"><TD CLASS="l">2710</TD><TD>                                                                if (memberType.problemId() == ProblemReasons.Ambiguous) {</TD></TR><TR CLASS="z"><TD CLASS="l">2711</TD><TD>                                                                        if (foundType == null || foundType.problemId() == ProblemReasons.NotVisible)</TD></TR><TR><TD CLASS="l">2712</TD><TD>                                                                                // supercedes any potential InheritedNameHidesEnclosingName problem</TD></TR><TR CLASS="z"><TD CLASS="l">2713</TD><TD>                                                                                return memberType;</TD></TR><TR><TD CLASS="l">2714</TD><TD>                                                                        // make the user qualify the type, likely wants the first inherited type</TD></TR><TR CLASS="z"><TD CLASS="l">2715</TD><TD>                                                                        return new ProblemReferenceBinding(name,(ReferenceBinding) foundType, ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR><TD CLASS="l">2716</TD><TD>                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2717</TD><TD>                                                                if (memberType.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2718</TD><TD>                                                                        if (sourceType == memberType.enclosingType() || compilerOptions().complianceLevel &gt;= ClassFileConstants.JDK1_4) {</TD></TR><TR CLASS="z"><TD CLASS="l">2719</TD><TD>                                                                                if (insideStaticContext &amp;&amp; !memberType.isStatic() &amp;&amp; sourceType.isGenericType())</TD></TR><TR CLASS="z"><TD CLASS="l">2720</TD><TD>                                                                                        return new ProblemReferenceBinding(name, memberType, ProblemReasons.NonStaticReferenceInStaticContext);</TD></TR><TR><TD CLASS="l">2721</TD><TD>                                                                                // found a valid type in the 'immediate' scope (ie. not inherited)</TD></TR><TR><TD CLASS="l">2722</TD><TD>                                                                                // OR in 1.4 mode (inherited shadows enclosing)</TD></TR><TR CLASS="z"><TD CLASS="l">2723</TD><TD>                                                                                if (foundType == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2724</TD><TD>                                                                                        return memberType;</TD></TR><TR><TD CLASS="l">2725</TD><TD>                                                                                // if a valid type was found, complain when another is found in an 'immediate' enclosing type (ie. not inherited)</TD></TR><TR CLASS="z"><TD CLASS="l">2726</TD><TD>                                                                                if (foundType.isValidBinding() &amp;&amp; foundType != memberType)</TD></TR><TR CLASS="z"><TD CLASS="l">2727</TD><TD>                                                                                        return new ProblemReferenceBinding(name, (ReferenceBinding)foundType, ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR><TD CLASS="l">2728</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">2729</TD><TD>                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2730</TD><TD>                                                                if (foundType == null || (foundType.problemId() == ProblemReasons.NotVisible &amp;&amp; memberType.problemId() != ProblemReasons.NotVisible))</TD></TR><TR><TD CLASS="l">2731</TD><TD>                                                                        // only remember the memberType if its the first one found or the previous one was not visible &amp; memberType is...</TD></TR><TR CLASS="z"><TD CLASS="l">2732</TD><TD>                                                                        foundType = memberType;</TD></TR><TR><TD CLASS="l">2733</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2734</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2735</TD><TD>                                                TypeVariableBinding typeVariable = sourceType.getTypeVariable(name);</TD></TR><TR CLASS="z"><TD CLASS="l">2736</TD><TD>                                                if (typeVariable != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2737</TD><TD>                                                        if (insideStaticContext) // do not consider this type modifiers: access is legite within same type</TD></TR><TR CLASS="z"><TD CLASS="l">2738</TD><TD>                                                                return new ProblemReferenceBinding(name, typeVariable, ProblemReasons.NonStaticReferenceInStaticContext);</TD></TR><TR CLASS="z"><TD CLASS="l">2739</TD><TD>                                                        return typeVariable;</TD></TR><TR><TD CLASS="l">2740</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2741</TD><TD>                                                insideStaticContext |= sourceType.isStatic();</TD></TR><TR CLASS="z"><TD CLASS="l">2742</TD><TD>                                                insideTypeAnnotation = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2743</TD><TD>                                                if (CharOperation.equals(sourceType.sourceName, name)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2744</TD><TD>                                                        if (foundType != null &amp;&amp; foundType != sourceType &amp;&amp; foundType.problemId() != ProblemReasons.NotVisible)</TD></TR><TR CLASS="z"><TD CLASS="l">2745</TD><TD>                                                                return new ProblemReferenceBinding(name, (ReferenceBinding)foundType, ProblemReasons.InheritedNameHidesEnclosingName);</TD></TR><TR CLASS="z"><TD CLASS="l">2746</TD><TD>                                                        return sourceType;</TD></TR><TR><TD CLASS="l">2747</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2748</TD><TD>                                                break;</TD></TR><TR><TD CLASS="l">2749</TD><TD>                                        case COMPILATION_UNIT_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">2750</TD><TD>                                                break done;</TD></TR><TR CLASS="z"><TD CLASS="l">2751</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2752</TD><TD>                                scope = scope.parent;</TD></TR><TR><TD CLASS="l">2753</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2754</TD><TD>                        if (foundType != null &amp;&amp; foundType.problemId() != ProblemReasons.NotVisible)</TD></TR><TR CLASS="z"><TD CLASS="l">2755</TD><TD>                                return foundType;</TD></TR><TR><TD CLASS="l">2756</TD><TD>                }</TD></TR><TR><TD CLASS="l">2757</TD><TD> </TD></TR><TR><TD CLASS="l">2758</TD><TD>                // at this point the scope is a compilation unit scope</TD></TR><TR CLASS="z"><TD CLASS="l">2759</TD><TD>                CompilationUnitScope unitScope = (CompilationUnitScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">2760</TD><TD>                HashtableOfObject typeOrPackageCache = unitScope.typeOrPackageCache;</TD></TR><TR CLASS="z"><TD CLASS="l">2761</TD><TD>                if (typeOrPackageCache != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2762</TD><TD>                        Binding binding = (Binding) typeOrPackageCache.get(name);</TD></TR><TR CLASS="z"><TD CLASS="l">2763</TD><TD>                        if (binding != null) { // can also include NotFound ProblemReferenceBindings if we already know this name is not found</TD></TR><TR CLASS="z"><TD CLASS="l">2764</TD><TD>                                if (binding instanceof ImportBinding) { // single type import cached in faultInImports(), replace it in the cache with the type</TD></TR><TR CLASS="z"><TD CLASS="l">2765</TD><TD>                                        ImportReference importReference = ((ImportBinding) binding).reference;</TD></TR><TR CLASS="z"><TD CLASS="l">2766</TD><TD>                                        if (importReference != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2767</TD><TD>                                                importReference.bits |= ASTNode.Used;</TD></TR><TR CLASS="z"><TD CLASS="l">2768</TD><TD>                                        if (binding instanceof ImportConflictBinding)</TD></TR><TR CLASS="z"><TD CLASS="l">2769</TD><TD>                                                typeOrPackageCache.put(name, binding = ((ImportConflictBinding) binding).conflictingTypeBinding); // already know its visible</TD></TR><TR><TD CLASS="l">2770</TD><TD>                                        else</TD></TR><TR CLASS="z"><TD CLASS="l">2771</TD><TD>                                                typeOrPackageCache.put(name, binding = ((ImportBinding) binding).resolvedImport); // already know its visible</TD></TR><TR><TD CLASS="l">2772</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2773</TD><TD>                                if ((mask &amp; Binding.TYPE) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2774</TD><TD>                                        if (foundType != null &amp;&amp; foundType.problemId() != ProblemReasons.NotVisible &amp;&amp; binding.problemId() != ProblemReasons.Ambiguous)</TD></TR><TR CLASS="z"><TD CLASS="l">2775</TD><TD>                                                return foundType; // problem type from above supercedes NotFound type but not Ambiguous import case</TD></TR><TR CLASS="z"><TD CLASS="l">2776</TD><TD>                                        if (binding instanceof ReferenceBinding)</TD></TR><TR CLASS="z"><TD CLASS="l">2777</TD><TD>                                                return binding; // cached type found in previous walk below</TD></TR><TR><TD CLASS="l">2778</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2779</TD><TD>                                if ((mask &amp; Binding.PACKAGE) != 0 &amp;&amp; binding instanceof PackageBinding)</TD></TR><TR CLASS="z"><TD CLASS="l">2780</TD><TD>                                        return binding; // cached package found in previous walk below</TD></TR><TR><TD CLASS="l">2781</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2782</TD><TD>                }</TD></TR><TR><TD CLASS="l">2783</TD><TD> </TD></TR><TR><TD CLASS="l">2784</TD><TD>                // ask for the imports + name</TD></TR><TR CLASS="z"><TD CLASS="l">2785</TD><TD>                if ((mask &amp; Binding.TYPE|Binding.VARIABLE|Binding.METHOD) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2786</TD><TD>                        ImportBinding[] imports = unitScope.imports;</TD></TR><TR CLASS="z"><TD CLASS="l">2787</TD><TD>                        if (imports != null &amp;&amp; typeOrPackageCache == null) { // walk single type imports since faultInImports() has not run yet</TD></TR><TR CLASS="z"><TD CLASS="l">2788</TD><TD>                                nextImport : for (int i = 0, length = imports.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2789</TD><TD>                                        ImportBinding importBinding = imports[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2790</TD><TD>                                        if (!importBinding.onDemand) {</TD></TR><TR CLASS="z"><TD CLASS="l">2791</TD><TD>                                                if (CharOperation.equals(importBinding.compoundName[importBinding.compoundName.length - 1], name)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2792</TD><TD>                                                        Binding resolvedImport = unitScope.resolveSingleImport(importBinding);</TD></TR><TR CLASS="z"><TD CLASS="l">2793</TD><TD>                                                        if (resolvedImport == null) continue nextImport;</TD></TR><TR CLASS="z"><TD CLASS="l">2794</TD><TD>                                                        if (resolvedImport instanceof MethodBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">2795</TD><TD>                                                                resolvedImport = getType(importBinding.compoundName, importBinding.compoundName.length);</TD></TR><TR CLASS="z"><TD CLASS="l">2796</TD><TD>                                                                if (!resolvedImport.isValidBinding()) continue nextImport;</TD></TR><TR><TD CLASS="l">2797</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2798</TD><TD>                                                        if (resolvedImport instanceof TypeBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">2799</TD><TD>                                                                ImportReference importReference = importBinding.reference;</TD></TR><TR CLASS="z"><TD CLASS="l">2800</TD><TD>                                                                if (importReference != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2801</TD><TD>                                                                        importReference.bits |= ASTNode.Used;</TD></TR><TR CLASS="z"><TD CLASS="l">2802</TD><TD>                                                                return resolvedImport; // already know its visible</TD></TR><TR><TD CLASS="l">2803</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2804</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2805</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2806</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2807</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2808</TD><TD> </TD></TR><TR><TD CLASS="l">2809</TD><TD> </TD></TR><TR><TD CLASS="l">2810</TD><TD>                        // check on file imports</TD></TR><TR CLASS="z"><TD CLASS="l">2811</TD><TD>                        if (imports != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2812</TD><TD>                                boolean foundInImport = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2813</TD><TD>                                Binding type = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2814</TD><TD>                                for (int i = 0, length = imports.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2815</TD><TD>                                        ImportBinding someImport = imports[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2816</TD><TD>                                        if (someImport.reference!=null &amp;&amp; someImport.reference.isFileImport())</TD></TR><TR><TD CLASS="l">2817</TD><TD>                                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2818</TD><TD>                                                Binding resolvedImport = someImport.resolvedImport;</TD></TR><TR CLASS="z"><TD CLASS="l">2819</TD><TD>                                                Binding temp = null;</TD></TR><TR><TD CLASS="l">2820</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2821</TD><TD>                                                if (resolvedImport instanceof CompilationUnitBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">2822</TD><TD>                                                        CompilationUnitBinding compilationUnitBinding =(CompilationUnitBinding)resolvedImport;</TD></TR><TR><TD CLASS="l">2823</TD><TD>                                                        </TD></TR><TR CLASS="z"><TD CLASS="l">2824</TD><TD>                                                        temp = findBinding(name, mask, compilationUnitBinding.getPackage(), unitScope.getDefaultPackage(), false);</TD></TR><TR CLASS="z"><TD CLASS="l">2825</TD><TD>                                                        if (temp!=null &amp;&amp; temp.isValidBinding())</TD></TR><TR><TD CLASS="l">2826</TD><TD>                                                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2827</TD><TD>                                                                ImportReference importReference = someImport.reference;</TD></TR><TR CLASS="z"><TD CLASS="l">2828</TD><TD>                                                                importReference.bits |= ASTNode.Used;</TD></TR><TR CLASS="z"><TD CLASS="l">2829</TD><TD>                                                                if (typeOrPackageCache != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2830</TD><TD>                                                                        typeOrPackageCache.put(name, temp);</TD></TR><TR CLASS="z"><TD CLASS="l">2831</TD><TD>                                                                return temp; // type is always visible to its own package</TD></TR><TR><TD CLASS="l">2832</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2833</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2834</TD><TD>                                                </TD></TR><TR><TD CLASS="l">2835</TD><TD> </TD></TR><TR><TD CLASS="l">2836</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2837</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2838</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2839</TD><TD>                        </TD></TR><TR><TD CLASS="l">2840</TD><TD>                        // check if the name is in the current package, skip it if its a sub-package</TD></TR><TR CLASS="z"><TD CLASS="l">2841</TD><TD>                        PackageBinding currentPackage = unitScope.getDefaultPackage();</TD></TR><TR CLASS="z"><TD CLASS="l">2842</TD><TD>                        unitScope.recordReference(currentPackage.compoundName, name);</TD></TR><TR CLASS="z"><TD CLASS="l">2843</TD><TD>                        Binding binding=currentPackage.getTypeOrPackage(name, mask);</TD></TR><TR CLASS="z"><TD CLASS="l">2844</TD><TD>                        if ( (binding instanceof ReferenceBinding || binding instanceof MethodBinding)</TD></TR><TR CLASS="z"><TD CLASS="l">2845</TD><TD>                                        &amp;&amp; !(binding instanceof ProblemReferenceBinding)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2846</TD><TD>                                if (typeOrPackageCache != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2847</TD><TD>                                        typeOrPackageCache.put(name, binding);</TD></TR><TR CLASS="z"><TD CLASS="l">2848</TD><TD>                                return binding; // type is always visible to its own package</TD></TR><TR><TD CLASS="l">2849</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2850</TD><TD>                        else if (binding instanceof LocalVariableBinding &amp;&amp; binding.isValidBinding())</TD></TR><TR><TD CLASS="l">2851</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2852</TD><TD>                                compilationUnitScope().addExternalVar((LocalVariableBinding)binding);</TD></TR><TR CLASS="z"><TD CLASS="l">2853</TD><TD>                                return binding;</TD></TR><TR><TD CLASS="l">2854</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2855</TD><TD> </TD></TR><TR><TD CLASS="l">2856</TD><TD>                        // check on demand imports</TD></TR><TR CLASS="z"><TD CLASS="l">2857</TD><TD>                        if (imports != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2858</TD><TD>                                boolean foundInImport = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2859</TD><TD>                                Binding type = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2860</TD><TD>                                for (int i = 0, length = imports.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2861</TD><TD>                                        ImportBinding someImport = imports[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2862</TD><TD>                                        if (someImport.onDemand) {</TD></TR><TR CLASS="z"><TD CLASS="l">2863</TD><TD>                                                Binding resolvedImport = someImport.resolvedImport;</TD></TR><TR CLASS="z"><TD CLASS="l">2864</TD><TD>                                                Binding temp = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2865</TD><TD>                                                if (resolvedImport instanceof PackageBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">2866</TD><TD>                                                        temp = findBinding(name, mask, (PackageBinding) resolvedImport, currentPackage, false);</TD></TR><TR><TD CLASS="l">2867</TD><TD>                                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2868</TD><TD>                                                        temp = findDirectMemberType(name, (ReferenceBinding) resolvedImport);</TD></TR><TR><TD CLASS="l">2869</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2870</TD><TD>                                                if (temp != type &amp;&amp; temp != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2871</TD><TD>                                                        if (temp.isValidBinding()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2872</TD><TD>                                                                ImportReference importReference = someImport.reference;</TD></TR><TR CLASS="z"><TD CLASS="l">2873</TD><TD>                                                                if (importReference != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2874</TD><TD>                                                                        importReference.bits |= ASTNode.Used;</TD></TR><TR CLASS="z"><TD CLASS="l">2875</TD><TD>                                                                if (foundInImport) {</TD></TR><TR><TD CLASS="l">2876</TD><TD>                                                                        // Answer error binding -- import on demand conflict; name found in two import on demand packages.</TD></TR><TR CLASS="z"><TD CLASS="l">2877</TD><TD>                                                                        temp = new ProblemReferenceBinding(name, null, ProblemReasons.Ambiguous);</TD></TR><TR CLASS="z"><TD CLASS="l">2878</TD><TD>                                                                        if (typeOrPackageCache != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2879</TD><TD>                                                                                typeOrPackageCache.put(name, temp);</TD></TR><TR CLASS="z"><TD CLASS="l">2880</TD><TD>                                                                        return temp;</TD></TR><TR><TD CLASS="l">2881</TD><TD>                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2882</TD><TD>                                                                type =  temp;</TD></TR><TR CLASS="z"><TD CLASS="l">2883</TD><TD>                                                                foundInImport = true;</TD></TR><TR CLASS="z"><TD CLASS="l">2884</TD><TD>                                                        } else if (foundType == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2885</TD><TD>                                                                foundType = temp;</TD></TR><TR><TD CLASS="l">2886</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2887</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2888</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2889</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2890</TD><TD>                                if (type != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2891</TD><TD>                                        if (typeOrPackageCache != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2892</TD><TD>                                                typeOrPackageCache.put(name, type);</TD></TR><TR CLASS="z"><TD CLASS="l">2893</TD><TD>                                        return type;</TD></TR><TR><TD CLASS="l">2894</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2895</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2896</TD><TD>                }</TD></TR><TR><TD CLASS="l">2897</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2898</TD><TD>                unitScope.recordSimpleReference(name);</TD></TR><TR CLASS="z"><TD CLASS="l">2899</TD><TD>                if ((mask &amp; Binding.PACKAGE) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2900</TD><TD>                        PackageBinding packageBinding = unitScope.environment.getTopLevelPackage(name);</TD></TR><TR CLASS="z"><TD CLASS="l">2901</TD><TD>                        if (packageBinding != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2902</TD><TD>                                if (typeOrPackageCache != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2903</TD><TD>                                        typeOrPackageCache.put(name, packageBinding);</TD></TR><TR CLASS="z"><TD CLASS="l">2904</TD><TD>                                return packageBinding;</TD></TR><TR><TD CLASS="l">2905</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2906</TD><TD>                }</TD></TR><TR><TD CLASS="l">2907</TD><TD> </TD></TR><TR><TD CLASS="l">2908</TD><TD>                // Answer error binding -- could not find name</TD></TR><TR CLASS="z"><TD CLASS="l">2909</TD><TD>                if (foundType == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2910</TD><TD>                        foundType = new ProblemReferenceBinding(name, null, ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2911</TD><TD>                        if (typeOrPackageCache != null &amp;&amp; (mask &amp; Binding.PACKAGE) != 0) // only put NotFound type in cache if you know its not a package</TD></TR><TR CLASS="z"><TD CLASS="l">2912</TD><TD>                                typeOrPackageCache.put(name, foundType);</TD></TR><TR><TD CLASS="l">2913</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2914</TD><TD>                return foundType;</TD></TR><TR><TD CLASS="l">2915</TD><TD>        }</TD></TR><TR><TD CLASS="l">2916</TD><TD> </TD></TR><TR><TD CLASS="l">2917</TD><TD>        // Added for code assist... NOT Public API</TD></TR><TR><TD CLASS="l"><A NAME="3e">2918</A></TD><TD>        // DO NOT USE to resolve import references since this method assumes 'A.B' is relative to a single type import of 'p1.A'</TD></TR><TR><TD CLASS="l">2919</TD><TD>        // when it may actually mean the type B in the package A</TD></TR><TR><TD CLASS="l">2920</TD><TD>        // use CompilationUnitScope.getImport(char[][]) instead</TD></TR><TR><TD CLASS="l">2921</TD><TD>        public final Binding getTypeOrPackage(char[][] compoundName) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3f">2922</A></TD><TD>                return getTypeOrPackage(compoundName,Binding.TYPE | Binding.PACKAGE);</TD></TR><TR><TD CLASS="l">2923</TD><TD>        }</TD></TR><TR><TD CLASS="l">2924</TD><TD> </TD></TR><TR><TD CLASS="l">2925</TD><TD>        public final Binding getTypeOrPackage(char[][] compoundName, int mask) {</TD></TR><TR CLASS="z"><TD CLASS="l">2926</TD><TD>                int nameLength = compoundName.length;</TD></TR><TR CLASS="z"><TD CLASS="l">2927</TD><TD>                if (nameLength == 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">2928</TD><TD>                        TypeBinding binding = getBaseType(compoundName[0]);</TD></TR><TR CLASS="z"><TD CLASS="l">2929</TD><TD>                        if (binding != null) return binding;</TD></TR><TR><TD CLASS="l">2930</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2931</TD><TD>                Binding binding = getTypeOrPackage(compoundName[0], Binding.TYPE | Binding.PACKAGE);</TD></TR><TR CLASS="z"><TD CLASS="l">2932</TD><TD>                if (!binding.isValidBinding()) return binding;</TD></TR><TR><TD CLASS="l">2933</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2934</TD><TD>                int currentIndex = 1;</TD></TR><TR CLASS="z"><TD CLASS="l">2935</TD><TD>                boolean checkVisibility = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2936</TD><TD>                if (binding instanceof PackageBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">2937</TD><TD>                        PackageBinding packageBinding = (PackageBinding) binding;</TD></TR><TR><TD CLASS="l">2938</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2939</TD><TD>                        while (currentIndex &lt; nameLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">2940</TD><TD>                                binding = packageBinding.getTypeOrPackage(compoundName[currentIndex++], mask);</TD></TR><TR CLASS="z"><TD CLASS="l">2941</TD><TD>                                if (binding == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2942</TD><TD>                                        return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2943</TD><TD>                                                CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2944</TD><TD>                                                null,</TD></TR><TR CLASS="z"><TD CLASS="l">2945</TD><TD>                                                ProblemReasons.NotFound);</TD></TR><TR CLASS="z"><TD CLASS="l">2946</TD><TD>                                if (!binding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">2947</TD><TD>                                        return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2948</TD><TD>                                                CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2949</TD><TD>                                                binding instanceof ReferenceBinding ? ((ReferenceBinding)binding).closestMatch() : null,</TD></TR><TR CLASS="z"><TD CLASS="l">2950</TD><TD>                                                binding.problemId());</TD></TR><TR CLASS="z"><TD CLASS="l">2951</TD><TD>                                if (!(binding instanceof PackageBinding))</TD></TR><TR CLASS="z"><TD CLASS="l">2952</TD><TD>                                        break;</TD></TR><TR CLASS="z"><TD CLASS="l">2953</TD><TD>                                packageBinding = (PackageBinding) binding;</TD></TR><TR><TD CLASS="l">2954</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2955</TD><TD>                        if (binding instanceof PackageBinding) return binding;</TD></TR><TR CLASS="z"><TD CLASS="l">2956</TD><TD>                        checkVisibility = true;</TD></TR><TR><TD CLASS="l">2957</TD><TD>                }</TD></TR><TR><TD CLASS="l">2958</TD><TD>                // binding is now a ReferenceBinding</TD></TR><TR CLASS="z"><TD CLASS="l">2959</TD><TD>                ReferenceBinding typeBinding = (ReferenceBinding) binding;</TD></TR><TR CLASS="z"><TD CLASS="l">2960</TD><TD>                ReferenceBinding qualifiedType = (ReferenceBinding) this.environment().convertToRawType(typeBinding);</TD></TR><TR><TD CLASS="l">2961</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2962</TD><TD>                if (checkVisibility) // handles the fall through case</TD></TR><TR CLASS="z"><TD CLASS="l">2963</TD><TD>                        if (!typeBinding.canBeSeenBy(this))</TD></TR><TR CLASS="z"><TD CLASS="l">2964</TD><TD>                                return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2965</TD><TD>                                        CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2966</TD><TD>                                        typeBinding,</TD></TR><TR CLASS="z"><TD CLASS="l">2967</TD><TD>                                        ProblemReasons.NotVisible);</TD></TR><TR><TD CLASS="l">2968</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2969</TD><TD>                while (currentIndex &lt; nameLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">2970</TD><TD>                        typeBinding = getMemberType(compoundName[currentIndex++], typeBinding);</TD></TR><TR><TD CLASS="l">2971</TD><TD>                        // checks visibility</TD></TR><TR CLASS="z"><TD CLASS="l">2972</TD><TD>                        if (!typeBinding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">2973</TD><TD>                                return new ProblemReferenceBinding(</TD></TR><TR CLASS="z"><TD CLASS="l">2974</TD><TD>                                        CharOperation.subarray(compoundName, 0, currentIndex),</TD></TR><TR CLASS="z"><TD CLASS="l">2975</TD><TD>                                        ((ReferenceBinding)binding).closestMatch(),</TD></TR><TR CLASS="z"><TD CLASS="l">2976</TD><TD>                                        typeBinding.problemId());</TD></TR><TR><TD CLASS="l">2977</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2978</TD><TD>                        if (typeBinding.isGenericType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">2979</TD><TD>                                qualifiedType = this.environment().createRawType(typeBinding, qualifiedType);</TD></TR><TR><TD CLASS="l">2980</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2981</TD><TD>                                qualifiedType = (qualifiedType != null &amp;&amp; (qualifiedType.isRawType() || qualifiedType.isParameterizedType()))</TD></TR><TR CLASS="z"><TD CLASS="l">2982</TD><TD>                                        ? this.environment().createParameterizedType(typeBinding, null, qualifiedType)</TD></TR><TR CLASS="z"><TD CLASS="l">2983</TD><TD>                                        : typeBinding;</TD></TR><TR><TD CLASS="l">2984</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2985</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="42">2986</A></TD><TD>                return qualifiedType;</TD></TR><TR><TD CLASS="l">2987</TD><TD>        }</TD></TR><TR><TD CLASS="l">2988</TD><TD> </TD></TR><TR><TD CLASS="l">2989</TD><TD>        protected boolean hasErasedCandidatesCollisions(TypeBinding one, TypeBinding two, Map invocations, ReferenceBinding type, ASTNode typeRef) {</TD></TR><TR CLASS="z"><TD CLASS="l">2990</TD><TD>                invocations.clear();</TD></TR><TR CLASS="z"><TD CLASS="l">2991</TD><TD>                TypeBinding[] mecs = minimalErasedCandidates(new TypeBinding[] {one, two}, invocations);</TD></TR><TR CLASS="z"><TD CLASS="l">2992</TD><TD>                if (mecs != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2993</TD><TD>                        nextCandidate: for (int k = 0, max = mecs.length; k &lt; max; k++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2994</TD><TD>                                TypeBinding mec = mecs[k];</TD></TR><TR CLASS="z"><TD CLASS="l">2995</TD><TD>                                if (mec == null) continue nextCandidate;</TD></TR><TR CLASS="z"><TD CLASS="l">2996</TD><TD>                                Object value = invocations.get(mec);</TD></TR><TR CLASS="z"><TD CLASS="l">2997</TD><TD>                                if (value instanceof TypeBinding[]) {</TD></TR><TR CLASS="z"><TD CLASS="l">2998</TD><TD>                                        TypeBinding[] invalidInvocations = (TypeBinding[]) value;</TD></TR><TR CLASS="z"><TD CLASS="l">2999</TD><TD>                                        problemReporter().superinterfacesCollide(invalidInvocations[0].erasure(), typeRef, invalidInvocations[0], invalidInvocations[1]);</TD></TR><TR CLASS="z"><TD CLASS="l">3000</TD><TD>                                        type.tagBits |= TagBits.HierarchyHasProblems;</TD></TR><TR CLASS="z"><TD CLASS="l">3001</TD><TD>                                        return true;</TD></TR><TR><TD CLASS="l">3002</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3003</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3004</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3005</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">3006</TD><TD>        }</TD></TR><TR><TD CLASS="l">3007</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="43">3008</A></TD><TD>        /**</TD></TR><TR><TD CLASS="l">3009</TD><TD>         * Returns the immediately enclosing switchCase statement (carried by closest blockScope),</TD></TR><TR><TD CLASS="l">3010</TD><TD>         */</TD></TR><TR><TD CLASS="l">3011</TD><TD>        public CaseStatement innermostSwitchCase() {</TD></TR><TR CLASS="z"><TD CLASS="l">3012</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">3013</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">3014</TD><TD>                        if (scope instanceof BlockScope)</TD></TR><TR CLASS="z"><TD CLASS="l">3015</TD><TD>                                return ((BlockScope) scope).enclosingCase;</TD></TR><TR CLASS="z"><TD CLASS="l">3016</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">3017</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="44">3018</A></TD><TD>                return null;</TD></TR><TR><TD CLASS="l">3019</TD><TD>        }</TD></TR><TR><TD CLASS="l">3020</TD><TD> </TD></TR><TR><TD CLASS="l">3021</TD><TD>        protected boolean isAcceptableMethod(MethodBinding one, MethodBinding two) {</TD></TR><TR CLASS="z"><TD CLASS="l">3022</TD><TD>                TypeBinding[] oneParams = one.parameters;</TD></TR><TR CLASS="z"><TD CLASS="l">3023</TD><TD>                TypeBinding[] twoParams = two.parameters;</TD></TR><TR CLASS="z"><TD CLASS="l">3024</TD><TD>                int oneParamsLength = oneParams.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3025</TD><TD>                int twoParamsLength = twoParams.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3026</TD><TD>                if (oneParamsLength == twoParamsLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">3027</TD><TD>                        for (int i = 0; i &lt; oneParamsLength; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3028</TD><TD>                                TypeBinding oneParam = oneParams[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3029</TD><TD>                                TypeBinding twoParam = twoParams[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3030</TD><TD>                                if (oneParam == twoParam) {</TD></TR><TR CLASS="z"><TD CLASS="l">3031</TD><TD>                                        if (oneParam.leafComponentType().isRawType()) {</TD></TR><TR><TD CLASS="l">3032</TD><TD>                                                // A#RAW is not more specific than a rawified A&lt;T&gt;</TD></TR><TR CLASS="z"><TD CLASS="l">3033</TD><TD>                                                if (oneParam == one.original().parameters[i] &amp;&amp; oneParam != two.original().parameters[i])</TD></TR><TR CLASS="z"><TD CLASS="l">3034</TD><TD>                                                        return false;</TD></TR><TR><TD CLASS="l">3035</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3036</TD><TD>                                        continue;</TD></TR><TR><TD CLASS="l">3037</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3038</TD><TD>                                if (oneParam.isCompatibleWith(twoParam)) {</TD></TR><TR CLASS="z"><TD CLASS="l">3039</TD><TD>                                        if (oneParam.leafComponentType().isRawType()) {</TD></TR><TR><TD CLASS="l">3040</TD><TD>                                                // A#RAW is not more specific than a rawified A&lt;T&gt;</TD></TR><TR CLASS="z"><TD CLASS="l">3041</TD><TD>                                                if (oneParam.needsUncheckedConversion(two.declaringClass.isRawType() ? twoParam : two.original().parameters[i]))</TD></TR><TR CLASS="z"><TD CLASS="l">3042</TD><TD>                                                        return false;</TD></TR><TR><TD CLASS="l">3043</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3044</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">3045</TD><TD>                                        if (i == oneParamsLength - 1 &amp;&amp; one.isVarargs() &amp;&amp; two.isVarargs()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3046</TD><TD>                                                TypeBinding eType = ((ArrayBinding) twoParam).elementsType();</TD></TR><TR CLASS="z"><TD CLASS="l">3047</TD><TD>                                                if (oneParam == eType || oneParam.isCompatibleWith(eType))</TD></TR><TR CLASS="z"><TD CLASS="l">3048</TD><TD>                                                        return true; // special case to choose between 2 varargs methods when the last arg is Object[]</TD></TR><TR><TD CLASS="l">3049</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3050</TD><TD>                                        return false;</TD></TR><TR><TD CLASS="l">3051</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3052</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3053</TD><TD>                        return true;</TD></TR><TR><TD CLASS="l">3054</TD><TD>                }</TD></TR><TR><TD CLASS="l">3055</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3056</TD><TD>                if (one.isVarargs() &amp;&amp; two.isVarargs()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3057</TD><TD>                        if (oneParamsLength &gt; twoParamsLength) {</TD></TR><TR><TD CLASS="l">3058</TD><TD>                                // special case when autoboxing makes (int, int...) better than (Object...) but not (int...) or (Integer, int...)</TD></TR><TR CLASS="z"><TD CLASS="l">3059</TD><TD>                                if (((ArrayBinding) twoParams[twoParamsLength - 1]).elementsType().id != TypeIds.T_JavaLangObject)</TD></TR><TR CLASS="z"><TD CLASS="l">3060</TD><TD>                                        return false;</TD></TR><TR><TD CLASS="l">3061</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3062</TD><TD>                        // check that each parameter before the vararg parameters are compatible (no autoboxing allowed here)</TD></TR><TR CLASS="z"><TD CLASS="l">3063</TD><TD>                        for (int i = (oneParamsLength &gt; twoParamsLength ? twoParamsLength : oneParamsLength) - 2; i &gt;= 0; i--)</TD></TR><TR CLASS="z"><TD CLASS="l">3064</TD><TD>                                if (oneParams[i] != twoParams[i] &amp;&amp; !oneParams[i].isCompatibleWith(twoParams[i]))</TD></TR><TR CLASS="z"><TD CLASS="l">3065</TD><TD>                                        return false;</TD></TR><TR CLASS="z"><TD CLASS="l">3066</TD><TD>                        if (parameterCompatibilityLevel(one, twoParams) == NOT_COMPATIBLE</TD></TR><TR CLASS="z"><TD CLASS="l">3067</TD><TD>                                &amp;&amp; parameterCompatibilityLevel(two, oneParams) == VARARGS_COMPATIBLE)</TD></TR><TR CLASS="z"><TD CLASS="l">3068</TD><TD>                                        return true;</TD></TR><TR><TD CLASS="l">3069</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="45">3070</A></TD><TD>                return false;</TD></TR><TR><TD CLASS="l">3071</TD><TD>        }</TD></TR><TR><TD CLASS="l">3072</TD><TD> </TD></TR><TR><TD CLASS="l">3073</TD><TD>        public boolean isBoxingCompatibleWith(TypeBinding expressionType, TypeBinding targetType) {</TD></TR><TR CLASS="z"><TD CLASS="l">3074</TD><TD>                LookupEnvironment environment = environment();</TD></TR><TR CLASS="z"><TD CLASS="l">3075</TD><TD>                if (environment.globalOptions.sourceLevel &lt; ClassFileConstants.JDK1_5 || expressionType.isBaseType() == targetType.isBaseType())</TD></TR><TR CLASS="z"><TD CLASS="l">3076</TD><TD>                        return false;</TD></TR><TR><TD CLASS="l">3077</TD><TD> </TD></TR><TR><TD CLASS="l">3078</TD><TD>                // check if autoboxed type is compatible</TD></TR><TR CLASS="z"><TD CLASS="l">3079</TD><TD>                TypeBinding convertedType = environment.computeBoxingType(expressionType);</TD></TR><TR CLASS="z"><TD CLASS="l">3080</TD><TD>                return convertedType == targetType || convertedType.isCompatibleWith(targetType);</TD></TR><TR><TD CLASS="l">3081</TD><TD>        }</TD></TR><TR><TD CLASS="l">3082</TD><TD> </TD></TR><TR><TD CLASS="l">3083</TD><TD>        /* Answer true if the scope is nested inside a given field declaration.</TD></TR><TR><TD CLASS="l"><A NAME="46">3084</A></TD><TD>         * Note: it works as long as the scope.fieldDeclarationIndex is reflecting the field being traversed</TD></TR><TR><TD CLASS="l">3085</TD><TD>         * e.g. during name resolution.</TD></TR><TR><TD CLASS="l">3086</TD><TD>        */</TD></TR><TR><TD CLASS="l">3087</TD><TD>        public final boolean isDefinedInField(FieldBinding field) {</TD></TR><TR CLASS="z"><TD CLASS="l">3088</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">3089</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">3090</TD><TD>                        if (scope instanceof MethodScope) {</TD></TR><TR CLASS="z"><TD CLASS="l">3091</TD><TD>                                MethodScope methodScope = (MethodScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">3092</TD><TD>                                if (methodScope.initializedField == field) return true;</TD></TR><TR><TD CLASS="l">3093</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3094</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">3095</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l">3096</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">3097</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="47">3098</A></TD><TD> </TD></TR><TR><TD CLASS="l">3099</TD><TD>        /* Answer true if the scope is nested inside a given method declaration</TD></TR><TR><TD CLASS="l">3100</TD><TD>        */</TD></TR><TR><TD CLASS="l">3101</TD><TD>        public final boolean isDefinedInMethod(MethodBinding method) {</TD></TR><TR CLASS="z"><TD CLASS="l">3102</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">3103</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">3104</TD><TD>                        if (scope instanceof MethodScope) {</TD></TR><TR CLASS="z"><TD CLASS="l">3105</TD><TD>                                ReferenceContext refContext = ((MethodScope) scope).referenceContext;</TD></TR><TR CLASS="z"><TD CLASS="l">3106</TD><TD>                                if (refContext instanceof AbstractMethodDeclaration)</TD></TR><TR CLASS="z"><TD CLASS="l">3107</TD><TD>                                        if (((AbstractMethodDeclaration) refContext).binding == method)</TD></TR><TR CLASS="z"><TD CLASS="l">3108</TD><TD>                                                return true;</TD></TR><TR><TD CLASS="l">3109</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3110</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">3111</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l">3112</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">3113</TD><TD>        }</TD></TR><TR><TD CLASS="l">3114</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="48">3115</A></TD><TD>        /* Answer whether the type is defined in the same compilation unit as the receiver</TD></TR><TR><TD CLASS="l">3116</TD><TD>        */</TD></TR><TR><TD CLASS="l">3117</TD><TD>        public final boolean isDefinedInSameUnit(ReferenceBinding type) {</TD></TR><TR><TD CLASS="l">3118</TD><TD>                // find the outer most enclosing type</TD></TR><TR CLASS="z"><TD CLASS="l">3119</TD><TD>                ReferenceBinding enclosingType = type;</TD></TR><TR CLASS="z"><TD CLASS="l">3120</TD><TD>                while ((type = enclosingType.enclosingType()) != null)</TD></TR><TR CLASS="z"><TD CLASS="l">3121</TD><TD>                        enclosingType = type;</TD></TR><TR><TD CLASS="l">3122</TD><TD> </TD></TR><TR><TD CLASS="l">3123</TD><TD>                // find the compilation unit scope</TD></TR><TR CLASS="z"><TD CLASS="l">3124</TD><TD>                Scope scope, unitScope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">3125</TD><TD>                while ((scope = unitScope.parent) != null)</TD></TR><TR CLASS="z"><TD CLASS="l">3126</TD><TD>                        unitScope = scope;</TD></TR><TR><TD CLASS="l">3127</TD><TD> </TD></TR><TR><TD CLASS="l">3128</TD><TD>                // test that the enclosingType is not part of the compilation unit</TD></TR><TR CLASS="z"><TD CLASS="l">3129</TD><TD>                SourceTypeBinding[] topLevelTypes = ((CompilationUnitScope) unitScope).topLevelTypes;</TD></TR><TR CLASS="z"><TD CLASS="l">3130</TD><TD>                for (int i = topLevelTypes.length; --i &gt;= 0;)</TD></TR><TR CLASS="z"><TD CLASS="l">3131</TD><TD>                        if (topLevelTypes[i] == enclosingType)</TD></TR><TR CLASS="z"><TD CLASS="l">3132</TD><TD>                                return true;</TD></TR><TR CLASS="z"><TD CLASS="l">3133</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">3134</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="49">3135</A></TD><TD> </TD></TR><TR><TD CLASS="l">3136</TD><TD>        /* Answer true if the scope is nested inside a given type declaration</TD></TR><TR><TD CLASS="l">3137</TD><TD>        */</TD></TR><TR><TD CLASS="l">3138</TD><TD>        public final boolean isDefinedInType(ReferenceBinding type) {</TD></TR><TR CLASS="z"><TD CLASS="l">3139</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">3140</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">3141</TD><TD>                        if (scope instanceof ClassScope)</TD></TR><TR CLASS="z"><TD CLASS="l">3142</TD><TD>                                if (((ClassScope) scope).getReferenceBinding() == type)</TD></TR><TR CLASS="z"><TD CLASS="l">3143</TD><TD>                                        return true;</TD></TR><TR CLASS="z"><TD CLASS="l">3144</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">3145</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l">3146</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">3147</TD><TD>        }</TD></TR><TR><TD CLASS="l">3148</TD><TD> </TD></TR><TR><TD CLASS="l">3149</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="4a">3150</A></TD><TD>         * Returns true if the scope or one of its parent is associated to a given caseStatement, denoting</TD></TR><TR><TD CLASS="l">3151</TD><TD>         * being part of a given switch case statement.</TD></TR><TR><TD CLASS="l">3152</TD><TD>         */</TD></TR><TR><TD CLASS="l">3153</TD><TD>        public boolean isInsideCase(CaseStatement caseStatement) {</TD></TR><TR CLASS="z"><TD CLASS="l">3154</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">3155</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">3156</TD><TD>                        switch (scope.kind) {</TD></TR><TR><TD CLASS="l">3157</TD><TD>                                case Scope.BLOCK_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">3158</TD><TD>                                        if (((BlockScope) scope).enclosingCase == caseStatement) {</TD></TR><TR CLASS="z"><TD CLASS="l">3159</TD><TD>                                                return true;</TD></TR><TR><TD CLASS="l">3160</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3161</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3162</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">3163</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4b">3164</A></TD><TD>                return false;</TD></TR><TR><TD CLASS="l">3165</TD><TD>        }</TD></TR><TR><TD CLASS="l">3166</TD><TD> </TD></TR><TR><TD CLASS="l">3167</TD><TD>        public boolean isInsideDeprecatedCode(){</TD></TR><TR CLASS="z"><TD CLASS="l">3168</TD><TD>                switch(this.kind){</TD></TR><TR><TD CLASS="l">3169</TD><TD>                        case Scope.BLOCK_SCOPE :</TD></TR><TR><TD CLASS="l">3170</TD><TD>                        case Scope.METHOD_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">3171</TD><TD>                                MethodScope methodScope = methodScope();</TD></TR><TR CLASS="z"><TD CLASS="l">3172</TD><TD>                                if (!methodScope.isInsideInitializer()){</TD></TR><TR><TD CLASS="l">3173</TD><TD>                                        // check method modifiers to see if deprecated</TD></TR><TR CLASS="z"><TD CLASS="l">3174</TD><TD>                                        MethodBinding context = ((AbstractMethodDeclaration)methodScope.referenceContext).binding;</TD></TR><TR CLASS="z"><TD CLASS="l">3175</TD><TD>                                        if (context != null &amp;&amp; context.isViewedAsDeprecated())</TD></TR><TR CLASS="z"><TD CLASS="l">3176</TD><TD>                                                return true;</TD></TR><TR><TD CLASS="l">3177</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">3178</TD><TD>                                        SourceTypeBinding type = ((BlockScope)this).referenceType().binding;</TD></TR><TR><TD CLASS="l">3179</TD><TD>                                        // inside field declaration ? check field modifier to see if deprecated</TD></TR><TR CLASS="z"><TD CLASS="l">3180</TD><TD>                                        if (methodScope.initializedField != null &amp;&amp; methodScope.initializedField.isViewedAsDeprecated())</TD></TR><TR CLASS="z"><TD CLASS="l">3181</TD><TD>                                                return true;</TD></TR><TR CLASS="z"><TD CLASS="l">3182</TD><TD>                                        if (type != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3183</TD><TD>                                                type.initializeDeprecatedAnnotationTagBits(); // may not have been resolved until then</TD></TR><TR CLASS="z"><TD CLASS="l">3184</TD><TD>                                                if (type.isViewedAsDeprecated())</TD></TR><TR CLASS="z"><TD CLASS="l">3185</TD><TD>                                                        return true;</TD></TR><TR><TD CLASS="l">3186</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3187</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3188</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">3189</TD><TD>                        case Scope.CLASS_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">3190</TD><TD>                                ReferenceBinding context = ((ClassScope)this).referenceType().binding;</TD></TR><TR CLASS="z"><TD CLASS="l">3191</TD><TD>                                if (context != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3192</TD><TD>                                        context.initializeDeprecatedAnnotationTagBits(); // may not have been resolved until then</TD></TR><TR CLASS="z"><TD CLASS="l">3193</TD><TD>                                        if (context.isViewedAsDeprecated())</TD></TR><TR CLASS="z"><TD CLASS="l">3194</TD><TD>                                                return true;</TD></TR><TR><TD CLASS="l">3195</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3196</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">3197</TD><TD>                        case Scope.COMPILATION_UNIT_SCOPE :</TD></TR><TR><TD CLASS="l">3198</TD><TD>                                // consider import as being deprecated if first type is itself deprecated (123522)</TD></TR><TR CLASS="z"><TD CLASS="l">3199</TD><TD>                                CompilationUnitDeclaration unit = referenceCompilationUnit();</TD></TR><TR CLASS="z"><TD CLASS="l">3200</TD><TD>                                if (unit.types != null &amp;&amp; unit.types.length &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">3201</TD><TD>                                        SourceTypeBinding type = unit.types[0].binding;</TD></TR><TR CLASS="z"><TD CLASS="l">3202</TD><TD>                                        if (type != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3203</TD><TD>                                                type.initializeDeprecatedAnnotationTagBits(); // may not have been resolved until then</TD></TR><TR CLASS="z"><TD CLASS="l">3204</TD><TD>                                                if (type.isViewedAsDeprecated())</TD></TR><TR CLASS="z"><TD CLASS="l">3205</TD><TD>                                                        return true;</TD></TR><TR><TD CLASS="l">3206</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3207</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3208</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4c">3209</A></TD><TD>                return false;</TD></TR><TR><TD CLASS="l">3210</TD><TD>        }</TD></TR><TR><TD CLASS="l">3211</TD><TD> </TD></TR><TR><TD CLASS="l">3212</TD><TD>        private TypeBinding leastContainingInvocation(TypeBinding mec, Object invocationData, List lubStack) {</TD></TR><TR CLASS="z"><TD CLASS="l">3213</TD><TD>                if (invocationData == null) return mec; // no alternate invocation</TD></TR><TR CLASS="z"><TD CLASS="l">3214</TD><TD>                if (invocationData instanceof TypeBinding) { // only one invocation, simply return it (array only allocated if more than one)</TD></TR><TR CLASS="z"><TD CLASS="l">3215</TD><TD>                        return (TypeBinding) invocationData;</TD></TR><TR><TD CLASS="l">3216</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3217</TD><TD>                TypeBinding[] invocations = (TypeBinding[]) invocationData;</TD></TR><TR><TD CLASS="l">3218</TD><TD> </TD></TR><TR><TD CLASS="l">3219</TD><TD>                // if mec is an array type, intersect invocation leaf component types, then promote back to array</TD></TR><TR CLASS="z"><TD CLASS="l">3220</TD><TD>                int dim = mec.dimensions();</TD></TR><TR CLASS="z"><TD CLASS="l">3221</TD><TD>                mec = mec.leafComponentType();</TD></TR><TR><TD CLASS="l">3222</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3223</TD><TD>                int argLength = mec.typeVariables().length;</TD></TR><TR CLASS="z"><TD CLASS="l">3224</TD><TD>                if (argLength == 0) return mec; // should be caught by no invocation check</TD></TR><TR><TD CLASS="l">3225</TD><TD> </TD></TR><TR><TD CLASS="l">3226</TD><TD>                // infer proper parameterized type from invocations</TD></TR><TR CLASS="z"><TD CLASS="l">3227</TD><TD>                TypeBinding[] bestArguments = new TypeBinding[argLength];</TD></TR><TR CLASS="z"><TD CLASS="l">3228</TD><TD>                for (int i = 0, length = invocations.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3229</TD><TD>                        TypeBinding invocation = invocations[i].leafComponentType();</TD></TR><TR CLASS="z"><TD CLASS="l">3230</TD><TD>                        switch (invocation.kind()) {</TD></TR><TR><TD CLASS="l">3231</TD><TD>                                case Binding.GENERIC_TYPE :</TD></TR><TR CLASS="z"><TD CLASS="l">3232</TD><TD>                                        TypeVariableBinding[] invocationVariables = invocation.typeVariables();</TD></TR><TR CLASS="z"><TD CLASS="l">3233</TD><TD>                                        for (int j = 0; j &lt; argLength; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3234</TD><TD>                                                TypeBinding bestArgument = leastContainingTypeArgument(bestArguments[j], invocationVariables[j], (ReferenceBinding) mec, j, lubStack);</TD></TR><TR CLASS="z"><TD CLASS="l">3235</TD><TD>                                                if (bestArgument == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">3236</TD><TD>                                                bestArguments[j] = bestArgument;</TD></TR><TR><TD CLASS="l">3237</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3238</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">3239</TD><TD>                                case Binding.PARAMETERIZED_TYPE :</TD></TR><TR CLASS="z"><TD CLASS="l">3240</TD><TD>                                        ParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding)invocation;</TD></TR><TR CLASS="z"><TD CLASS="l">3241</TD><TD>                                        for (int j = 0; j &lt; argLength; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3242</TD><TD>                                                TypeBinding bestArgument = leastContainingTypeArgument(bestArguments[j], parameterizedType.arguments[j], (ReferenceBinding) mec, j, lubStack);</TD></TR><TR CLASS="z"><TD CLASS="l">3243</TD><TD>                                                if (bestArgument == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">3244</TD><TD>                                                bestArguments[j] = bestArgument;</TD></TR><TR><TD CLASS="l">3245</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3246</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">3247</TD><TD>                                case Binding.RAW_TYPE :</TD></TR><TR CLASS="z"><TD CLASS="l">3248</TD><TD>                                        return dim == 0 ? invocation : environment().createArrayType(invocation, dim); // raw type is taking precedence</TD></TR><TR><TD CLASS="l">3249</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3250</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3251</TD><TD>                TypeBinding least = environment().createParameterizedType((ReferenceBinding) mec.erasure(), bestArguments, mec.enclosingType());</TD></TR><TR CLASS="z"><TD CLASS="l">3252</TD><TD>                return dim == 0 ? least : environment().createArrayType(least, dim);</TD></TR><TR><TD CLASS="l"><A NAME="4d">3253</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">3254</TD><TD> </TD></TR><TR><TD CLASS="l">3255</TD><TD>        // JLS 15.12.2</TD></TR><TR><TD CLASS="l">3256</TD><TD>        private TypeBinding leastContainingTypeArgument(TypeBinding u, TypeBinding v, ReferenceBinding genericType, int rank, List lubStack) {</TD></TR><TR CLASS="z"><TD CLASS="l">3257</TD><TD>                if (u == null) return v;</TD></TR><TR CLASS="z"><TD CLASS="l">3258</TD><TD>                if (u == v) return u;</TD></TR><TR CLASS="z"><TD CLASS="l">3259</TD><TD>                if (v.isWildcard()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3260</TD><TD>                        WildcardBinding wildV = (WildcardBinding) v;</TD></TR><TR CLASS="z"><TD CLASS="l">3261</TD><TD>                        if (u.isWildcard()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3262</TD><TD>                                WildcardBinding wildU = (WildcardBinding) u;</TD></TR><TR CLASS="z"><TD CLASS="l">3263</TD><TD>                                switch (wildU.boundKind) {</TD></TR><TR><TD CLASS="l">3264</TD><TD>                                        // ? extends U</TD></TR><TR><TD CLASS="l">3265</TD><TD>                                        case Wildcard.EXTENDS :</TD></TR><TR CLASS="z"><TD CLASS="l">3266</TD><TD>                                                switch(wildV.boundKind) {</TD></TR><TR><TD CLASS="l">3267</TD><TD>                                                        // ? extends U, ? extends V</TD></TR><TR><TD CLASS="l">3268</TD><TD>                                                        case Wildcard.EXTENDS :</TD></TR><TR CLASS="z"><TD CLASS="l">3269</TD><TD>                                                                TypeBinding lub = lowerUpperBound(new TypeBinding[]{wildU.bound,wildV.bound}, lubStack);</TD></TR><TR CLASS="z"><TD CLASS="l">3270</TD><TD>                                                                if (lub == null) return null;</TD></TR><TR><TD CLASS="l">3271</TD><TD>                                                                // int is returned to denote cycle detected in lub computation - stop recursion by answering unbound wildcard</TD></TR><TR CLASS="z"><TD CLASS="l">3272</TD><TD>                                                                if (lub == TypeBinding.INT) return environment().createWildcard(genericType, rank, null, null /*no extra bound*/, Wildcard.UNBOUND);</TD></TR><TR CLASS="z"><TD CLASS="l">3273</TD><TD>                                                                return environment().createWildcard(genericType, rank, lub, null /*no extra bound*/, Wildcard.EXTENDS);</TD></TR><TR><TD CLASS="l">3274</TD><TD>                                                        // ? extends U, ? SUPER V</TD></TR><TR><TD CLASS="l">3275</TD><TD>                                                        case Wildcard.SUPER :</TD></TR><TR CLASS="z"><TD CLASS="l">3276</TD><TD>                                                                if (wildU.bound == wildV.bound) return wildU.bound;</TD></TR><TR CLASS="z"><TD CLASS="l">3277</TD><TD>                                                                return environment().createWildcard(genericType, rank, null, null /*no extra bound*/, Wildcard.UNBOUND);</TD></TR><TR><TD CLASS="l">3278</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3279</TD><TD>                                                break;</TD></TR><TR><TD CLASS="l">3280</TD><TD>                                                // ? super U</TD></TR><TR><TD CLASS="l">3281</TD><TD>                                        case Wildcard.SUPER :</TD></TR><TR><TD CLASS="l">3282</TD><TD>                                                // ? super U, ? super V</TD></TR><TR CLASS="z"><TD CLASS="l">3283</TD><TD>                                                if (wildU.boundKind == Wildcard.SUPER) {</TD></TR><TR CLASS="z"><TD CLASS="l">3284</TD><TD>                                                        TypeBinding[] glb = greaterLowerBound(new TypeBinding[]{wildU.bound,wildV.bound});</TD></TR><TR CLASS="z"><TD CLASS="l">3285</TD><TD>                                                        if (glb == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">3286</TD><TD>                                                        return environment().createWildcard(genericType, rank, glb[0], null /*no extra bound*/, Wildcard.SUPER);        // TODO (philippe) need to capture entire bounds</TD></TR><TR><TD CLASS="l">3287</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3288</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3289</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">3290</TD><TD>                                switch (wildV.boundKind) {</TD></TR><TR><TD CLASS="l">3291</TD><TD>                                        // U, ? extends V</TD></TR><TR><TD CLASS="l">3292</TD><TD>                                        case Wildcard.EXTENDS :</TD></TR><TR CLASS="z"><TD CLASS="l">3293</TD><TD>                                                TypeBinding lub = lowerUpperBound(new TypeBinding[]{u,wildV.bound}, lubStack);</TD></TR><TR CLASS="z"><TD CLASS="l">3294</TD><TD>                                                if (lub == null) return null;</TD></TR><TR><TD CLASS="l">3295</TD><TD>                                                // int is returned to denote cycle detected in lub computation - stop recursion by answering unbound wildcard</TD></TR><TR CLASS="z"><TD CLASS="l">3296</TD><TD>                                                if (lub == TypeBinding.INT) return environment().createWildcard(genericType, rank, null, null /*no extra bound*/, Wildcard.UNBOUND);</TD></TR><TR CLASS="z"><TD CLASS="l">3297</TD><TD>                                                return environment().createWildcard(genericType, rank, lub, null /*no extra bound*/, Wildcard.EXTENDS);</TD></TR><TR><TD CLASS="l">3298</TD><TD>                                        // U, ? super V</TD></TR><TR><TD CLASS="l">3299</TD><TD>                                        case Wildcard.SUPER :</TD></TR><TR CLASS="z"><TD CLASS="l">3300</TD><TD>                                                TypeBinding[] glb = greaterLowerBound(new TypeBinding[]{u,wildV.bound});</TD></TR><TR CLASS="z"><TD CLASS="l">3301</TD><TD>                                                if (glb == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">3302</TD><TD>                                                return environment().createWildcard(genericType, rank, glb[0], null /*no extra bound*/, Wildcard.SUPER);        // TODO (philippe) need to capture entire bounds</TD></TR><TR><TD CLASS="l">3303</TD><TD>                                        case Wildcard.UNBOUND :</TD></TR><TR CLASS="z"><TD CLASS="l">3304</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3305</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3306</TD><TD>                } else if (u.isWildcard()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3307</TD><TD>                        WildcardBinding wildU = (WildcardBinding) u;</TD></TR><TR CLASS="z"><TD CLASS="l">3308</TD><TD>                        switch (wildU.boundKind) {</TD></TR><TR><TD CLASS="l">3309</TD><TD>                                // U, ? extends V</TD></TR><TR><TD CLASS="l">3310</TD><TD>                                case Wildcard.EXTENDS :</TD></TR><TR CLASS="z"><TD CLASS="l">3311</TD><TD>                                        TypeBinding lub = lowerUpperBound(new TypeBinding[]{wildU.bound, v}, lubStack);</TD></TR><TR CLASS="z"><TD CLASS="l">3312</TD><TD>                                        if (lub == null) return null;</TD></TR><TR><TD CLASS="l">3313</TD><TD>                                        // int is returned to denote cycle detected in lub computation - stop recursion by answering unbound wildcard</TD></TR><TR CLASS="z"><TD CLASS="l">3314</TD><TD>                                        if (lub == TypeBinding.INT) return environment().createWildcard(genericType, rank, null, null /*no extra bound*/, Wildcard.UNBOUND);</TD></TR><TR CLASS="z"><TD CLASS="l">3315</TD><TD>                                        return environment().createWildcard(genericType, rank, lub, null /*no extra bound*/, Wildcard.EXTENDS);</TD></TR><TR><TD CLASS="l">3316</TD><TD>                                // U, ? super V</TD></TR><TR><TD CLASS="l">3317</TD><TD>                                case Wildcard.SUPER :</TD></TR><TR CLASS="z"><TD CLASS="l">3318</TD><TD>                                        TypeBinding[] glb = greaterLowerBound(new TypeBinding[]{wildU.bound, v});</TD></TR><TR CLASS="z"><TD CLASS="l">3319</TD><TD>                                        if (glb == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">3320</TD><TD>                                        return environment().createWildcard(genericType, rank, glb[0], null /*no extra bound*/, Wildcard.SUPER); // TODO (philippe) need to capture entire bounds</TD></TR><TR><TD CLASS="l">3321</TD><TD>                                case Wildcard.UNBOUND :</TD></TR><TR><TD CLASS="l">3322</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3323</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3324</TD><TD>                TypeBinding lub = lowerUpperBound(new TypeBinding[]{u,v}, lubStack);</TD></TR><TR CLASS="z"><TD CLASS="l">3325</TD><TD>                if (lub == null) return null;</TD></TR><TR><TD CLASS="l">3326</TD><TD>                // int is returned to denote cycle detected in lub computation - stop recursion by answering unbound wildcard</TD></TR><TR CLASS="z"><TD CLASS="l">3327</TD><TD>                if (lub == TypeBinding.INT) return environment().createWildcard(genericType, rank, null, null /*no extra bound*/, Wildcard.UNBOUND);</TD></TR><TR CLASS="z"><TD CLASS="l">3328</TD><TD>                return environment().createWildcard(genericType, rank, lub, null /*no extra bound*/, Wildcard.EXTENDS);</TD></TR><TR><TD CLASS="l">3329</TD><TD>        }</TD></TR><TR><TD CLASS="l">3330</TD><TD> </TD></TR><TR><TD CLASS="l">3331</TD><TD>        // 15.12.2</TD></TR><TR><TD CLASS="l">3332</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="4e">3333</A></TD><TD>         * Returns VoidBinding if types have no intersection (e.g. 2 unrelated interfaces), or null if</TD></TR><TR><TD CLASS="l">3334</TD><TD>         * no common supertype (e.g. List&lt;String&gt; and List&lt;Exception&gt;), or the intersection type if possible</TD></TR><TR><TD CLASS="l">3335</TD><TD>         */</TD></TR><TR><TD CLASS="l">3336</TD><TD>        public TypeBinding lowerUpperBound(TypeBinding[] types) {</TD></TR><TR CLASS="z"><TD CLASS="l">3337</TD><TD>                int typeLength = types.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3338</TD><TD>                if (typeLength == 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">3339</TD><TD>                        TypeBinding type = types[0];</TD></TR><TR CLASS="z"><TD CLASS="l">3340</TD><TD>                        return type == null ? TypeBinding.VOID : type;</TD></TR><TR><TD CLASS="l">3341</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3342</TD><TD>                return lowerUpperBound(types, new ArrayList(1));</TD></TR><TR><TD CLASS="l">3343</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="4f">3344</A></TD><TD> </TD></TR><TR><TD CLASS="l">3345</TD><TD>        // 15.12.2</TD></TR><TR><TD CLASS="l">3346</TD><TD>        private TypeBinding lowerUpperBound(TypeBinding[] types, List lubStack) {</TD></TR><TR><TD CLASS="l">3347</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3348</TD><TD>                int typeLength = types.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3349</TD><TD>                if (typeLength == 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">3350</TD><TD>                        TypeBinding type = types[0];</TD></TR><TR CLASS="z"><TD CLASS="l">3351</TD><TD>                        return type == null ? TypeBinding.VOID : type;</TD></TR><TR><TD CLASS="l">3352</TD><TD>                }</TD></TR><TR><TD CLASS="l">3353</TD><TD>                // cycle detection</TD></TR><TR CLASS="z"><TD CLASS="l">3354</TD><TD>                int stackLength = lubStack.size();</TD></TR><TR CLASS="z"><TD CLASS="l">3355</TD><TD>                nextLubCheck: for (int i = 0; i &lt; stackLength; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3356</TD><TD>                        TypeBinding[] lubTypes = (TypeBinding[])lubStack.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">3357</TD><TD>                        int lubTypeLength = lubTypes.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3358</TD><TD>                        if (lubTypeLength &lt; typeLength) continue nextLubCheck;</TD></TR><TR CLASS="z"><TD CLASS="l">3359</TD><TD>                        nextTypeCheck:        for (int j = 0; j &lt; typeLength; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3360</TD><TD>                                TypeBinding type = types[j];</TD></TR><TR CLASS="z"><TD CLASS="l">3361</TD><TD>                                if (type == null) continue nextTypeCheck; // ignore</TD></TR><TR CLASS="z"><TD CLASS="l">3362</TD><TD>                                for (int k = 0; k &lt; lubTypeLength; k++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3363</TD><TD>                                        TypeBinding lubType = lubTypes[k];</TD></TR><TR CLASS="z"><TD CLASS="l">3364</TD><TD>                                        if (lubType == null) continue; // ignore</TD></TR><TR CLASS="z"><TD CLASS="l">3365</TD><TD>                                        if (lubType == type || lubType.isEquivalentTo(type)) continue nextTypeCheck; // type found, jump to next one</TD></TR><TR><TD CLASS="l">3366</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3367</TD><TD>                                continue nextLubCheck; // type not found in current lubTypes</TD></TR><TR><TD CLASS="l">3368</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3369</TD><TD>                        // all types are included in some lub, cycle detected - stop recursion by answering special value (int)</TD></TR><TR CLASS="z"><TD CLASS="l">3370</TD><TD>                        return TypeBinding.INT;</TD></TR><TR><TD CLASS="l">3371</TD><TD>                }</TD></TR><TR><TD CLASS="l">3372</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3373</TD><TD>                lubStack.add(types);</TD></TR><TR CLASS="z"><TD CLASS="l">3374</TD><TD>                Map invocations = new HashMap(1);</TD></TR><TR CLASS="z"><TD CLASS="l">3375</TD><TD>                TypeBinding[] mecs = minimalErasedCandidates(types, invocations);</TD></TR><TR CLASS="z"><TD CLASS="l">3376</TD><TD>                if (mecs == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">3377</TD><TD>                int length = mecs.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3378</TD><TD>                if (length == 0) return TypeBinding.VOID;</TD></TR><TR CLASS="z"><TD CLASS="l">3379</TD><TD>                int count = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3380</TD><TD>                TypeBinding firstBound = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3381</TD><TD>                int commonDim = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">3382</TD><TD>                for (int i = 0; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3383</TD><TD>                        TypeBinding mec = mecs[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3384</TD><TD>                        if (mec == null) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">3385</TD><TD>                        mec = leastContainingInvocation(mec, invocations.get(mec), lubStack);</TD></TR><TR CLASS="z"><TD CLASS="l">3386</TD><TD>                        if (mec == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">3387</TD><TD>                        int dim = mec.dimensions();</TD></TR><TR CLASS="z"><TD CLASS="l">3388</TD><TD>                        if (commonDim == -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">3389</TD><TD>                                commonDim = dim;</TD></TR><TR CLASS="z"><TD CLASS="l">3390</TD><TD>                        } else if (dim != commonDim) { // not all types have same dimension</TD></TR><TR CLASS="z"><TD CLASS="l">3391</TD><TD>                                return null;</TD></TR><TR><TD CLASS="l">3392</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3393</TD><TD>                        if (firstBound == null &amp;&amp; !mec.leafComponentType().isInterface()) firstBound = mec.leafComponentType();</TD></TR><TR CLASS="z"><TD CLASS="l">3394</TD><TD>                        mecs[count++] = mec; // recompact them to the front</TD></TR><TR><TD CLASS="l">3395</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3396</TD><TD>                switch (count) {</TD></TR><TR CLASS="z"><TD CLASS="l">3397</TD><TD>                        case 0 : return TypeBinding.VOID;</TD></TR><TR CLASS="z"><TD CLASS="l">3398</TD><TD>                        case 1 : return mecs[0];</TD></TR><TR><TD CLASS="l">3399</TD><TD>                        case 2 :</TD></TR><TR CLASS="z"><TD CLASS="l">3400</TD><TD>                                if ((commonDim == 0 ? mecs[1].id : mecs[1].leafComponentType().id) == T_JavaLangObject) return mecs[0];</TD></TR><TR CLASS="z"><TD CLASS="l">3401</TD><TD>                                if ((commonDim == 0 ? mecs[0].id : mecs[0].leafComponentType().id) == T_JavaLangObject) return mecs[1];</TD></TR><TR><TD CLASS="l">3402</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3403</TD><TD>                TypeBinding[] otherBounds = new TypeBinding[count - 1];</TD></TR><TR CLASS="z"><TD CLASS="l">3404</TD><TD>                int rank = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3405</TD><TD>                for (int i = 0; i &lt; count; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3406</TD><TD>                        TypeBinding mec = commonDim == 0 ? mecs[i] : mecs[i].leafComponentType();</TD></TR><TR CLASS="z"><TD CLASS="l">3407</TD><TD>                        if (mec.isInterface()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3408</TD><TD>                                otherBounds[rank++] = mec;</TD></TR><TR><TD CLASS="l">3409</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3410</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3411</TD><TD>                TypeBinding intersectionType = environment().createWildcard(null, 0, firstBound, otherBounds, Wildcard.EXTENDS);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="50">3412</A></TD><TD>                return commonDim == 0 ? intersectionType : environment().createArrayType(intersectionType, commonDim);</TD></TR><TR><TD CLASS="l">3413</TD><TD>        }</TD></TR><TR><TD CLASS="l">3414</TD><TD> </TD></TR><TR><TD CLASS="l">3415</TD><TD>        public MethodScope methodScope() {</TD></TR><TR CLASS="z"><TD CLASS="l">3416</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">3417</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">3418</TD><TD>                        if (scope instanceof MethodScope)</TD></TR><TR CLASS="z"><TD CLASS="l">3419</TD><TD>                                return (MethodScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">3420</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">3421</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l">3422</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">3423</TD><TD>        }</TD></TR><TR><TD CLASS="l">3424</TD><TD> </TD></TR><TR><TD CLASS="l">3425</TD><TD>        /**</TD></TR><TR><TD CLASS="l">3426</TD><TD>         * Returns the most specific set of types compatible with all given types.</TD></TR><TR><TD CLASS="l">3427</TD><TD>         * (i.e. most specific common super types)</TD></TR><TR><TD CLASS="l">3428</TD><TD>         * If no types is given, will return an empty array. If not compatible</TD></TR><TR><TD CLASS="l">3429</TD><TD>         * reference type is found, returns null. In other cases, will return an array</TD></TR><TR><TD CLASS="l"><A NAME="51">3430</A></TD><TD>         * of minimal erased types, where some nulls may appear (and must simply be</TD></TR><TR><TD CLASS="l">3431</TD><TD>         * ignored).</TD></TR><TR><TD CLASS="l">3432</TD><TD>         */</TD></TR><TR><TD CLASS="l">3433</TD><TD>        protected TypeBinding[] minimalErasedCandidates(TypeBinding[] types, Map allInvocations) {</TD></TR><TR CLASS="z"><TD CLASS="l">3434</TD><TD>                int length = types.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3435</TD><TD>                int indexOfFirst = -1, actualLength = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3436</TD><TD>                for (int i = 0; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3437</TD><TD>                        TypeBinding type = types[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3438</TD><TD>                        if (type == null) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">3439</TD><TD>                        if (type.isBaseType()) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">3440</TD><TD>                        if (indexOfFirst &lt; 0) indexOfFirst = i;</TD></TR><TR CLASS="z"><TD CLASS="l">3441</TD><TD>                        actualLength ++;</TD></TR><TR><TD CLASS="l">3442</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3443</TD><TD>                switch (actualLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">3444</TD><TD>                        case 0: return Binding.NO_TYPES;</TD></TR><TR CLASS="z"><TD CLASS="l">3445</TD><TD>                        case 1: return types;</TD></TR><TR><TD CLASS="l">3446</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3447</TD><TD>                TypeBinding firstType = types[indexOfFirst];</TD></TR><TR CLASS="z"><TD CLASS="l">3448</TD><TD>                if (firstType.isBaseType()) return null;</TD></TR><TR><TD CLASS="l">3449</TD><TD> </TD></TR><TR><TD CLASS="l">3450</TD><TD>                // record all supertypes of type</TD></TR><TR><TD CLASS="l">3451</TD><TD>                // intersect with all supertypes of otherType</TD></TR><TR CLASS="z"><TD CLASS="l">3452</TD><TD>                ArrayList typesToVisit = new ArrayList(5);</TD></TR><TR><TD CLASS="l">3453</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3454</TD><TD>                int dim = firstType.dimensions();</TD></TR><TR CLASS="z"><TD CLASS="l">3455</TD><TD>                TypeBinding leafType = firstType.leafComponentType();</TD></TR><TR CLASS="z"><TD CLASS="l">3456</TD><TD>                TypeBinding firstErasure = (leafType.isTypeVariable() || leafType.isWildcard()/*&amp;&amp; !leafType.isCapture()*/) ? firstType : firstType.erasure();</TD></TR><TR CLASS="z"><TD CLASS="l">3457</TD><TD>                if (firstErasure != firstType) {</TD></TR><TR CLASS="z"><TD CLASS="l">3458</TD><TD>                        allInvocations.put(firstErasure, firstType);</TD></TR><TR><TD CLASS="l">3459</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3460</TD><TD>                typesToVisit.add(firstType);</TD></TR><TR CLASS="z"><TD CLASS="l">3461</TD><TD>                int max = 1;</TD></TR><TR><TD CLASS="l">3462</TD><TD>                ReferenceBinding currentType;</TD></TR><TR CLASS="z"><TD CLASS="l">3463</TD><TD>                for (int i = 0; i &lt; max; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3464</TD><TD>                        TypeBinding typeToVisit = (TypeBinding) typesToVisit.get(i);</TD></TR><TR CLASS="z"><TD CLASS="l">3465</TD><TD>                        dim = typeToVisit.dimensions();</TD></TR><TR CLASS="z"><TD CLASS="l">3466</TD><TD>                        if (dim &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">3467</TD><TD>                                leafType = typeToVisit.leafComponentType();</TD></TR><TR CLASS="z"><TD CLASS="l">3468</TD><TD>                                switch(leafType.id) {</TD></TR><TR><TD CLASS="l">3469</TD><TD>                                        case T_JavaLangObject:</TD></TR><TR CLASS="z"><TD CLASS="l">3470</TD><TD>                                                if (dim &gt; 1) { // Object[][] supertype is Object[]</TD></TR><TR CLASS="z"><TD CLASS="l">3471</TD><TD>                                                        TypeBinding elementType = ((ArrayBinding)typeToVisit).elementsType();</TD></TR><TR CLASS="z"><TD CLASS="l">3472</TD><TD>                                                        if (!typesToVisit.contains(elementType)) {</TD></TR><TR CLASS="z"><TD CLASS="l">3473</TD><TD>                                                                typesToVisit.add(elementType);</TD></TR><TR CLASS="z"><TD CLASS="l">3474</TD><TD>                                                                max++;</TD></TR><TR><TD CLASS="l">3475</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3476</TD><TD>                                                        continue;</TD></TR><TR><TD CLASS="l">3477</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">3478</TD><TD>                                                // fallthrough</TD></TR><TR><TD CLASS="l">3479</TD><TD>                                        case T_byte:</TD></TR><TR><TD CLASS="l">3480</TD><TD>                                        case T_short:</TD></TR><TR><TD CLASS="l">3481</TD><TD>                                        case T_char:</TD></TR><TR><TD CLASS="l">3482</TD><TD>                                        case T_boolean:</TD></TR><TR><TD CLASS="l">3483</TD><TD>                                        case T_int:</TD></TR><TR><TD CLASS="l">3484</TD><TD>                                        case T_long:</TD></TR><TR><TD CLASS="l">3485</TD><TD>                                        case T_float:</TD></TR><TR><TD CLASS="l">3486</TD><TD>                                        case T_double:</TD></TR><TR CLASS="z"><TD CLASS="l">3487</TD><TD>                                                TypeBinding superType = getJavaIoSerializable();</TD></TR><TR CLASS="z"><TD CLASS="l">3488</TD><TD>                                                if (!typesToVisit.contains(superType)) {</TD></TR><TR CLASS="z"><TD CLASS="l">3489</TD><TD>                                                        typesToVisit.add(superType);</TD></TR><TR CLASS="z"><TD CLASS="l">3490</TD><TD>                                                        max++;</TD></TR><TR><TD CLASS="l">3491</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3492</TD><TD>                                                superType = getJavaLangCloneable();</TD></TR><TR CLASS="z"><TD CLASS="l">3493</TD><TD>                                                if (!typesToVisit.contains(superType)) {</TD></TR><TR CLASS="z"><TD CLASS="l">3494</TD><TD>                                                        typesToVisit.add(superType);</TD></TR><TR CLASS="z"><TD CLASS="l">3495</TD><TD>                                                        max++;</TD></TR><TR><TD CLASS="l">3496</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3497</TD><TD>                                                superType = getJavaLangObject();</TD></TR><TR CLASS="z"><TD CLASS="l">3498</TD><TD>                                                if (!typesToVisit.contains(superType)) {</TD></TR><TR CLASS="z"><TD CLASS="l">3499</TD><TD>                                                        typesToVisit.add(superType);</TD></TR><TR CLASS="z"><TD CLASS="l">3500</TD><TD>                                                        max++;</TD></TR><TR><TD CLASS="l">3501</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3502</TD><TD>                                                continue;</TD></TR><TR><TD CLASS="l">3503</TD><TD> </TD></TR><TR><TD CLASS="l">3504</TD><TD>                                        default:</TD></TR><TR><TD CLASS="l">3505</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3506</TD><TD>                                typeToVisit = leafType;</TD></TR><TR><TD CLASS="l">3507</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3508</TD><TD>                        currentType = (ReferenceBinding) typeToVisit;</TD></TR><TR CLASS="z"><TD CLASS="l">3509</TD><TD>                        if (currentType.isCapture()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3510</TD><TD>                                TypeBinding firstBound = ((CaptureBinding) currentType).firstBound;</TD></TR><TR CLASS="z"><TD CLASS="l">3511</TD><TD>                                if (firstBound != null &amp;&amp; firstBound.isArrayType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3512</TD><TD>                                        TypeBinding superType = dim == 0 ? firstBound : (TypeBinding)environment().createArrayType(firstBound, dim); // recreate array if needed</TD></TR><TR CLASS="z"><TD CLASS="l">3513</TD><TD>                                        if (!typesToVisit.contains(superType)) {</TD></TR><TR CLASS="z"><TD CLASS="l">3514</TD><TD>                                                typesToVisit.add(superType);</TD></TR><TR CLASS="z"><TD CLASS="l">3515</TD><TD>                                                max++;</TD></TR><TR CLASS="z"><TD CLASS="l">3516</TD><TD>                                                TypeBinding superTypeErasure = (firstBound.isTypeVariable() || firstBound.isWildcard() /*&amp;&amp; !itsInterface.isCapture()*/) ? superType : superType.erasure();</TD></TR><TR CLASS="z"><TD CLASS="l">3517</TD><TD>                                                if (superTypeErasure != superType) {</TD></TR><TR CLASS="z"><TD CLASS="l">3518</TD><TD>                                                        allInvocations.put(superTypeErasure, superType);</TD></TR><TR><TD CLASS="l">3519</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">3520</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3521</TD><TD>                                        continue;</TD></TR><TR><TD CLASS="l">3522</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3523</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3524</TD><TD>                        // inject super interfaces prior to superclass</TD></TR><TR CLASS="z"><TD CLASS="l">3525</TD><TD>                        ReferenceBinding[] itsInterfaces = currentType.superInterfaces();</TD></TR><TR CLASS="z"><TD CLASS="l">3526</TD><TD>                        if (itsInterfaces != null) { // can be null during code assist operations that use LookupEnvironment.completeTypeBindings(parsedUnit, buildFieldsAndMethods)</TD></TR><TR CLASS="z"><TD CLASS="l">3527</TD><TD>                                for (int j = 0, count = itsInterfaces.length; j &lt; count; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3528</TD><TD>                                        TypeBinding itsInterface = itsInterfaces[j];</TD></TR><TR CLASS="z"><TD CLASS="l">3529</TD><TD>                                        TypeBinding superType = dim == 0 ? itsInterface : (TypeBinding)environment().createArrayType(itsInterface, dim); // recreate array if needed</TD></TR><TR CLASS="z"><TD CLASS="l">3530</TD><TD>                                        if (!typesToVisit.contains(superType)) {</TD></TR><TR CLASS="z"><TD CLASS="l">3531</TD><TD>                                                typesToVisit.add(superType);</TD></TR><TR CLASS="z"><TD CLASS="l">3532</TD><TD>                                                max++;</TD></TR><TR CLASS="z"><TD CLASS="l">3533</TD><TD>                                                TypeBinding superTypeErasure = (itsInterface.isTypeVariable() || itsInterface.isWildcard() /*&amp;&amp; !itsInterface.isCapture()*/) ? superType : superType.erasure();</TD></TR><TR CLASS="z"><TD CLASS="l">3534</TD><TD>                                                if (superTypeErasure != superType) {</TD></TR><TR CLASS="z"><TD CLASS="l">3535</TD><TD>                                                        allInvocations.put(superTypeErasure, superType);</TD></TR><TR><TD CLASS="l">3536</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">3537</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3538</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3539</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3540</TD><TD>                        TypeBinding itsSuperclass = currentType.superclass();</TD></TR><TR CLASS="z"><TD CLASS="l">3541</TD><TD>                        if (itsSuperclass != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3542</TD><TD>                                TypeBinding superType = dim == 0 ? itsSuperclass : (TypeBinding)environment().createArrayType(itsSuperclass, dim); // recreate array if needed</TD></TR><TR CLASS="z"><TD CLASS="l">3543</TD><TD>                                if (!typesToVisit.contains(superType)) {</TD></TR><TR CLASS="z"><TD CLASS="l">3544</TD><TD>                                        typesToVisit.add(superType);</TD></TR><TR CLASS="z"><TD CLASS="l">3545</TD><TD>                                        max++;</TD></TR><TR CLASS="z"><TD CLASS="l">3546</TD><TD>                                        TypeBinding superTypeErasure = (itsSuperclass.isTypeVariable() || itsSuperclass.isWildcard() /*&amp;&amp; !itsSuperclass.isCapture()*/) ? superType : superType.erasure();</TD></TR><TR CLASS="z"><TD CLASS="l">3547</TD><TD>                                        if (superTypeErasure != superType) {</TD></TR><TR CLASS="z"><TD CLASS="l">3548</TD><TD>                                                allInvocations.put(superTypeErasure, superType);</TD></TR><TR><TD CLASS="l">3549</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3550</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3551</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3552</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3553</TD><TD>                int superLength = typesToVisit.size();</TD></TR><TR CLASS="z"><TD CLASS="l">3554</TD><TD>                TypeBinding[] erasedSuperTypes = new TypeBinding[superLength];</TD></TR><TR CLASS="z"><TD CLASS="l">3555</TD><TD>                int rank = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3556</TD><TD>                for (Iterator iter = typesToVisit.iterator(); iter.hasNext();) {</TD></TR><TR CLASS="z"><TD CLASS="l">3557</TD><TD>                        TypeBinding type = (TypeBinding)iter.next();</TD></TR><TR CLASS="z"><TD CLASS="l">3558</TD><TD>                        leafType = type.leafComponentType();</TD></TR><TR CLASS="z"><TD CLASS="l">3559</TD><TD>                        erasedSuperTypes[rank++] = (leafType.isTypeVariable() || leafType.isWildcard() /*&amp;&amp; !leafType.isCapture()*/) ? type : type.erasure();</TD></TR><TR><TD CLASS="l">3560</TD><TD>                }</TD></TR><TR><TD CLASS="l">3561</TD><TD>                // intersecting first type supertypes with other types' ones, nullifying non matching supertypes</TD></TR><TR CLASS="z"><TD CLASS="l">3562</TD><TD>                int remaining = superLength;</TD></TR><TR CLASS="z"><TD CLASS="l">3563</TD><TD>                nextOtherType: for (int i = indexOfFirst+1; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3564</TD><TD>                        TypeBinding otherType = types[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3565</TD><TD>                        if (otherType == null) continue nextOtherType;</TD></TR><TR CLASS="z"><TD CLASS="l">3566</TD><TD>                        if (otherType.isArrayType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3567</TD><TD>                                nextSuperType: for (int j = 0; j &lt; superLength; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3568</TD><TD>                                        TypeBinding erasedSuperType = erasedSuperTypes[j];</TD></TR><TR CLASS="z"><TD CLASS="l">3569</TD><TD>                                        if (erasedSuperType == null || erasedSuperType == otherType) continue nextSuperType;</TD></TR><TR><TD CLASS="l">3570</TD><TD>                                        TypeBinding match;</TD></TR><TR CLASS="z"><TD CLASS="l">3571</TD><TD>                                        if ((match = otherType.findSuperTypeWithSameErasure(erasedSuperType)) == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3572</TD><TD>                                                erasedSuperTypes[j] = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3573</TD><TD>                                                if (--remaining == 0) return null;</TD></TR><TR><TD CLASS="l">3574</TD><TD>                                                continue nextSuperType;</TD></TR><TR><TD CLASS="l">3575</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3576</TD><TD>                                        // record invocation</TD></TR><TR CLASS="z"><TD CLASS="l">3577</TD><TD>                                        Object invocationData = allInvocations.get(erasedSuperType);</TD></TR><TR CLASS="z"><TD CLASS="l">3578</TD><TD>                                        if (invocationData == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3579</TD><TD>                                                allInvocations.put(erasedSuperType, match); // no array for singleton</TD></TR><TR CLASS="z"><TD CLASS="l">3580</TD><TD>                                        } else if (invocationData instanceof TypeBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">3581</TD><TD>                                                if (match != invocationData) {</TD></TR><TR><TD CLASS="l">3582</TD><TD>                                                        // using an array to record invocations in order (188103)</TD></TR><TR CLASS="z"><TD CLASS="l">3583</TD><TD>                                                        TypeBinding[] someInvocations = { (TypeBinding) invocationData, match, };</TD></TR><TR CLASS="z"><TD CLASS="l">3584</TD><TD>                                                        allInvocations.put(erasedSuperType, someInvocations);</TD></TR><TR><TD CLASS="l">3585</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">3586</TD><TD>                                        } else { // using an array to record invocations in order (188103)</TD></TR><TR CLASS="z"><TD CLASS="l">3587</TD><TD>                                                TypeBinding[] someInvocations = (TypeBinding[]) invocationData;</TD></TR><TR><TD CLASS="l">3588</TD><TD>                                                checkExisting: {</TD></TR><TR CLASS="z"><TD CLASS="l">3589</TD><TD>                                                        int invocLength = someInvocations.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3590</TD><TD>                                                        for (int k = 0; k &lt; invocLength; k++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3591</TD><TD>                                                                if (someInvocations[k] == match) break checkExisting;</TD></TR><TR><TD CLASS="l">3592</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3593</TD><TD>                                                        System.arraycopy(someInvocations, 0, someInvocations = new TypeBinding[invocLength+1], 0, invocLength);</TD></TR><TR CLASS="z"><TD CLASS="l">3594</TD><TD>                                                        allInvocations.put(erasedSuperType, someInvocations);</TD></TR><TR CLASS="z"><TD CLASS="l">3595</TD><TD>                                                        someInvocations[invocLength] = match;</TD></TR><TR><TD CLASS="l">3596</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">3597</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3598</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3599</TD><TD>                                continue nextOtherType;</TD></TR><TR><TD CLASS="l">3600</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3601</TD><TD>                        nextSuperType: for (int j = 0; j &lt; superLength; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3602</TD><TD>                                TypeBinding erasedSuperType = erasedSuperTypes[j];</TD></TR><TR CLASS="z"><TD CLASS="l">3603</TD><TD>                                if (erasedSuperType == null) continue nextSuperType;</TD></TR><TR><TD CLASS="l">3604</TD><TD>                                TypeBinding match;</TD></TR><TR CLASS="z"><TD CLASS="l">3605</TD><TD>                                if (erasedSuperType == otherType || erasedSuperType.id == T_JavaLangObject &amp;&amp; otherType.isInterface()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3606</TD><TD>                                        match = erasedSuperType;</TD></TR><TR><TD CLASS="l">3607</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">3608</TD><TD>                                        if (erasedSuperType.isArrayType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3609</TD><TD>                                                match = null;</TD></TR><TR><TD CLASS="l">3610</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">3611</TD><TD>                                                match = otherType.findSuperTypeWithSameErasure(erasedSuperType);</TD></TR><TR><TD CLASS="l">3612</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3613</TD><TD>                                        if (match == null) { // incompatible super type</TD></TR><TR CLASS="z"><TD CLASS="l">3614</TD><TD>                                                erasedSuperTypes[j] = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3615</TD><TD>                                                if (--remaining == 0) return null;</TD></TR><TR><TD CLASS="l">3616</TD><TD>                                                continue nextSuperType;</TD></TR><TR><TD CLASS="l">3617</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3618</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3619</TD><TD>                                // record invocation</TD></TR><TR CLASS="z"><TD CLASS="l">3620</TD><TD>                                Object invocationData = allInvocations.get(erasedSuperType);</TD></TR><TR CLASS="z"><TD CLASS="l">3621</TD><TD>                                if (invocationData == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3622</TD><TD>                                        allInvocations.put(erasedSuperType, match); // no array for singleton</TD></TR><TR CLASS="z"><TD CLASS="l">3623</TD><TD>                                } else if (invocationData instanceof TypeBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">3624</TD><TD>                                        if (match != invocationData) {</TD></TR><TR><TD CLASS="l">3625</TD><TD>                                                // using an array to record invocations in order (188103)</TD></TR><TR CLASS="z"><TD CLASS="l">3626</TD><TD>                                                TypeBinding[] someInvocations = { (TypeBinding) invocationData, match, };</TD></TR><TR CLASS="z"><TD CLASS="l">3627</TD><TD>                                                allInvocations.put(erasedSuperType, someInvocations);</TD></TR><TR><TD CLASS="l">3628</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3629</TD><TD>                                } else { // using an array to record invocations in order (188103)</TD></TR><TR CLASS="z"><TD CLASS="l">3630</TD><TD>                                        TypeBinding[] someInvocations = (TypeBinding[]) invocationData;</TD></TR><TR><TD CLASS="l">3631</TD><TD>                                        checkExisting: {</TD></TR><TR CLASS="z"><TD CLASS="l">3632</TD><TD>                                                int invocLength = someInvocations.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3633</TD><TD>                                                for (int k = 0; k &lt; invocLength; k++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3634</TD><TD>                                                        if (someInvocations[k] == match) break checkExisting;</TD></TR><TR><TD CLASS="l">3635</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3636</TD><TD>                                                System.arraycopy(someInvocations, 0, someInvocations = new TypeBinding[invocLength+1], 0, invocLength);</TD></TR><TR CLASS="z"><TD CLASS="l">3637</TD><TD>                                                allInvocations.put(erasedSuperType, someInvocations);</TD></TR><TR CLASS="z"><TD CLASS="l">3638</TD><TD>                                                someInvocations[invocLength] = match;</TD></TR><TR><TD CLASS="l">3639</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3640</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3641</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3642</TD><TD>                }</TD></TR><TR><TD CLASS="l">3643</TD><TD>                // eliminate non minimal super types</TD></TR><TR CLASS="z"><TD CLASS="l">3644</TD><TD>                if (remaining &gt; 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">3645</TD><TD>                        nextType: for (int i = 0; i &lt; superLength; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3646</TD><TD>                                TypeBinding erasedSuperType = erasedSuperTypes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3647</TD><TD>                                if (erasedSuperType == null) continue nextType;</TD></TR><TR CLASS="z"><TD CLASS="l">3648</TD><TD>                                nextOtherType: for (int j = 0; j &lt; superLength; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3649</TD><TD>                                        if (i == j) continue nextOtherType;</TD></TR><TR CLASS="z"><TD CLASS="l">3650</TD><TD>                                        TypeBinding otherType = erasedSuperTypes[j];</TD></TR><TR CLASS="z"><TD CLASS="l">3651</TD><TD>                                        if (otherType == null) continue nextOtherType;</TD></TR><TR CLASS="z"><TD CLASS="l">3652</TD><TD>                                        if (erasedSuperType instanceof ReferenceBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">3653</TD><TD>                                                if (otherType.id == T_JavaLangObject &amp;&amp; erasedSuperType.isInterface()) continue nextOtherType; // keep Object for an interface</TD></TR><TR CLASS="z"><TD CLASS="l">3654</TD><TD>                                                if (erasedSuperType.findSuperTypeWithSameErasure(otherType) != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3655</TD><TD>                                                        erasedSuperTypes[j] = null; // discard non minimal supertype</TD></TR><TR CLASS="z"><TD CLASS="l">3656</TD><TD>                                                        remaining--;</TD></TR><TR><TD CLASS="l">3657</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3658</TD><TD>                                        } else if (erasedSuperType.isArrayType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3659</TD><TD>                                        if (otherType.isArrayType() // keep Object[...] for an interface array (same dimensions)</TD></TR><TR CLASS="z"><TD CLASS="l">3660</TD><TD>                                                        &amp;&amp; otherType.leafComponentType().id == T_JavaLangObject</TD></TR><TR CLASS="z"><TD CLASS="l">3661</TD><TD>                                                        &amp;&amp; otherType.dimensions() == erasedSuperType.dimensions()</TD></TR><TR CLASS="z"><TD CLASS="l">3662</TD><TD>                                                        &amp;&amp; erasedSuperType.leafComponentType().isInterface()) continue nextOtherType;</TD></TR><TR CLASS="z"><TD CLASS="l">3663</TD><TD>                                                if (erasedSuperType.findSuperTypeWithSameErasure(otherType) != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3664</TD><TD>                                                        erasedSuperTypes[j] = null; // discard non minimal supertype</TD></TR><TR CLASS="z"><TD CLASS="l">3665</TD><TD>                                                        remaining--;</TD></TR><TR><TD CLASS="l">3666</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">3667</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3668</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3669</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3670</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3671</TD><TD>                return erasedSuperTypes;</TD></TR><TR><TD CLASS="l">3672</TD><TD>        }</TD></TR><TR><TD CLASS="l">3673</TD><TD> </TD></TR><TR><TD CLASS="l">3674</TD><TD> </TD></TR><TR><TD CLASS="l">3675</TD><TD>        // Internal use only</TD></TR><TR><TD CLASS="l">3676</TD><TD>        /* All methods in visible are acceptable matches for the method in question...</TD></TR><TR><TD CLASS="l">3677</TD><TD>        * The methods defined by the receiver type appear before those defined by its</TD></TR><TR><TD CLASS="l">3678</TD><TD>        * superclass and so on. We want to find the one which matches best.</TD></TR><TR><TD CLASS="l">3679</TD><TD>        *</TD></TR><TR><TD CLASS="l">3680</TD><TD>        * Since the receiver type is a class, we know each method's declaring class is</TD></TR><TR><TD CLASS="l">3681</TD><TD>        * either the receiver type or one of its superclasses. It is an error if the best match</TD></TR><TR><TD CLASS="l"><A NAME="52">3682</A></TD><TD>        * is defined by a superclass, when a lesser match is defined by the receiver type</TD></TR><TR><TD CLASS="l">3683</TD><TD>        * or a closer superclass.</TD></TR><TR><TD CLASS="l">3684</TD><TD>        */</TD></TR><TR><TD CLASS="l">3685</TD><TD>        protected final MethodBinding mostSpecificClassMethodBinding(MethodBinding[] visible, int visibleSize, InvocationSite invocationSite) {</TD></TR><TR CLASS="z"><TD CLASS="l">3686</TD><TD>                MethodBinding previous = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3687</TD><TD>                nextVisible : for (int i = 0; i &lt; visibleSize; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3688</TD><TD>                        MethodBinding method = visible[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3689</TD><TD>                        if (previous != null &amp;&amp; method.declaringClass != previous.declaringClass)</TD></TR><TR CLASS="z"><TD CLASS="l">3690</TD><TD>                                break; // cannot answer a method farther up the hierarchy than the first method found</TD></TR><TR><TD CLASS="l">3691</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3692</TD><TD>                        if (!method.isStatic()) previous = method; // no ambiguity for static methods</TD></TR><TR CLASS="z"><TD CLASS="l">3693</TD><TD>                        for (int j = 0; j &lt; visibleSize; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3694</TD><TD>                                if (i == j) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">3695</TD><TD>                                if (!visible[j].areParametersCompatibleWith(method.parameters))</TD></TR><TR CLASS="z"><TD CLASS="l">3696</TD><TD>                                        continue nextVisible;</TD></TR><TR><TD CLASS="l">3697</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3698</TD><TD>                        compilationUnitScope().recordTypeReferences(method.thrownExceptions);</TD></TR><TR CLASS="z"><TD CLASS="l">3699</TD><TD>                        return method;</TD></TR><TR><TD CLASS="l">3700</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3701</TD><TD>                        return new ProblemMethodBinding(visible[0], visible[0].selector, visible[0].parameters, ProblemReasons.Ambiguous);</TD></TR><TR><TD CLASS="l">3702</TD><TD>        }</TD></TR><TR><TD CLASS="l">3703</TD><TD> </TD></TR><TR><TD CLASS="l">3704</TD><TD>        // Internal use only</TD></TR><TR><TD CLASS="l">3705</TD><TD>        /* All methods in visible are acceptable matches for the method in question...</TD></TR><TR><TD CLASS="l">3706</TD><TD>        * Since the receiver type is an interface, we ignore the possibility that 2 inherited</TD></TR><TR><TD CLASS="l">3707</TD><TD>        * but unrelated superinterfaces may define the same method in acceptable but</TD></TR><TR><TD CLASS="l">3708</TD><TD>        * not identical ways... we just take the best match that we find since any class which</TD></TR><TR><TD CLASS="l">3709</TD><TD>        * implements the receiver interface MUST implement all signatures for the method...</TD></TR><TR><TD CLASS="l">3710</TD><TD>        * in which case the best match is correct.</TD></TR><TR><TD CLASS="l">3711</TD><TD>        *</TD></TR><TR><TD CLASS="l">3712</TD><TD>        * NOTE: This is different than javac... in the following example, the message send of</TD></TR><TR><TD CLASS="l">3713</TD><TD>        * bar(X) in class Y is supposed to be ambiguous. But any class which implements the</TD></TR><TR><TD CLASS="l">3714</TD><TD>        * interface I MUST implement both signatures for bar. If this class was the receiver of</TD></TR><TR><TD CLASS="l">3715</TD><TD>        * the message send instead of the interface I, then no problem would be reported.</TD></TR><TR><TD CLASS="l">3716</TD><TD>        *</TD></TR><TR><TD CLASS="l">3717</TD><TD>        interface I1 {</TD></TR><TR><TD CLASS="l">3718</TD><TD>                void bar(J j);</TD></TR><TR><TD CLASS="l">3719</TD><TD>        }</TD></TR><TR><TD CLASS="l">3720</TD><TD>        interface I2 {</TD></TR><TR><TD CLASS="l">3721</TD><TD>        //        void bar(J j);</TD></TR><TR><TD CLASS="l">3722</TD><TD>                void bar(Object o);</TD></TR><TR><TD CLASS="l">3723</TD><TD>        }</TD></TR><TR><TD CLASS="l">3724</TD><TD>        interface I extends I1, I2 {}</TD></TR><TR><TD CLASS="l">3725</TD><TD>        interface J {}</TD></TR><TR><TD CLASS="l">3726</TD><TD> </TD></TR><TR><TD CLASS="l">3727</TD><TD>        class X implements J {}</TD></TR><TR><TD CLASS="l">3728</TD><TD> </TD></TR><TR><TD CLASS="l">3729</TD><TD>        class Y extends X {</TD></TR><TR><TD CLASS="l"><A NAME="53">3730</A></TD><TD>                public void foo(I i, X x) { i.bar(x); }</TD></TR><TR><TD CLASS="l">3731</TD><TD>        }</TD></TR><TR><TD CLASS="l">3732</TD><TD>        */</TD></TR><TR><TD CLASS="l">3733</TD><TD>        protected final MethodBinding mostSpecificInterfaceMethodBinding(MethodBinding[] visible, int visibleSize, InvocationSite invocationSite) {</TD></TR><TR CLASS="z"><TD CLASS="l">3734</TD><TD>                nextVisible : for (int i = 0; i &lt; visibleSize; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3735</TD><TD>                        MethodBinding method = visible[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3736</TD><TD>                        for (int j = 0; j &lt; visibleSize; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3737</TD><TD>                                if (i == j) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">3738</TD><TD>                                if (!visible[j].areParametersCompatibleWith(method.parameters))</TD></TR><TR CLASS="z"><TD CLASS="l">3739</TD><TD>                                        continue nextVisible;</TD></TR><TR><TD CLASS="l">3740</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3741</TD><TD>                        compilationUnitScope().recordTypeReferences(method.thrownExceptions);</TD></TR><TR CLASS="z"><TD CLASS="l">3742</TD><TD>                        return method;</TD></TR><TR><TD CLASS="l">3743</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3744</TD><TD>                        return new ProblemMethodBinding(visible[0], visible[0].selector, visible[0].parameters, ProblemReasons.Ambiguous);</TD></TR><TR><TD CLASS="l"><A NAME="54">3745</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">3746</TD><TD> </TD></TR><TR><TD CLASS="l">3747</TD><TD>        // caveat: this is not a direct implementation of JLS</TD></TR><TR><TD CLASS="l">3748</TD><TD>        protected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType) {</TD></TR><TR CLASS="z"><TD CLASS="l">3749</TD><TD>                int[] compatibilityLevels = new int[visibleSize];</TD></TR><TR CLASS="z"><TD CLASS="l">3750</TD><TD>                for (int i = 0; i &lt; visibleSize; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">3751</TD><TD>                        compatibilityLevels[i] = parameterCompatibilityLevel(visible[i], argumentTypes);</TD></TR><TR><TD CLASS="l">3752</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3753</TD><TD>                boolean useTiebreakMethod = invocationSite.genericTypeArguments() == null;</TD></TR><TR CLASS="z"><TD CLASS="l">3754</TD><TD>                MethodBinding[] moreSpecific = new MethodBinding[visibleSize];</TD></TR><TR CLASS="z"><TD CLASS="l">3755</TD><TD>                int count = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">3756</TD><TD>                for (int level = 0, max = VARARGS_COMPATIBLE; level &lt;= max; level++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3757</TD><TD>                        nextVisible : for (int i = 0; i &lt; visibleSize; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3758</TD><TD>                                if (compatibilityLevels[i] != level) continue nextVisible;</TD></TR><TR CLASS="z"><TD CLASS="l">3759</TD><TD>                                max = level; // do not examine further categories, will either return mostSpecific or report ambiguous case</TD></TR><TR CLASS="z"><TD CLASS="l">3760</TD><TD>                                MethodBinding current = visible[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3761</TD><TD>                                MethodBinding original = current.original();</TD></TR><TR CLASS="z"><TD CLASS="l">3762</TD><TD>                                MethodBinding tiebreakMethod = useTiebreakMethod ? current.tiebreakMethod() : current;</TD></TR><TR CLASS="z"><TD CLASS="l">3763</TD><TD>                                for (int j = 0; j &lt; visibleSize; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3764</TD><TD>                                        if (i == j || compatibilityLevels[j] != level) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">3765</TD><TD>                                        MethodBinding next = visible[j];</TD></TR><TR CLASS="z"><TD CLASS="l">3766</TD><TD>                                        if (original == next.original()) {</TD></TR><TR><TD CLASS="l">3767</TD><TD>                                                // parameterized superclasses &amp; interfaces may be walked twice from different paths so skip next from now on</TD></TR><TR CLASS="z"><TD CLASS="l">3768</TD><TD>                                                compatibilityLevels[j] = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">3769</TD><TD>                                                continue;</TD></TR><TR><TD CLASS="l">3770</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3771</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3772</TD><TD>                                        MethodBinding methodToTest = next;</TD></TR><TR CLASS="z"><TD CLASS="l">3773</TD><TD>                                        if (next instanceof ParameterizedGenericMethodBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">3774</TD><TD>                                                ParameterizedGenericMethodBinding pNext = (ParameterizedGenericMethodBinding) next;</TD></TR><TR CLASS="z"><TD CLASS="l">3775</TD><TD>                                                if (pNext.isRaw &amp;&amp; !pNext.isStatic()) {</TD></TR><TR><TD CLASS="l">3776</TD><TD>                                                        // hold onto the raw substituted method</TD></TR><TR><TD CLASS="l">3777</TD><TD>                                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">3778</TD><TD>                                                        methodToTest = pNext.originalMethod;</TD></TR><TR><TD CLASS="l">3779</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">3780</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3781</TD><TD>                                        MethodBinding acceptable = computeCompatibleMethod(methodToTest, tiebreakMethod.parameters, invocationSite);</TD></TR><TR><TD CLASS="l">3782</TD><TD>                                        /* There are 4 choices to consider with current &amp; next :</TD></TR><TR><TD CLASS="l">3783</TD><TD>                                         foo(B) &amp; foo(A) where B extends A</TD></TR><TR><TD CLASS="l">3784</TD><TD>                                         1. the 2 methods are equal (both accept each others parameters) -&gt; want to continue</TD></TR><TR><TD CLASS="l">3785</TD><TD>                                         2. current has more specific parameters than next (so acceptable is a valid method) -&gt; want to continue</TD></TR><TR><TD CLASS="l">3786</TD><TD>                                         3. current has less specific parameters than next (so acceptable is null) -&gt; go on to next</TD></TR><TR><TD CLASS="l">3787</TD><TD>                                         4. current and next are not compatible with each other (so acceptable is null) -&gt; go on to next</TD></TR><TR><TD CLASS="l">3788</TD><TD>                                         */</TD></TR><TR CLASS="z"><TD CLASS="l">3789</TD><TD>                                        if (acceptable == null || !acceptable.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">3790</TD><TD>                                                continue nextVisible;</TD></TR><TR CLASS="z"><TD CLASS="l">3791</TD><TD>                                        if (!isAcceptableMethod(tiebreakMethod, acceptable))</TD></TR><TR CLASS="z"><TD CLASS="l">3792</TD><TD>                                                continue nextVisible;</TD></TR><TR><TD CLASS="l">3793</TD><TD>                                        // pick a concrete method over a bridge method when parameters are equal since the return type of the concrete method is more specific</TD></TR><TR CLASS="z"><TD CLASS="l">3794</TD><TD>                                        if (current.isBridge() &amp;&amp; !next.isBridge())</TD></TR><TR CLASS="z"><TD CLASS="l">3795</TD><TD>                                                if (tiebreakMethod.areParametersEqual(acceptable))</TD></TR><TR CLASS="z"><TD CLASS="l">3796</TD><TD>                                                        continue nextVisible; // skip current so acceptable wins over this bridge method</TD></TR><TR><TD CLASS="l">3797</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3798</TD><TD>                                moreSpecific[i] = current;</TD></TR><TR CLASS="z"><TD CLASS="l">3799</TD><TD>                                count++;</TD></TR><TR><TD CLASS="l">3800</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3801</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">3802</TD><TD>                if (count == 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">3803</TD><TD>                        for (int i = 0; i &lt; visibleSize; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3804</TD><TD>                                if (moreSpecific[i] != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3805</TD><TD>                                        compilationUnitScope().recordTypeReferences(visible[i].thrownExceptions);</TD></TR><TR CLASS="z"><TD CLASS="l">3806</TD><TD>                                        return visible[i];</TD></TR><TR><TD CLASS="l">3807</TD><TD>                                }</TD></TR><TR><TD CLASS="l">3808</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3809</TD><TD>                } else if (count == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">3810</TD><TD>                        return new ProblemMethodBinding(visible[0], visible[0].selector, visible[0].parameters, ProblemReasons.Ambiguous);</TD></TR><TR><TD CLASS="l">3811</TD><TD>                }</TD></TR><TR><TD CLASS="l">3812</TD><TD> </TD></TR><TR><TD CLASS="l">3813</TD><TD>                // found several methods that are mutually acceptable -&gt; must be equal</TD></TR><TR><TD CLASS="l">3814</TD><TD>                // so now with the first acceptable method, find the 'correct' inherited method for each other acceptable method AND</TD></TR><TR><TD CLASS="l">3815</TD><TD>                // see if they are equal after substitution of type variables (do the type variables have to be equal to be considered an override???)</TD></TR><TR CLASS="z"><TD CLASS="l">3816</TD><TD>                if (receiverType != null)</TD></TR><TR CLASS="z"><TD CLASS="l">3817</TD><TD>                        receiverType = receiverType instanceof CaptureBinding ? receiverType : (ReferenceBinding) receiverType.erasure();</TD></TR><TR CLASS="z"><TD CLASS="l">3818</TD><TD>                nextSpecific : for (int i = 0; i &lt; visibleSize; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3819</TD><TD>                        MethodBinding current = moreSpecific[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3820</TD><TD>                        if (current != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3821</TD><TD>                                ReferenceBinding[] mostSpecificExceptions = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3822</TD><TD>                                SimpleSet possibleMethods = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3823</TD><TD>                                MethodBinding original = current.original();</TD></TR><TR CLASS="z"><TD CLASS="l">3824</TD><TD>                                for (int j = 0; j &lt; visibleSize; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3825</TD><TD>                                        MethodBinding next = moreSpecific[j];</TD></TR><TR CLASS="z"><TD CLASS="l">3826</TD><TD>                                        if (next == null || i == j) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">3827</TD><TD>                                        MethodBinding original2 = next.original();</TD></TR><TR CLASS="z"><TD CLASS="l">3828</TD><TD>                                        if (original.declaringClass == original2.declaringClass)</TD></TR><TR CLASS="z"><TD CLASS="l">3829</TD><TD>                                                break nextSpecific; // duplicates thru substitution</TD></TR><TR><TD CLASS="l">3830</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3831</TD><TD>                                        if (!original.isAbstract()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3832</TD><TD>                                                if (original2.isAbstract())</TD></TR><TR CLASS="z"><TD CLASS="l">3833</TD><TD>                                                        continue; // only compare current against other concrete methods</TD></TR><TR CLASS="z"><TD CLASS="l">3834</TD><TD>                                                TypeBinding superType = original.declaringClass.findSuperTypeWithSameErasure(original2.declaringClass.erasure());</TD></TR><TR CLASS="z"><TD CLASS="l">3835</TD><TD>                                                if (superType == null)</TD></TR><TR CLASS="z"><TD CLASS="l">3836</TD><TD>                                                        continue nextSpecific; // current's declaringClass is not a subtype of next's declaringClass</TD></TR><TR CLASS="z"><TD CLASS="l">3837</TD><TD>                                                if (current.hasSubstitutedParameters() || original.typeVariables != Binding.NO_TYPE_VARIABLES) {</TD></TR><TR CLASS="z"><TD CLASS="l">3838</TD><TD>                                                        if (original2.declaringClass != superType) {</TD></TR><TR><TD CLASS="l">3839</TD><TD>                                                                // must find inherited method with the same substituted variables</TD></TR><TR CLASS="z"><TD CLASS="l">3840</TD><TD>                                                                MethodBinding[] superMethods = ((ReferenceBinding) superType).getMethods(original2.selector);</TD></TR><TR CLASS="z"><TD CLASS="l">3841</TD><TD>                                                                for (int m = 0, l = superMethods.length; m &lt; l; m++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3842</TD><TD>                                                                        if (superMethods[m].original() == original2) {</TD></TR><TR CLASS="z"><TD CLASS="l">3843</TD><TD>                                                                                original2 = superMethods[m];</TD></TR><TR CLASS="z"><TD CLASS="l">3844</TD><TD>                                                                                break;</TD></TR><TR><TD CLASS="l">3845</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">3846</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">3847</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3848</TD><TD>                                                        if (original.typeVariables != Binding.NO_TYPE_VARIABLES)</TD></TR><TR CLASS="z"><TD CLASS="l">3849</TD><TD>                                                                original2 = original.computeSubstitutedMethod(original2, environment());</TD></TR><TR CLASS="z"><TD CLASS="l">3850</TD><TD>                                                        if (original2 == null || !original.areParametersEqual(original2))</TD></TR><TR CLASS="z"><TD CLASS="l">3851</TD><TD>                                                                continue nextSpecific; // current does not override next</TD></TR><TR><TD CLASS="l">3852</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3853</TD><TD>                                        } else if (receiverType != null) { // should not be null if original isAbstract, but be safe</TD></TR><TR CLASS="z"><TD CLASS="l">3854</TD><TD>                                                TypeBinding superType = receiverType.findSuperTypeWithSameErasure(original.declaringClass.erasure());</TD></TR><TR CLASS="z"><TD CLASS="l">3855</TD><TD>                                                if (original.declaringClass == superType || !(superType instanceof ReferenceBinding)) {</TD></TR><TR><TD CLASS="l">3856</TD><TD>                                                        // keep original</TD></TR><TR><TD CLASS="l">3857</TD><TD>                                                } else {</TD></TR><TR><TD CLASS="l">3858</TD><TD>                                                        // must find inherited method with the same substituted variables</TD></TR><TR CLASS="z"><TD CLASS="l">3859</TD><TD>                                                        MethodBinding[] superMethods = ((ReferenceBinding) superType).getMethods(original.selector);</TD></TR><TR CLASS="z"><TD CLASS="l">3860</TD><TD>                                                        for (int m = 0, l = superMethods.length; m &lt; l; m++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3861</TD><TD>                                                                if (superMethods[m].original() == original) {</TD></TR><TR CLASS="z"><TD CLASS="l">3862</TD><TD>                                                                        original = superMethods[m];</TD></TR><TR CLASS="z"><TD CLASS="l">3863</TD><TD>                                                                        break;</TD></TR><TR><TD CLASS="l">3864</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">3865</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">3866</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3867</TD><TD>                                                superType = receiverType.findSuperTypeWithSameErasure(original2.declaringClass.erasure());</TD></TR><TR CLASS="z"><TD CLASS="l">3868</TD><TD>                                                if (original2.declaringClass == superType || !(superType instanceof ReferenceBinding)) {</TD></TR><TR><TD CLASS="l">3869</TD><TD>                                                        // keep original2</TD></TR><TR><TD CLASS="l">3870</TD><TD>                                                } else {</TD></TR><TR><TD CLASS="l">3871</TD><TD>                                                        // must find inherited method with the same substituted variables</TD></TR><TR CLASS="z"><TD CLASS="l">3872</TD><TD>                                                        MethodBinding[] superMethods = ((ReferenceBinding) superType).getMethods(original2.selector);</TD></TR><TR CLASS="z"><TD CLASS="l">3873</TD><TD>                                                        for (int m = 0, l = superMethods.length; m &lt; l; m++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3874</TD><TD>                                                                if (superMethods[m].original() == original2) {</TD></TR><TR CLASS="z"><TD CLASS="l">3875</TD><TD>                                                                        original2 = superMethods[m];</TD></TR><TR CLASS="z"><TD CLASS="l">3876</TD><TD>                                                                        break;</TD></TR><TR><TD CLASS="l">3877</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">3878</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">3879</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3880</TD><TD>                                                if (original.typeVariables != Binding.NO_TYPE_VARIABLES)</TD></TR><TR CLASS="z"><TD CLASS="l">3881</TD><TD>                                                        original2 = original.computeSubstitutedMethod(original2, environment());</TD></TR><TR CLASS="z"><TD CLASS="l">3882</TD><TD>                                                if (original2 == null || !original.areParameterErasuresEqual(original2))</TD></TR><TR CLASS="z"><TD CLASS="l">3883</TD><TD>                                                        continue nextSpecific; // current does not override next</TD></TR><TR CLASS="z"><TD CLASS="l">3884</TD><TD>                                                if (!original.returnType.isCompatibleWith(original2.returnType) &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">3885</TD><TD>                                                                !original.returnType.erasure().isCompatibleWith(original2.returnType.erasure())) {</TD></TR><TR><TD CLASS="l">3886</TD><TD>                                                        // 15.12.2</TD></TR><TR CLASS="z"><TD CLASS="l">3887</TD><TD>                                                        continue nextSpecific; // choose original2 instead</TD></TR><TR><TD CLASS="l">3888</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3889</TD><TD>                                                if (original.thrownExceptions != original2.thrownExceptions) {</TD></TR><TR CLASS="z"><TD CLASS="l">3890</TD><TD>                                                        if (mostSpecificExceptions == null)</TD></TR><TR CLASS="z"><TD CLASS="l">3891</TD><TD>                                                                mostSpecificExceptions = original.thrownExceptions;</TD></TR><TR CLASS="z"><TD CLASS="l">3892</TD><TD>                                                        if (possibleMethods == null)</TD></TR><TR CLASS="z"><TD CLASS="l">3893</TD><TD>                                                                possibleMethods = new SimpleSet(3);</TD></TR><TR CLASS="z"><TD CLASS="l">3894</TD><TD>                                                        int mostSpecificLength = mostSpecificExceptions.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3895</TD><TD>                                                        int original2Length = original2.thrownExceptions.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3896</TD><TD>                                                        SimpleSet temp = new SimpleSet(mostSpecificLength);</TD></TR><TR CLASS="z"><TD CLASS="l">3897</TD><TD>                                                        nextException : for (int t = 0; t &lt; mostSpecificLength; t++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3898</TD><TD>                                                                ReferenceBinding exception = mostSpecificExceptions[t];</TD></TR><TR CLASS="z"><TD CLASS="l">3899</TD><TD>                                                                for (int s = 0; s &lt; original2Length; s++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3900</TD><TD>                                                                        if (exception.isCompatibleWith(original2.thrownExceptions[s])) {</TD></TR><TR CLASS="z"><TD CLASS="l">3901</TD><TD>                                                                                possibleMethods.add(current);</TD></TR><TR CLASS="z"><TD CLASS="l">3902</TD><TD>                                                                                temp.add(exception);</TD></TR><TR CLASS="z"><TD CLASS="l">3903</TD><TD>                                                                                continue nextException;</TD></TR><TR CLASS="z"><TD CLASS="l">3904</TD><TD>                                                                        } else if (original2.thrownExceptions[s].isCompatibleWith(exception)) {</TD></TR><TR CLASS="z"><TD CLASS="l">3905</TD><TD>                                                                                possibleMethods.add(next);</TD></TR><TR CLASS="z"><TD CLASS="l">3906</TD><TD>                                                                                temp.add(original2.thrownExceptions[s]);</TD></TR><TR CLASS="z"><TD CLASS="l">3907</TD><TD>                                                                                continue nextException;</TD></TR><TR><TD CLASS="l">3908</TD><TD>                                                                        }</TD></TR><TR><TD CLASS="l">3909</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">3910</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3911</TD><TD>                                                        mostSpecificExceptions = temp.elementSize == 0 ? Binding.NO_EXCEPTIONS : new ReferenceBinding[temp.elementSize];</TD></TR><TR CLASS="z"><TD CLASS="l">3912</TD><TD>                                                        temp.asArray(mostSpecificExceptions);</TD></TR><TR><TD CLASS="l">3913</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">3914</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3915</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3916</TD><TD>                                if (mostSpecificExceptions != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">3917</TD><TD>                                        Object[] values = possibleMethods.values;</TD></TR><TR CLASS="z"><TD CLASS="l">3918</TD><TD>                                        int exceptionLength = mostSpecificExceptions.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3919</TD><TD>                                        nextMethod : for (int p = 0, vLength = values.length; p &lt; vLength; p++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3920</TD><TD>                                                MethodBinding possible = (MethodBinding) values[p];</TD></TR><TR CLASS="z"><TD CLASS="l">3921</TD><TD>                                                if (possible == null) continue nextMethod;</TD></TR><TR CLASS="z"><TD CLASS="l">3922</TD><TD>                                                ReferenceBinding[] itsExceptions = possible.thrownExceptions;</TD></TR><TR CLASS="z"><TD CLASS="l">3923</TD><TD>                                                if (itsExceptions.length == exceptionLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">3924</TD><TD>                                                        nextException : for (int e = 0; e &lt; exceptionLength; e++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3925</TD><TD>                                                                ReferenceBinding exception = itsExceptions[e];</TD></TR><TR CLASS="z"><TD CLASS="l">3926</TD><TD>                                                                for (int f = 0; f &lt; exceptionLength; f++)</TD></TR><TR CLASS="z"><TD CLASS="l">3927</TD><TD>                                                                        if (exception == mostSpecificExceptions[f]) continue nextException;</TD></TR><TR CLASS="z"><TD CLASS="l">3928</TD><TD>                                                                continue nextMethod;</TD></TR><TR><TD CLASS="l">3929</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3930</TD><TD>                                                        return possible;</TD></TR><TR><TD CLASS="l">3931</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">3932</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">3933</TD><TD>// do not return a new methodBinding until we know that it does not cause problems</TD></TR><TR><TD CLASS="l">3934</TD><TD>//                                        return new FunctionBinding(</TD></TR><TR><TD CLASS="l">3935</TD><TD>//                                                current.modifiers,</TD></TR><TR><TD CLASS="l">3936</TD><TD>//                                                current.selector,</TD></TR><TR><TD CLASS="l">3937</TD><TD>//                                                current.returnType,</TD></TR><TR><TD CLASS="l">3938</TD><TD>//                                                current.parameters,</TD></TR><TR><TD CLASS="l">3939</TD><TD>//                                                mostSpecificExceptions,</TD></TR><TR><TD CLASS="l">3940</TD><TD>//                                                current.declaringClass</TD></TR><TR><TD CLASS="l">3941</TD><TD>//                                        );</TD></TR><TR><TD CLASS="l">3942</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">3943</TD><TD>                                return current;</TD></TR><TR><TD CLASS="l">3944</TD><TD>                        }</TD></TR><TR><TD CLASS="l">3945</TD><TD>                }</TD></TR><TR><TD CLASS="l">3946</TD><TD> </TD></TR><TR><TD CLASS="l">3947</TD><TD>                // if all moreSpecific methods are equal then see if duplicates exist because of substitution</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="55">3948</A></TD><TD>                return new ProblemMethodBinding(visible[0], visible[0].selector, visible[0].parameters, ProblemReasons.Ambiguous);</TD></TR><TR><TD CLASS="l">3949</TD><TD>        }</TD></TR><TR><TD CLASS="l">3950</TD><TD> </TD></TR><TR><TD CLASS="l">3951</TD><TD>        public final ClassScope outerMostClassScope() {</TD></TR><TR CLASS="z"><TD CLASS="l">3952</TD><TD>                ClassScope lastClassScope = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3953</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">3954</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">3955</TD><TD>                        if (scope instanceof ClassScope)</TD></TR><TR CLASS="z"><TD CLASS="l">3956</TD><TD>                                lastClassScope = (ClassScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">3957</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">3958</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="56">3959</A></TD><TD>                return lastClassScope; // may answer null if no class around</TD></TR><TR><TD CLASS="l">3960</TD><TD>        }</TD></TR><TR><TD CLASS="l">3961</TD><TD> </TD></TR><TR><TD CLASS="l">3962</TD><TD>        public final MethodScope outerMostMethodScope() {</TD></TR><TR CLASS="z"><TD CLASS="l">3963</TD><TD>                MethodScope lastMethodScope = null;</TD></TR><TR CLASS="z"><TD CLASS="l">3964</TD><TD>                Scope scope = this;</TD></TR><TR><TD CLASS="l">3965</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">3966</TD><TD>                        if (scope instanceof MethodScope)</TD></TR><TR CLASS="z"><TD CLASS="l">3967</TD><TD>                                lastMethodScope = (MethodScope) scope;</TD></TR><TR CLASS="z"><TD CLASS="l">3968</TD><TD>                        scope = scope.parent;</TD></TR><TR CLASS="z"><TD CLASS="l">3969</TD><TD>                } while (scope != null);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="57">3970</A></TD><TD>                return lastMethodScope; // may answer null if no method around</TD></TR><TR><TD CLASS="l">3971</TD><TD>        }</TD></TR><TR><TD CLASS="l">3972</TD><TD> </TD></TR><TR><TD CLASS="l">3973</TD><TD>        public int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments) {</TD></TR><TR CLASS="z"><TD CLASS="l">3974</TD><TD>                TypeBinding[] parameters = method.parameters;</TD></TR><TR CLASS="z"><TD CLASS="l">3975</TD><TD>                int paramLength = parameters.length;</TD></TR><TR CLASS="z"><TD CLASS="l">3976</TD><TD>                int argLength = arguments.length;</TD></TR><TR><TD CLASS="l">3977</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3978</TD><TD>                if (compilerOptions().sourceLevel &lt; ClassFileConstants.JDK1_5) {</TD></TR><TR CLASS="z"><TD CLASS="l">3979</TD><TD>                        if (paramLength != argLength)</TD></TR><TR CLASS="z"><TD CLASS="l">3980</TD><TD>                                return NOT_COMPATIBLE;</TD></TR><TR CLASS="z"><TD CLASS="l">3981</TD><TD>                        for (int i = 0; i &lt; argLength; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">3982</TD><TD>                                TypeBinding param = parameters[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3983</TD><TD>                                TypeBinding arg = arguments[i];</TD></TR><TR CLASS="z"><TD CLASS="l">3984</TD><TD>                                if (arg != param &amp;&amp; !arg.isCompatibleWith(param))</TD></TR><TR CLASS="z"><TD CLASS="l">3985</TD><TD>                                        return NOT_COMPATIBLE;</TD></TR><TR><TD CLASS="l">3986</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">3987</TD><TD>                        return COMPATIBLE;</TD></TR><TR><TD CLASS="l">3988</TD><TD>                }</TD></TR><TR><TD CLASS="l">3989</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">3990</TD><TD>                int level = COMPATIBLE; // no autoboxing or varargs support needed</TD></TR><TR CLASS="z"><TD CLASS="l">3991</TD><TD>                int lastIndex = argLength;</TD></TR><TR CLASS="z"><TD CLASS="l">3992</TD><TD>                LookupEnvironment env = environment();</TD></TR><TR CLASS="z"><TD CLASS="l">3993</TD><TD>                if (method.isVarargs()) {</TD></TR><TR CLASS="z"><TD CLASS="l">3994</TD><TD>                        lastIndex = paramLength - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">3995</TD><TD>                        if (paramLength == argLength) { // accept X or X[] but not X[][]</TD></TR><TR CLASS="z"><TD CLASS="l">3996</TD><TD>                                TypeBinding param = parameters[lastIndex]; // is an ArrayBinding by definition</TD></TR><TR CLASS="z"><TD CLASS="l">3997</TD><TD>                                TypeBinding arg = arguments[lastIndex];</TD></TR><TR CLASS="z"><TD CLASS="l">3998</TD><TD>                                if (param != arg) {</TD></TR><TR CLASS="z"><TD CLASS="l">3999</TD><TD>                                        level = parameterCompatibilityLevel(arg, param, env);</TD></TR><TR CLASS="z"><TD CLASS="l">4000</TD><TD>                                        if (level == NOT_COMPATIBLE) {</TD></TR><TR><TD CLASS="l">4001</TD><TD>                                                // expect X[], is it called with X</TD></TR><TR CLASS="z"><TD CLASS="l">4002</TD><TD>                                                param = ((ArrayBinding) param).elementsType();</TD></TR><TR CLASS="z"><TD CLASS="l">4003</TD><TD>                                                if (parameterCompatibilityLevel(arg, param, env) == NOT_COMPATIBLE)</TD></TR><TR CLASS="z"><TD CLASS="l">4004</TD><TD>                                                        return NOT_COMPATIBLE;</TD></TR><TR CLASS="z"><TD CLASS="l">4005</TD><TD>                                                level = VARARGS_COMPATIBLE; // varargs support needed</TD></TR><TR><TD CLASS="l">4006</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">4007</TD><TD>                                }</TD></TR><TR><TD CLASS="l">4008</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">4009</TD><TD>                                if (paramLength &lt; argLength) { // all remaining argument types must be compatible with the elementsType of varArgType</TD></TR><TR CLASS="z"><TD CLASS="l">4010</TD><TD>                                        TypeBinding param = ((ArrayBinding) parameters[lastIndex]).elementsType();</TD></TR><TR CLASS="z"><TD CLASS="l">4011</TD><TD>                                        for (int i = lastIndex; i &lt; argLength; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">4012</TD><TD>                                                TypeBinding arg = arguments[i];</TD></TR><TR CLASS="z"><TD CLASS="l">4013</TD><TD>                                                if (param != arg &amp;&amp; parameterCompatibilityLevel(arg, param, env) == NOT_COMPATIBLE)</TD></TR><TR CLASS="z"><TD CLASS="l">4014</TD><TD>                                                        return NOT_COMPATIBLE;</TD></TR><TR><TD CLASS="l">4015</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">4016</TD><TD>                                }  else if (lastIndex != argLength) { // can call foo(int i, X ... x) with foo(1) but NOT foo();</TD></TR><TR CLASS="z"><TD CLASS="l">4017</TD><TD>                                        return NOT_COMPATIBLE;</TD></TR><TR><TD CLASS="l">4018</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">4019</TD><TD>                                level = VARARGS_COMPATIBLE; // varargs support needed</TD></TR><TR><TD CLASS="l">4020</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">4021</TD><TD>                } else if (paramLength != argLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">4022</TD><TD>                        return NOT_COMPATIBLE;</TD></TR><TR><TD CLASS="l">4023</TD><TD>                }</TD></TR><TR><TD CLASS="l">4024</TD><TD>                // now compare standard arguments from 0 to lastIndex</TD></TR><TR CLASS="z"><TD CLASS="l">4025</TD><TD>                for (int i = 0; i &lt; lastIndex; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">4026</TD><TD>                        TypeBinding param = parameters[i];</TD></TR><TR CLASS="z"><TD CLASS="l">4027</TD><TD>                        TypeBinding arg = arguments[i];</TD></TR><TR CLASS="z"><TD CLASS="l">4028</TD><TD>                        if (arg != param) {</TD></TR><TR CLASS="z"><TD CLASS="l">4029</TD><TD>                                int newLevel = parameterCompatibilityLevel(arg, param, env);</TD></TR><TR CLASS="z"><TD CLASS="l">4030</TD><TD>                                if (newLevel == NOT_COMPATIBLE)</TD></TR><TR CLASS="z"><TD CLASS="l">4031</TD><TD>                                        return NOT_COMPATIBLE;</TD></TR><TR CLASS="z"><TD CLASS="l">4032</TD><TD>                                if (newLevel &gt; level)</TD></TR><TR CLASS="z"><TD CLASS="l">4033</TD><TD>                                        level = newLevel;</TD></TR><TR><TD CLASS="l">4034</TD><TD>                        }</TD></TR><TR><TD CLASS="l">4035</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">4036</TD><TD>                return level;</TD></TR><TR><TD CLASS="l"><A NAME="58">4037</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">4038</TD><TD> </TD></TR><TR><TD CLASS="l">4039</TD><TD>        private int parameterCompatibilityLevel(TypeBinding arg, TypeBinding param, LookupEnvironment env) {</TD></TR><TR><TD CLASS="l">4040</TD><TD>                // only called if env.options.sourceLevel &gt;= ClassFileConstants.JDK1_5</TD></TR><TR CLASS="z"><TD CLASS="l">4041</TD><TD>                if (arg.isCompatibleWith(param))</TD></TR><TR CLASS="z"><TD CLASS="l">4042</TD><TD>                        return COMPATIBLE;</TD></TR><TR CLASS="z"><TD CLASS="l">4043</TD><TD>                if (arg.isBaseType() != param.isBaseType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">4044</TD><TD>                        TypeBinding convertedType = env.computeBoxingType(arg);</TD></TR><TR CLASS="z"><TD CLASS="l">4045</TD><TD>                        if (convertedType == param || convertedType.isCompatibleWith(param))</TD></TR><TR CLASS="z"><TD CLASS="l">4046</TD><TD>                                return AUTOBOX_COMPATIBLE;</TD></TR><TR><TD CLASS="l">4047</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">4048</TD><TD>                return NOT_COMPATIBLE;</TD></TR><TR><TD CLASS="l">4049</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="59">4050</A></TD><TD> </TD></TR><TR><TD CLASS="l">4051</TD><TD>        public abstract ProblemReporter problemReporter();</TD></TR><TR><TD CLASS="l">4052</TD><TD> </TD></TR><TR><TD CLASS="l">4053</TD><TD>        public final CompilationUnitDeclaration referenceCompilationUnit() {</TD></TR><TR CLASS="z"><TD CLASS="l">4054</TD><TD>                Scope scope, unitScope = this;</TD></TR><TR CLASS="z"><TD CLASS="l">4055</TD><TD>                while ((scope = unitScope.parent) != null)</TD></TR><TR CLASS="z"><TD CLASS="l">4056</TD><TD>                        unitScope = scope;</TD></TR><TR CLASS="z"><TD CLASS="l">4057</TD><TD>                return ((CompilationUnitScope) unitScope).referenceContext;</TD></TR><TR><TD CLASS="l">4058</TD><TD>        }</TD></TR><TR><TD CLASS="l">4059</TD><TD> </TD></TR><TR><TD CLASS="l">4060</TD><TD>        /**</TD></TR><TR><TD CLASS="l"><A NAME="5a">4061</A></TD><TD>         * Returns the nearest reference context, starting from current scope.</TD></TR><TR><TD CLASS="l">4062</TD><TD>         * If starting on a class, it will return current class. If starting on unitScope, returns unit.</TD></TR><TR><TD CLASS="l">4063</TD><TD>         */</TD></TR><TR><TD CLASS="l">4064</TD><TD>        public ReferenceContext referenceContext() {</TD></TR><TR CLASS="z"><TD CLASS="l">4065</TD><TD>                Scope current = this;</TD></TR><TR><TD CLASS="l">4066</TD><TD>                do {</TD></TR><TR CLASS="z"><TD CLASS="l">4067</TD><TD>                        switch(current.kind) {</TD></TR><TR><TD CLASS="l">4068</TD><TD>                                case METHOD_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">4069</TD><TD>                                        return ((MethodScope) current).referenceContext;</TD></TR><TR><TD CLASS="l">4070</TD><TD>                                case CLASS_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">4071</TD><TD>                                        return ((ClassScope) current).referenceContext;</TD></TR><TR><TD CLASS="l">4072</TD><TD>                                case COMPILATION_UNIT_SCOPE :</TD></TR><TR CLASS="z"><TD CLASS="l">4073</TD><TD>                                        return ((CompilationUnitScope) current).referenceContext;</TD></TR><TR CLASS="z"><TD CLASS="l">4074</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">4075</TD><TD>                } while ((current = current.parent) != null);</TD></TR><TR CLASS="z"><TD CLASS="l">4076</TD><TD>                return null;</TD></TR><TR><TD CLASS="l"><A NAME="5b">4077</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">4078</TD><TD> </TD></TR><TR><TD CLASS="l">4079</TD><TD>        // start position in this scope - for ordering scopes vs. variables</TD></TR><TR><TD CLASS="l">4080</TD><TD>        int startIndex() {</TD></TR><TR CLASS="z"><TD CLASS="l">4081</TD><TD>                return 0;</TD></TR><TR><TD CLASS="l">4082</TD><TD>        }</TD></TR><TR><TD CLASS="l">4083</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../xslUnitTestCoverage.html">all classes</A>][<A HREF="11f.html">org.eclipse.wst.jsdt.internal.compiler.lookup</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://www.eclemma.org/support.html">EMMA 2.0.5312 EclEmma Fix 1</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>