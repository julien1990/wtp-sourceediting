<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://www.eclemma.org/">EMMA</A> Coverage Report (generated Tue Jun 09 19:59:05 GMT 2009)</TH></TR><TR><TD CLASS="nv">[<A HREF="../xslUnitTestCoverage.html">all classes</A>][<A HREF="17a.html">org.eclipse.wst.jsdt.internal.ui.text.java</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">JavaAutoIndentStrategy.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>JavaAutoIndentStrategy.java</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/2743)</TD><TD CLASS="h">0%   (0/642)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">JavaAutoIndentStrategy</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/42)</TD><TD CLASS="h">0%   (0/2734)</TD><TD CLASS="h">0%   (0/638)</TD></TR><TR><TD CLASS="f"><A HREF="#0">&lt;static initializer&gt;</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">JavaAutoIndentStrategy (String, IJavaScriptProject, ISourceViewer): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#3">addIndent (Document, int, CharSequence, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/77)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">clearCachedValues (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#5">closeBrace (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">computeAnonymousPosition (IDocument, int, String, int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/86)</TD><TD CLASS="h">0%   (0/22)</TD></TR><TR><TD CLASS="f"><A HREF="#7">computeSmartMode (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">computeVisualLength (CharSequence, int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/31)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#9">computeVisualLength (char, int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">createRegion (ASTNode, int): IRegion</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#b">customizeDocumentCommand (IDocument, DocumentCommand): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/78)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">cutIndent (Document, int, int, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/61)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR><TD CLASS="f"><A HREF="#d">findClosingParenToLeft (JavaHeuristicScanner, int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">getBlockBalance (IDocument, int, String): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/56)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR><TD CLASS="f"><A HREF="#f">getBracketCount (IDocument, int, int, boolean): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/69)</TD><TD CLASS="h">0%   (0/26)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">getCommentEnd (IDocument, int, int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#11">getCompilationUnitForMethod (IDocument, int): JavaAutoIndentStrategy$Compilat...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/57)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">getCoreOption (IJavaScriptProject, String): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#13">getCurrentIndent (Document, int): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/81)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">getIndentOfLine (IDocument, int): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/30)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#15">getPeerPosition (IDocument, DocumentCommand): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/172)</TD><TD CLASS="h">0%   (0/51)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">getPreferenceStore (): IPreferenceStore</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#17">getStringEnd (IDocument, int, int, char): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">getToken (IDocument, IRegion, int): IRegion</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/54)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR><TD CLASS="f"><A HREF="#19">getVisualTabLengthPreference (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">installJavaStuff (Document): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/43)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">isClosed (IDocument, int, int): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/268)</TD><TD CLASS="h">0%   (0/49)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">isDefaultPartition (IDocument, int, String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/30)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">isInsertingSpacesForTab (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">isLineDelimiter (IDocument, String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">isNewMatch (IDocument, int, int, String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/88)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">isRepresentingTab (String): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/47)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#21">looksLikeAnonymousClassDef (IDocument, String, JavaHeuristicScanner, int): bo...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/47)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">removeJavaStuff (Document): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#23">skipScope (JavaHeuristicScanner, int, int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/50)</TD><TD CLASS="h">0%   (0/22)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">smartIndentAfterClosingBracket (IDocument, DocumentCommand): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/116)</TD><TD CLASS="h">0%   (0/21)</TD></TR><TR><TD CLASS="f"><A HREF="#25">smartIndentAfterNewLine (IDocument, DocumentCommand): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/312)</TD><TD CLASS="h">0%   (0/52)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">smartIndentAfterOpeningBracket (IDocument, DocumentCommand): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/112)</TD><TD CLASS="h">0%   (0/23)</TD></TR><TR><TD CLASS="f"><A HREF="#27">smartIndentOnKeypress (IDocument, DocumentCommand): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">smartIndentUponE (IDocument, DocumentCommand): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/247)</TD><TD CLASS="h">0%   (0/55)</TD></TR><TR><TD CLASS="f"><A HREF="#29">smartPaste (IDocument, DocumentCommand): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/260)</TD><TD CLASS="h">0%   (0/68)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">subtractIndent (CharSequence, CharSequence, StringBuffer, int): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/47)</TD><TD CLASS="h">0%   (0/12)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#2b">JavaAutoIndentStrategy$CompilationUnitInfo</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">JavaAutoIndentStrategy$CompilationUnitInfo (char [], int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/4)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="l">1</TD><TD>/*******************************************************************************</TD></TR><TR><TD CLASS="l">2</TD><TD> * Copyright (c) 2000, 2009 IBM Corporation and others.</TD></TR><TR><TD CLASS="l">3</TD><TD> * All rights reserved. This program and the accompanying materials</TD></TR><TR><TD CLASS="l">4</TD><TD> * are made available under the terms of the Eclipse Public License v1.0</TD></TR><TR><TD CLASS="l">5</TD><TD> * which accompanies this distribution, and is available at</TD></TR><TR><TD CLASS="l">6</TD><TD> * http://www.eclipse.org/legal/epl-v10.html</TD></TR><TR><TD CLASS="l">7</TD><TD> *</TD></TR><TR><TD CLASS="l">8</TD><TD> * Contributors:</TD></TR><TR><TD CLASS="l">9</TD><TD> *     IBM Corporation - initial API and implementation</TD></TR><TR><TD CLASS="l">10</TD><TD> *     Nikolay Metchev - Fixed https://bugs.eclipse.org/bugs/show_bug.cgi?id=29909</TD></TR><TR><TD CLASS="l">11</TD><TD> *     Tom Eicher (Avaloq Evolution AG) - block selection mode</TD></TR><TR><TD CLASS="l">12</TD><TD> *******************************************************************************/</TD></TR><TR><TD CLASS="l">13</TD><TD>package org.eclipse.wst.jsdt.internal.ui.text.java;</TD></TR><TR><TD CLASS="l">14</TD><TD> </TD></TR><TR><TD CLASS="l">15</TD><TD>import org.eclipse.core.runtime.Assert;</TD></TR><TR><TD CLASS="l">16</TD><TD>import org.eclipse.jface.preference.IPreferenceStore;</TD></TR><TR><TD CLASS="l">17</TD><TD>import org.eclipse.jface.text.BadLocationException;</TD></TR><TR><TD CLASS="l">18</TD><TD>import org.eclipse.jface.text.DefaultIndentLineAutoEditStrategy;</TD></TR><TR><TD CLASS="l">19</TD><TD>import org.eclipse.jface.text.Document;</TD></TR><TR><TD CLASS="l">20</TD><TD>import org.eclipse.jface.text.DocumentCommand;</TD></TR><TR><TD CLASS="l">21</TD><TD>import org.eclipse.jface.text.DocumentRewriteSession;</TD></TR><TR><TD CLASS="l">22</TD><TD>import org.eclipse.jface.text.DocumentRewriteSessionType;</TD></TR><TR><TD CLASS="l">23</TD><TD>import org.eclipse.jface.text.IDocument;</TD></TR><TR><TD CLASS="l">24</TD><TD>import org.eclipse.jface.text.IRegion;</TD></TR><TR><TD CLASS="l">25</TD><TD>import org.eclipse.jface.text.ITypedRegion;</TD></TR><TR><TD CLASS="l">26</TD><TD>import org.eclipse.jface.text.Region;</TD></TR><TR><TD CLASS="l">27</TD><TD>import org.eclipse.jface.text.TextUtilities;</TD></TR><TR><TD CLASS="l">28</TD><TD>import org.eclipse.jface.text.rules.FastPartitioner;</TD></TR><TR><TD CLASS="l">29</TD><TD>import org.eclipse.jface.text.source.ISourceViewer;</TD></TR><TR><TD CLASS="l">30</TD><TD>import org.eclipse.ui.IEditorPart;</TD></TR><TR><TD CLASS="l">31</TD><TD>import org.eclipse.ui.IWorkbenchPage;</TD></TR><TR><TD CLASS="l">32</TD><TD>import org.eclipse.ui.texteditor.ITextEditorExtension3;</TD></TR><TR><TD CLASS="l">33</TD><TD>import org.eclipse.wst.jsdt.core.IJavaScriptProject;</TD></TR><TR><TD CLASS="l">34</TD><TD>import org.eclipse.wst.jsdt.core.JavaScriptCore;</TD></TR><TR><TD CLASS="l">35</TD><TD>import org.eclipse.wst.jsdt.core.ToolFactory;</TD></TR><TR><TD CLASS="l">36</TD><TD>import org.eclipse.wst.jsdt.core.compiler.IProblem;</TD></TR><TR><TD CLASS="l">37</TD><TD>import org.eclipse.wst.jsdt.core.compiler.IScanner;</TD></TR><TR><TD CLASS="l">38</TD><TD>import org.eclipse.wst.jsdt.core.compiler.ITerminalSymbols;</TD></TR><TR><TD CLASS="l">39</TD><TD>import org.eclipse.wst.jsdt.core.compiler.InvalidInputException;</TD></TR><TR><TD CLASS="l">40</TD><TD>import org.eclipse.wst.jsdt.core.dom.AST;</TD></TR><TR><TD CLASS="l">41</TD><TD>import org.eclipse.wst.jsdt.core.dom.ASTNode;</TD></TR><TR><TD CLASS="l">42</TD><TD>import org.eclipse.wst.jsdt.core.dom.ASTParser;</TD></TR><TR><TD CLASS="l">43</TD><TD>import org.eclipse.wst.jsdt.core.dom.DoStatement;</TD></TR><TR><TD CLASS="l">44</TD><TD>import org.eclipse.wst.jsdt.core.dom.Expression;</TD></TR><TR><TD CLASS="l">45</TD><TD>import org.eclipse.wst.jsdt.core.dom.ForStatement;</TD></TR><TR><TD CLASS="l">46</TD><TD>import org.eclipse.wst.jsdt.core.dom.IfStatement;</TD></TR><TR><TD CLASS="l">47</TD><TD>import org.eclipse.wst.jsdt.core.dom.JavaScriptUnit;</TD></TR><TR><TD CLASS="l">48</TD><TD>import org.eclipse.wst.jsdt.core.dom.Statement;</TD></TR><TR><TD CLASS="l">49</TD><TD>import org.eclipse.wst.jsdt.core.dom.WhileStatement;</TD></TR><TR><TD CLASS="l">50</TD><TD>import org.eclipse.wst.jsdt.core.formatter.DefaultCodeFormatterConstants;</TD></TR><TR><TD CLASS="l">51</TD><TD>import org.eclipse.wst.jsdt.internal.corext.dom.NodeFinder;</TD></TR><TR><TD CLASS="l">52</TD><TD>import org.eclipse.wst.jsdt.internal.corext.util.CodeFormatterUtil;</TD></TR><TR><TD CLASS="l">53</TD><TD>import org.eclipse.wst.jsdt.internal.ui.JavaScriptPlugin;</TD></TR><TR><TD CLASS="l">54</TD><TD>import org.eclipse.wst.jsdt.internal.ui.text.FastJavaPartitionScanner;</TD></TR><TR><TD CLASS="l">55</TD><TD>import org.eclipse.wst.jsdt.internal.ui.text.JavaHeuristicScanner;</TD></TR><TR><TD CLASS="l">56</TD><TD>import org.eclipse.wst.jsdt.internal.ui.text.JavaIndenter;</TD></TR><TR><TD CLASS="l">57</TD><TD>import org.eclipse.wst.jsdt.internal.ui.text.Symbols;</TD></TR><TR><TD CLASS="l">58</TD><TD>import org.eclipse.wst.jsdt.ui.PreferenceConstants;</TD></TR><TR><TD CLASS="l">59</TD><TD>import org.eclipse.wst.jsdt.ui.text.IJavaScriptPartitions;</TD></TR><TR><TD CLASS="l">60</TD><TD> </TD></TR><TR><TD CLASS="l">61</TD><TD> </TD></TR><TR><TD CLASS="l">62</TD><TD>/**</TD></TR><TR><TD CLASS="l">63</TD><TD> * Auto indent strategy sensitive to brackets.</TD></TR><TR><TD CLASS="l">64</TD><TD> */</TD></TR><TR CLASS="z"><TD CLASS="l">65</TD><TD>public class JavaAutoIndentStrategy extends DefaultIndentLineAutoEditStrategy {</TD></TR><TR><TD CLASS="l">66</TD><TD> </TD></TR><TR><TD CLASS="l">67</TD><TD>        /** The line comment introducer. Value is &#34;{@value}&#34; */</TD></TR><TR><TD CLASS="l">68</TD><TD>        private static final String LINE_COMMENT= &#34;//&#34;; //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">69</TD><TD> </TD></TR><TR><TD CLASS="l">70</TD><TD>                private static class CompilationUnitInfo {</TD></TR><TR><TD CLASS="l"><A NAME="2b">71</A></TD><TD> </TD></TR><TR><TD CLASS="l">72</TD><TD>                        char[] buffer;</TD></TR><TR><TD CLASS="l">73</TD><TD>                        int delta;</TD></TR><TR><TD CLASS="l">74</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">75</TD><TD>                        CompilationUnitInfo(char[] buffer, int delta) {</TD></TR><TR CLASS="z"><TD CLASS="l">76</TD><TD>                                this.buffer= buffer;</TD></TR><TR CLASS="z"><TD CLASS="l">77</TD><TD>                                this.delta= delta;</TD></TR><TR CLASS="z"><TD CLASS="l">78</TD><TD>                        }</TD></TR><TR><TD CLASS="l">79</TD><TD>                }</TD></TR><TR><TD CLASS="l">80</TD><TD> </TD></TR><TR><TD CLASS="l">81</TD><TD> </TD></TR><TR><TD CLASS="l">82</TD><TD>        private boolean fCloseBrace;</TD></TR><TR><TD CLASS="l">83</TD><TD>        private boolean fIsSmartMode;</TD></TR><TR><TD CLASS="l"><A NAME="0">84</A></TD><TD>        private boolean fIsSmartTab;</TD></TR><TR><TD CLASS="l">85</TD><TD> </TD></TR><TR><TD CLASS="l">86</TD><TD>        private String fPartitioning;</TD></TR><TR><TD CLASS="l">87</TD><TD>        private final IJavaScriptProject fProject;</TD></TR><TR CLASS="z"><TD CLASS="l">88</TD><TD>        private static IScanner fgScanner= ToolFactory.createScanner(false, false, false, false);</TD></TR><TR><TD CLASS="l">89</TD><TD>        /**</TD></TR><TR><TD CLASS="l">90</TD><TD>         * The viewer.</TD></TR><TR><TD CLASS="l">91</TD><TD>         * @since 3.5</TD></TR><TR><TD CLASS="l">92</TD><TD>         */</TD></TR><TR><TD CLASS="l">93</TD><TD>        private final ISourceViewer fViewer;</TD></TR><TR><TD CLASS="l">94</TD><TD> </TD></TR><TR><TD CLASS="l">95</TD><TD>        /**</TD></TR><TR><TD CLASS="l">96</TD><TD>         * Creates a new Java auto indent strategy for the given document partitioning.</TD></TR><TR><TD CLASS="l">97</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="2">98</A></TD><TD>         * @param partitioning the document partitioning</TD></TR><TR><TD CLASS="l">99</TD><TD>         * @param project the project to get formatting preferences from, or null to use default preferences</TD></TR><TR><TD CLASS="l">100</TD><TD>         * @param viewer the source viewer that this strategy is attached to</TD></TR><TR><TD CLASS="l">101</TD><TD>         */</TD></TR><TR CLASS="z"><TD CLASS="l">102</TD><TD>        public JavaAutoIndentStrategy(String partitioning, IJavaScriptProject project, ISourceViewer viewer) {</TD></TR><TR CLASS="z"><TD CLASS="l">103</TD><TD>                fPartitioning= partitioning;</TD></TR><TR CLASS="z"><TD CLASS="l">104</TD><TD>                fProject= project;</TD></TR><TR CLASS="z"><TD CLASS="l">105</TD><TD>                fViewer= viewer;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="f">106</A></TD><TD>         }</TD></TR><TR><TD CLASS="l">107</TD><TD> </TD></TR><TR><TD CLASS="l">108</TD><TD>        private int getBracketCount(IDocument d, int startOffset, int endOffset, boolean ignoreCloseBrackets) throws BadLocationException {</TD></TR><TR><TD CLASS="l">109</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">110</TD><TD>                int bracketCount= 0;</TD></TR><TR CLASS="z"><TD CLASS="l">111</TD><TD>                while (startOffset &lt; endOffset) {</TD></TR><TR CLASS="z"><TD CLASS="l">112</TD><TD>                        char curr= d.getChar(startOffset);</TD></TR><TR CLASS="z"><TD CLASS="l">113</TD><TD>                        startOffset++;</TD></TR><TR CLASS="z"><TD CLASS="l">114</TD><TD>                        switch (curr) {</TD></TR><TR><TD CLASS="l">115</TD><TD>                                case '/' :</TD></TR><TR CLASS="z"><TD CLASS="l">116</TD><TD>                                        if (startOffset &lt; endOffset) {</TD></TR><TR CLASS="z"><TD CLASS="l">117</TD><TD>                                                char next= d.getChar(startOffset);</TD></TR><TR CLASS="z"><TD CLASS="l">118</TD><TD>                                                if (next == '*') {</TD></TR><TR><TD CLASS="l">119</TD><TD>                                                        // a comment starts, advance to the comment end</TD></TR><TR CLASS="z"><TD CLASS="l">120</TD><TD>                                                        startOffset= getCommentEnd(d, startOffset + 1, endOffset);</TD></TR><TR CLASS="z"><TD CLASS="l">121</TD><TD>                                                } else if (next == '/') {</TD></TR><TR><TD CLASS="l">122</TD><TD>                                                        // '//'-comment: nothing to do anymore on this line</TD></TR><TR CLASS="z"><TD CLASS="l">123</TD><TD>                                                        startOffset= endOffset;</TD></TR><TR><TD CLASS="l">124</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">125</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">126</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">127</TD><TD>                                case '*' :</TD></TR><TR CLASS="z"><TD CLASS="l">128</TD><TD>                                        if (startOffset &lt; endOffset) {</TD></TR><TR CLASS="z"><TD CLASS="l">129</TD><TD>                                                char next= d.getChar(startOffset);</TD></TR><TR CLASS="z"><TD CLASS="l">130</TD><TD>                                                if (next == '/') {</TD></TR><TR><TD CLASS="l">131</TD><TD>                                                        // we have been in a comment: forget what we read before</TD></TR><TR CLASS="z"><TD CLASS="l">132</TD><TD>                                                        bracketCount= 0;</TD></TR><TR CLASS="z"><TD CLASS="l">133</TD><TD>                                                        startOffset++;</TD></TR><TR><TD CLASS="l">134</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">135</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">136</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">137</TD><TD>                                case '{' :</TD></TR><TR CLASS="z"><TD CLASS="l">138</TD><TD>                                        bracketCount++;</TD></TR><TR CLASS="z"><TD CLASS="l">139</TD><TD>                                        ignoreCloseBrackets= false;</TD></TR><TR CLASS="z"><TD CLASS="l">140</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">141</TD><TD>                                case '}' :</TD></TR><TR CLASS="z"><TD CLASS="l">142</TD><TD>                                        if (!ignoreCloseBrackets) {</TD></TR><TR CLASS="z"><TD CLASS="l">143</TD><TD>                                                bracketCount--;</TD></TR><TR><TD CLASS="l">144</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">145</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">146</TD><TD>                                case '&#34;' :</TD></TR><TR><TD CLASS="l">147</TD><TD>                                case '\'' :</TD></TR><TR CLASS="z"><TD CLASS="l">148</TD><TD>                                        startOffset= getStringEnd(d, startOffset, endOffset, curr);</TD></TR><TR><TD CLASS="l">149</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">150</TD><TD>                                default :</TD></TR><TR><TD CLASS="l">151</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">152</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">153</TD><TD>                return bracketCount;</TD></TR><TR><TD CLASS="l">154</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="10">155</A></TD><TD> </TD></TR><TR><TD CLASS="l">156</TD><TD>        // ----------- bracket counting ------------------------------------------------------</TD></TR><TR><TD CLASS="l">157</TD><TD> </TD></TR><TR><TD CLASS="l">158</TD><TD>        private int getCommentEnd(IDocument d, int offset, int endOffset) throws BadLocationException {</TD></TR><TR CLASS="z"><TD CLASS="l">159</TD><TD>                while (offset &lt; endOffset) {</TD></TR><TR CLASS="z"><TD CLASS="l">160</TD><TD>                        char curr= d.getChar(offset);</TD></TR><TR CLASS="z"><TD CLASS="l">161</TD><TD>                        offset++;</TD></TR><TR CLASS="z"><TD CLASS="l">162</TD><TD>                        if (curr == '*') {</TD></TR><TR CLASS="z"><TD CLASS="l">163</TD><TD>                                if (offset &lt; endOffset &amp;&amp; d.getChar(offset) == '/') {</TD></TR><TR CLASS="z"><TD CLASS="l">164</TD><TD>                                        return offset + 1;</TD></TR><TR><TD CLASS="l">165</TD><TD>                                }</TD></TR><TR><TD CLASS="l">166</TD><TD>                        }</TD></TR><TR><TD CLASS="l">167</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="14">168</A></TD><TD>                return endOffset;</TD></TR><TR><TD CLASS="l">169</TD><TD>        }</TD></TR><TR><TD CLASS="l">170</TD><TD> </TD></TR><TR><TD CLASS="l">171</TD><TD>        private String getIndentOfLine(IDocument d, int line) throws BadLocationException {</TD></TR><TR CLASS="z"><TD CLASS="l">172</TD><TD>                if (line &gt; -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">173</TD><TD>                        int start= d.getLineOffset(line);</TD></TR><TR CLASS="z"><TD CLASS="l">174</TD><TD>                        int end= start + d.getLineLength(line) - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">175</TD><TD>                        int whiteEnd= findEndOfWhiteSpace(d, start, end);</TD></TR><TR CLASS="z"><TD CLASS="l">176</TD><TD>                        return d.get(start, whiteEnd - start);</TD></TR><TR><TD CLASS="l">177</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">178</TD><TD>                        return &#34;&#34;; //$NON-NLS-1$</TD></TR><TR><TD CLASS="l"><A NAME="17">179</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">180</TD><TD>        }</TD></TR><TR><TD CLASS="l">181</TD><TD> </TD></TR><TR><TD CLASS="l">182</TD><TD>        private int getStringEnd(IDocument d, int offset, int endOffset, char ch) throws BadLocationException {</TD></TR><TR CLASS="z"><TD CLASS="l">183</TD><TD>                while (offset &lt; endOffset) {</TD></TR><TR CLASS="z"><TD CLASS="l">184</TD><TD>                        char curr= d.getChar(offset);</TD></TR><TR CLASS="z"><TD CLASS="l">185</TD><TD>                        offset++;</TD></TR><TR CLASS="z"><TD CLASS="l">186</TD><TD>                        if (curr == '\\') {</TD></TR><TR><TD CLASS="l">187</TD><TD>                                // ignore escaped characters</TD></TR><TR CLASS="z"><TD CLASS="l">188</TD><TD>                                offset++;</TD></TR><TR CLASS="z"><TD CLASS="l">189</TD><TD>                        } else if (curr == ch) {</TD></TR><TR CLASS="z"><TD CLASS="l">190</TD><TD>                                return offset;</TD></TR><TR><TD CLASS="l">191</TD><TD>                        }</TD></TR><TR><TD CLASS="l">192</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="24">193</A></TD><TD>                return endOffset;</TD></TR><TR><TD CLASS="l">194</TD><TD>        }</TD></TR><TR><TD CLASS="l">195</TD><TD> </TD></TR><TR><TD CLASS="l">196</TD><TD>        private void smartIndentAfterClosingBracket(IDocument d, DocumentCommand c) {</TD></TR><TR CLASS="z"><TD CLASS="l">197</TD><TD>                if (c.offset == -1 || d.getLength() == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">198</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">199</TD><TD> </TD></TR><TR><TD CLASS="l">200</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">201</TD><TD>                        int p= (c.offset == d.getLength() ? c.offset - 1 : c.offset);</TD></TR><TR CLASS="z"><TD CLASS="l">202</TD><TD>                        int line= d.getLineOfOffset(p);</TD></TR><TR CLASS="z"><TD CLASS="l">203</TD><TD>                        int start= d.getLineOffset(line);</TD></TR><TR CLASS="z"><TD CLASS="l">204</TD><TD>                        int whiteend= findEndOfWhiteSpace(d, start, c.offset);</TD></TR><TR><TD CLASS="l">205</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">206</TD><TD>                        JavaHeuristicScanner scanner= new JavaHeuristicScanner(d);</TD></TR><TR CLASS="z"><TD CLASS="l">207</TD><TD>                        JavaIndenter indenter= new JavaIndenter(d, scanner, fProject);</TD></TR><TR><TD CLASS="l">208</TD><TD> </TD></TR><TR><TD CLASS="l">209</TD><TD>                        // shift only when line does not contain any text up to the closing bracket</TD></TR><TR CLASS="z"><TD CLASS="l">210</TD><TD>                        if (whiteend == c.offset) {</TD></TR><TR><TD CLASS="l">211</TD><TD>                                // evaluate the line with the opening bracket that matches out closing bracket</TD></TR><TR CLASS="z"><TD CLASS="l">212</TD><TD>                                int reference= indenter.findReferencePosition(c.offset, false, true, false, false);</TD></TR><TR CLASS="z"><TD CLASS="l">213</TD><TD>                                int indLine= d.getLineOfOffset(reference);</TD></TR><TR CLASS="z"><TD CLASS="l">214</TD><TD>                                if (indLine != -1 &amp;&amp; indLine != line) {</TD></TR><TR><TD CLASS="l">215</TD><TD>                                        // take the indent of the found line</TD></TR><TR CLASS="z"><TD CLASS="l">216</TD><TD>                                        StringBuffer replaceText= new StringBuffer(getIndentOfLine(d, indLine));</TD></TR><TR><TD CLASS="l">217</TD><TD>                                        // add the rest of the current line including the just added close bracket</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>                                        replaceText.append(d.get(whiteend, c.offset - whiteend));</TD></TR><TR CLASS="z"><TD CLASS="l">219</TD><TD>                                        replaceText.append(c.text);</TD></TR><TR><TD CLASS="l">220</TD><TD>                                        // modify document command</TD></TR><TR CLASS="z"><TD CLASS="l">221</TD><TD>                                        c.length += c.offset - start;</TD></TR><TR CLASS="z"><TD CLASS="l">222</TD><TD>                                        c.offset= start;</TD></TR><TR CLASS="z"><TD CLASS="l">223</TD><TD>                                        c.text= replaceText.toString();</TD></TR><TR><TD CLASS="l">224</TD><TD>                                }</TD></TR><TR><TD CLASS="l">225</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">226</TD><TD>                } catch (BadLocationException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">227</TD><TD>                        JavaScriptPlugin.log(e);</TD></TR><TR><TD CLASS="l"><A NAME="26">228</A></TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">229</TD><TD>        }</TD></TR><TR><TD CLASS="l">230</TD><TD> </TD></TR><TR><TD CLASS="l">231</TD><TD>        private void smartIndentAfterOpeningBracket(IDocument d, DocumentCommand c) {</TD></TR><TR CLASS="z"><TD CLASS="l">232</TD><TD>                if (c.offset &lt; 1 || d.getLength() == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">233</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">234</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">235</TD><TD>                JavaHeuristicScanner scanner= new JavaHeuristicScanner(d);</TD></TR><TR><TD CLASS="l">236</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">237</TD><TD>                int p= (c.offset == d.getLength() ? c.offset - 1 : c.offset);</TD></TR><TR><TD CLASS="l">238</TD><TD> </TD></TR><TR><TD CLASS="l">239</TD><TD>                try {</TD></TR><TR><TD CLASS="l">240</TD><TD>                        // current line</TD></TR><TR CLASS="z"><TD CLASS="l">241</TD><TD>                        int line= d.getLineOfOffset(p);</TD></TR><TR CLASS="z"><TD CLASS="l">242</TD><TD>                        int lineOffset= d.getLineOffset(line);</TD></TR><TR><TD CLASS="l">243</TD><TD> </TD></TR><TR><TD CLASS="l">244</TD><TD>                        // make sure we don't have any leading comments etc.</TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>                        if (d.get(lineOffset, p - lineOffset).trim().length() != 0)</TD></TR><TR CLASS="z"><TD CLASS="l">246</TD><TD>                                return;</TD></TR><TR><TD CLASS="l">247</TD><TD> </TD></TR><TR><TD CLASS="l">248</TD><TD>                        // line of last Java code</TD></TR><TR CLASS="z"><TD CLASS="l">249</TD><TD>                        int pos= scanner.findNonWhitespaceBackward(p, JavaHeuristicScanner.UNBOUND);</TD></TR><TR CLASS="z"><TD CLASS="l">250</TD><TD>                        if (pos == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">251</TD><TD>                                return;</TD></TR><TR CLASS="z"><TD CLASS="l">252</TD><TD>                        int lastLine= d.getLineOfOffset(pos);</TD></TR><TR><TD CLASS="l">253</TD><TD> </TD></TR><TR><TD CLASS="l">254</TD><TD>                        // only shift if the last java line is further up and is a braceless block candidate</TD></TR><TR CLASS="z"><TD CLASS="l">255</TD><TD>                        if (lastLine &lt; line) {</TD></TR><TR><TD CLASS="l">256</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">257</TD><TD>                                JavaIndenter indenter= new JavaIndenter(d, scanner, fProject);</TD></TR><TR CLASS="z"><TD CLASS="l">258</TD><TD>                                StringBuffer indent= indenter.computeIndentation(p, true);</TD></TR><TR CLASS="z"><TD CLASS="l">259</TD><TD>                                String toDelete= d.get(lineOffset, c.offset - lineOffset);</TD></TR><TR CLASS="z"><TD CLASS="l">260</TD><TD>                                if (indent != null &amp;&amp; !indent.toString().equals(toDelete)) {</TD></TR><TR CLASS="z"><TD CLASS="l">261</TD><TD>                                        c.text= indent.append(c.text).toString();</TD></TR><TR CLASS="z"><TD CLASS="l">262</TD><TD>                                        c.length += c.offset - lineOffset;</TD></TR><TR CLASS="z"><TD CLASS="l">263</TD><TD>                                        c.offset= lineOffset;</TD></TR><TR><TD CLASS="l">264</TD><TD>                                }</TD></TR><TR><TD CLASS="l">265</TD><TD>                        }</TD></TR><TR><TD CLASS="l">266</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">267</TD><TD>                } catch (BadLocationException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">268</TD><TD>                        JavaScriptPlugin.log(e);</TD></TR><TR><TD CLASS="l">269</TD><TD>                }</TD></TR><TR><TD CLASS="l"><A NAME="25">270</A></TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">271</TD><TD>        }</TD></TR><TR><TD CLASS="l">272</TD><TD> </TD></TR><TR><TD CLASS="l">273</TD><TD>        private void smartIndentAfterNewLine(IDocument d, DocumentCommand c) {</TD></TR><TR CLASS="z"><TD CLASS="l">274</TD><TD>                JavaHeuristicScanner scanner= new JavaHeuristicScanner(d);</TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>                JavaIndenter indenter= new JavaIndenter(d, scanner, fProject);</TD></TR><TR CLASS="z"><TD CLASS="l">276</TD><TD>                StringBuffer indent= indenter.computeIndentation(c.offset);</TD></TR><TR CLASS="z"><TD CLASS="l">277</TD><TD>                if (indent == null)</TD></TR><TR CLASS="z"><TD CLASS="l">278</TD><TD>                        indent= new StringBuffer();</TD></TR><TR><TD CLASS="l">279</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">280</TD><TD>                int docLength= d.getLength();</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>                if (c.offset == -1 || docLength == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">282</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">283</TD><TD> </TD></TR><TR><TD CLASS="l">284</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">285</TD><TD>                        int p= (c.offset == docLength ? c.offset - 1 : c.offset);</TD></TR><TR CLASS="z"><TD CLASS="l">286</TD><TD>                        int line= d.getLineOfOffset(p);</TD></TR><TR><TD CLASS="l">287</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">288</TD><TD>                        StringBuffer buf= new StringBuffer(c.text + indent);</TD></TR><TR><TD CLASS="l">289</TD><TD> </TD></TR><TR><TD CLASS="l">290</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">291</TD><TD>                        IRegion reg= d.getLineInformation(line);</TD></TR><TR CLASS="z"><TD CLASS="l">292</TD><TD>                        int lineEnd= reg.getOffset() + reg.getLength();</TD></TR><TR><TD CLASS="l">293</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">294</TD><TD>                        int contentStart= findEndOfWhiteSpace(d, c.offset, lineEnd);</TD></TR><TR CLASS="z"><TD CLASS="l">295</TD><TD>                        c.length=  Math.max(contentStart - c.offset, 0);</TD></TR><TR><TD CLASS="l">296</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">297</TD><TD>                        int start= reg.getOffset();</TD></TR><TR CLASS="z"><TD CLASS="l">298</TD><TD>                        ITypedRegion region= TextUtilities.getPartition(d, fPartitioning, start, true);</TD></TR><TR CLASS="z"><TD CLASS="l">299</TD><TD>                        if (IJavaScriptPartitions.JAVA_DOC.equals(region.getType()))</TD></TR><TR CLASS="z"><TD CLASS="l">300</TD><TD>                                start= d.getLineInformationOfOffset(region.getOffset()).getOffset();</TD></TR><TR><TD CLASS="l">301</TD><TD> </TD></TR><TR><TD CLASS="l">302</TD><TD>                        // insert closing brace on new line after an unclosed opening brace</TD></TR><TR CLASS="z"><TD CLASS="l">303</TD><TD>                        if (getBracketCount(d, start, c.offset, true) &gt; 0 &amp;&amp; closeBrace() &amp;&amp; !isClosed(d, c.offset, c.length)) {</TD></TR><TR CLASS="z"><TD CLASS="l">304</TD><TD>                                c.caretOffset= c.offset + buf.length();</TD></TR><TR CLASS="z"><TD CLASS="l">305</TD><TD>                                c.shiftsCaret= false;</TD></TR><TR><TD CLASS="l">306</TD><TD> </TD></TR><TR><TD CLASS="l">307</TD><TD>                                // copy old content of line behind insertion point to new line</TD></TR><TR><TD CLASS="l">308</TD><TD>                                // unless we think we are inserting an anonymous type definition</TD></TR><TR><TD CLASS="l">309</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">310</TD><TD>                                if (c.offset == 0 || computeAnonymousPosition(d, c.offset - 1, fPartitioning, lineEnd) == -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">311</TD><TD>                                        if (lineEnd - contentStart &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">312</TD><TD>                                                c.length=  lineEnd - c.offset;</TD></TR><TR CLASS="z"><TD CLASS="l">313</TD><TD>                                                buf.append(d.get(contentStart, lineEnd - contentStart).toCharArray());</TD></TR><TR><TD CLASS="l">314</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">315</TD><TD>                                }</TD></TR><TR><TD CLASS="l">316</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">317</TD><TD>                                buf.append(TextUtilities.getDefaultLineDelimiter(d));</TD></TR><TR CLASS="z"><TD CLASS="l">318</TD><TD>                                StringBuffer reference= null;</TD></TR><TR CLASS="z"><TD CLASS="l">319</TD><TD>                                int nonWS= findEndOfWhiteSpace(d, start, lineEnd);</TD></TR><TR CLASS="z"><TD CLASS="l">320</TD><TD>                                if (nonWS &lt; c.offset &amp;&amp; d.getChar(nonWS) == '{')</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>                                        reference= new StringBuffer(d.get(start, nonWS - start));</TD></TR><TR><TD CLASS="l">322</TD><TD>                                else</TD></TR><TR CLASS="z"><TD CLASS="l">323</TD><TD>                                        reference= indenter.getReferenceIndentation(c.offset);</TD></TR><TR CLASS="z"><TD CLASS="l">324</TD><TD>                                if (reference != null)</TD></TR><TR CLASS="z"><TD CLASS="l">325</TD><TD>                                        buf.append(reference);</TD></TR><TR CLASS="z"><TD CLASS="l">326</TD><TD>                                buf.append('}');</TD></TR><TR><TD CLASS="l">327</TD><TD>                        }</TD></TR><TR><TD CLASS="l">328</TD><TD>                        // insert extra line upon new line between two braces</TD></TR><TR CLASS="z"><TD CLASS="l">329</TD><TD>                        else if (c.offset &gt; start &amp;&amp; contentStart &lt; lineEnd &amp;&amp; d.getChar(contentStart) == '}') {</TD></TR><TR CLASS="z"><TD CLASS="l">330</TD><TD>                                int firstCharPos= scanner.findNonWhitespaceBackward(c.offset - 1, start);</TD></TR><TR CLASS="z"><TD CLASS="l">331</TD><TD>                                if (firstCharPos != JavaHeuristicScanner.NOT_FOUND &amp;&amp; d.getChar(firstCharPos) == '{') {</TD></TR><TR CLASS="z"><TD CLASS="l">332</TD><TD>                                        c.caretOffset= c.offset + buf.length();</TD></TR><TR CLASS="z"><TD CLASS="l">333</TD><TD>                                        c.shiftsCaret= false;</TD></TR><TR><TD CLASS="l">334</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">335</TD><TD>                                        StringBuffer reference= null;</TD></TR><TR CLASS="z"><TD CLASS="l">336</TD><TD>                                        int nonWS= findEndOfWhiteSpace(d, start, lineEnd);</TD></TR><TR CLASS="z"><TD CLASS="l">337</TD><TD>                                        if (nonWS &lt; c.offset &amp;&amp; d.getChar(nonWS) == '{')</TD></TR><TR CLASS="z"><TD CLASS="l">338</TD><TD>                                                reference= new StringBuffer(d.get(start, nonWS - start));</TD></TR><TR><TD CLASS="l">339</TD><TD>                                        else</TD></TR><TR CLASS="z"><TD CLASS="l">340</TD><TD>                                                reference= indenter.getReferenceIndentation(c.offset);</TD></TR><TR><TD CLASS="l">341</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">342</TD><TD>                                        buf.append(TextUtilities.getDefaultLineDelimiter(d));</TD></TR><TR><TD CLASS="l">343</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">344</TD><TD>                                        if (reference != null)</TD></TR><TR CLASS="z"><TD CLASS="l">345</TD><TD>                                                buf.append(reference);</TD></TR><TR><TD CLASS="l">346</TD><TD>                                }</TD></TR><TR><TD CLASS="l">347</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">348</TD><TD>                        c.text= buf.toString();</TD></TR><TR><TD CLASS="l">349</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">350</TD><TD>                } catch (BadLocationException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">351</TD><TD>                        JavaScriptPlugin.log(e);</TD></TR><TR><TD CLASS="l">352</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">353</TD><TD>        }</TD></TR><TR><TD CLASS="l">354</TD><TD> </TD></TR><TR><TD CLASS="l">355</TD><TD>        /**</TD></TR><TR><TD CLASS="l">356</TD><TD>         * Computes an insert position for an opening brace if &lt;code&gt;offset&lt;/code&gt; maps to a position in</TD></TR><TR><TD CLASS="l">357</TD><TD>         * &lt;code&gt;document&lt;/code&gt; with a expression in parenthesis that will take a block after the closing parenthesis.</TD></TR><TR><TD CLASS="l">358</TD><TD>         *</TD></TR><TR><TD CLASS="l">359</TD><TD>         * @param document the document being modified</TD></TR><TR><TD CLASS="l">360</TD><TD>         * @param offset the offset of the caret position, relative to the line start.</TD></TR><TR><TD CLASS="l">361</TD><TD>         * @param partitioning the document partitioning</TD></TR><TR><TD CLASS="l">362</TD><TD>         * @param max the max position</TD></TR><TR><TD CLASS="l">363</TD><TD>         * @return an insert position relative to the line start if &lt;code&gt;line&lt;/code&gt; contains a parenthesized expression that can be followed by a block, -1 otherwise</TD></TR><TR><TD CLASS="l">364</TD><TD>         */</TD></TR><TR><TD CLASS="l">365</TD><TD>        private static int computeAnonymousPosition(IDocument document, int offset, String partitioning,  int max) {</TD></TR><TR><TD CLASS="l"><A NAME="6">366</A></TD><TD>                // find the opening parenthesis for every closing parenthesis on the current line after offset</TD></TR><TR><TD CLASS="l">367</TD><TD>                // return the position behind the closing parenthesis if it looks like a method declaration</TD></TR><TR><TD CLASS="l">368</TD><TD>                // or an expression for an if, while, for, catch statement</TD></TR><TR><TD CLASS="l">369</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">370</TD><TD>                JavaHeuristicScanner scanner= new JavaHeuristicScanner(document);</TD></TR><TR CLASS="z"><TD CLASS="l">371</TD><TD>                int pos= offset;</TD></TR><TR CLASS="z"><TD CLASS="l">372</TD><TD>                int length= max;</TD></TR><TR CLASS="z"><TD CLASS="l">373</TD><TD>                int scanTo= scanner.scanForward(pos, length, '}');</TD></TR><TR CLASS="z"><TD CLASS="l">374</TD><TD>                if (scanTo == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">375</TD><TD>                        scanTo= length;</TD></TR><TR><TD CLASS="l">376</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">377</TD><TD>                int closingParen= findClosingParenToLeft(scanner, pos) - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">378</TD><TD>                boolean hasNewToken= looksLikeAnonymousClassDef(document, partitioning, scanner, pos);</TD></TR><TR CLASS="z"><TD CLASS="l">379</TD><TD>                int openingParen= -1;</TD></TR><TR><TD CLASS="l">380</TD><TD>                while (true) {</TD></TR><TR CLASS="z"><TD CLASS="l">381</TD><TD>                        int startScan= closingParen + 1;</TD></TR><TR CLASS="z"><TD CLASS="l">382</TD><TD>                        closingParen= scanner.scanForward(startScan, scanTo, ')');</TD></TR><TR CLASS="z"><TD CLASS="l">383</TD><TD>                        if (closingParen == -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">384</TD><TD>                                if (hasNewToken &amp;&amp; openingParen != -1)</TD></TR><TR CLASS="z"><TD CLASS="l">385</TD><TD>                                        return openingParen + 1;</TD></TR><TR><TD CLASS="l">386</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">387</TD><TD>                        }</TD></TR><TR><TD CLASS="l">388</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">389</TD><TD>                        openingParen= scanner.findOpeningPeer(closingParen - 1, '(', ')');</TD></TR><TR><TD CLASS="l">390</TD><TD> </TD></TR><TR><TD CLASS="l">391</TD><TD>                        // no way an expression at the beginning of the document can mean anything</TD></TR><TR CLASS="z"><TD CLASS="l">392</TD><TD>                        if (openingParen &lt; 1)</TD></TR><TR CLASS="z"><TD CLASS="l">393</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">394</TD><TD> </TD></TR><TR><TD CLASS="l">395</TD><TD>                        // only select insert positions for parenthesis currently embracing the caret</TD></TR><TR CLASS="z"><TD CLASS="l">396</TD><TD>                        if (openingParen &gt; pos)</TD></TR><TR CLASS="z"><TD CLASS="l">397</TD><TD>                                continue;</TD></TR><TR><TD CLASS="l">398</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">399</TD><TD>                        if (looksLikeAnonymousClassDef(document, partitioning, scanner, openingParen - 1))</TD></TR><TR CLASS="z"><TD CLASS="l">400</TD><TD>                                return closingParen + 1;</TD></TR><TR><TD CLASS="l">401</TD><TD> </TD></TR><TR><TD CLASS="l">402</TD><TD>                }</TD></TR><TR><TD CLASS="l">403</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">404</TD><TD>                return -1;</TD></TR><TR><TD CLASS="l">405</TD><TD>        }</TD></TR><TR><TD CLASS="l">406</TD><TD> </TD></TR><TR><TD CLASS="l">407</TD><TD>        /**</TD></TR><TR><TD CLASS="l">408</TD><TD>         * Finds a closing parenthesis to the left of &lt;code&gt;position&lt;/code&gt; in document, where that parenthesis is only</TD></TR><TR><TD CLASS="l">409</TD><TD>         * separated by whitespace from &lt;code&gt;position&lt;/code&gt;. If no such parenthesis can be found, &lt;code&gt;position&lt;/code&gt; is returned.</TD></TR><TR><TD CLASS="l">410</TD><TD>         * </TD></TR><TR><TD CLASS="l">411</TD><TD>         * @param scanner the java heuristic scanner set up on the document</TD></TR><TR><TD CLASS="l"><A NAME="d">412</A></TD><TD>         * @param position the first character position in &lt;code&gt;document&lt;/code&gt; to be considered</TD></TR><TR><TD CLASS="l">413</TD><TD>         * @return the position of a closing parenthesis left to &lt;code&gt;position&lt;/code&gt; separated only by whitespace, or &lt;code&gt;position&lt;/code&gt; if no parenthesis can be found</TD></TR><TR><TD CLASS="l">414</TD><TD>         */</TD></TR><TR><TD CLASS="l">415</TD><TD>        private static int findClosingParenToLeft(JavaHeuristicScanner scanner, int position) {</TD></TR><TR CLASS="z"><TD CLASS="l">416</TD><TD>                if (position &lt; 1)</TD></TR><TR CLASS="z"><TD CLASS="l">417</TD><TD>                        return position;</TD></TR><TR><TD CLASS="l">418</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">419</TD><TD>                if (scanner.previousToken(position - 1, JavaHeuristicScanner.UNBOUND) == Symbols.TokenRPAREN)</TD></TR><TR CLASS="z"><TD CLASS="l">420</TD><TD>                        return scanner.getPosition() + 1;</TD></TR><TR CLASS="z"><TD CLASS="l">421</TD><TD>                return position;</TD></TR><TR><TD CLASS="l">422</TD><TD>        }</TD></TR><TR><TD CLASS="l">423</TD><TD> </TD></TR><TR><TD CLASS="l">424</TD><TD>        /**</TD></TR><TR><TD CLASS="l">425</TD><TD>         * Checks whether the content of &lt;code&gt;document&lt;/code&gt; in the range (&lt;code&gt;offset&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;)</TD></TR><TR><TD CLASS="l">426</TD><TD>         * contains the &lt;code&gt;new&lt;/code&gt; keyword.</TD></TR><TR><TD CLASS="l">427</TD><TD>         *</TD></TR><TR><TD CLASS="l">428</TD><TD>         * @param document the document being modified</TD></TR><TR><TD CLASS="l">429</TD><TD>         * @param offset the first character position in &lt;code&gt;document&lt;/code&gt; to be considered</TD></TR><TR><TD CLASS="l">430</TD><TD>         * @param length the length of the character range to be considered</TD></TR><TR><TD CLASS="l"><A NAME="1f">431</A></TD><TD>         * @param partitioning the document partitioning</TD></TR><TR><TD CLASS="l">432</TD><TD>         * @return &lt;code&gt;true&lt;/code&gt; if the specified character range contains a &lt;code&gt;new&lt;/code&gt; keyword, &lt;code&gt;false&lt;/code&gt; otherwise.</TD></TR><TR><TD CLASS="l">433</TD><TD>         */</TD></TR><TR><TD CLASS="l">434</TD><TD>        private static boolean isNewMatch(IDocument document, int offset, int length, String partitioning) {</TD></TR><TR CLASS="z"><TD CLASS="l">435</TD><TD>                Assert.isTrue(length &gt;= 0);</TD></TR><TR CLASS="z"><TD CLASS="l">436</TD><TD>                Assert.isTrue(offset &gt;= 0);</TD></TR><TR CLASS="z"><TD CLASS="l">437</TD><TD>                Assert.isTrue(offset + length &lt; document.getLength() + 1);</TD></TR><TR><TD CLASS="l">438</TD><TD> </TD></TR><TR><TD CLASS="l">439</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">440</TD><TD>                        String text= document.get(offset, length);</TD></TR><TR CLASS="z"><TD CLASS="l">441</TD><TD>                        int pos= text.indexOf(&#34;new&#34;); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">442</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">443</TD><TD>                        while (pos != -1 &amp;&amp; !isDefaultPartition(document, pos + offset, partitioning))</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>                                pos= text.indexOf(&#34;new&#34;, pos + 2); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">445</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">446</TD><TD>                        if (pos &lt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">447</TD><TD>                                return false;</TD></TR><TR><TD CLASS="l">448</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">449</TD><TD>                        if (pos != 0 &amp;&amp; Character.isJavaIdentifierPart(text.charAt(pos - 1)))</TD></TR><TR CLASS="z"><TD CLASS="l">450</TD><TD>                                return false;</TD></TR><TR><TD CLASS="l">451</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">452</TD><TD>                        if (pos + 3 &lt; length &amp;&amp; Character.isJavaIdentifierPart(text.charAt(pos + 3)))</TD></TR><TR CLASS="z"><TD CLASS="l">453</TD><TD>                                return false;</TD></TR><TR><TD CLASS="l">454</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">455</TD><TD>                        return true;</TD></TR><TR><TD CLASS="l">456</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">457</TD><TD>                } catch (BadLocationException e) {</TD></TR><TR><TD CLASS="l">458</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">459</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">460</TD><TD>        }</TD></TR><TR><TD CLASS="l">461</TD><TD> </TD></TR><TR><TD CLASS="l">462</TD><TD>        /**</TD></TR><TR><TD CLASS="l">463</TD><TD>         * Checks whether the content of &lt;code&gt;document&lt;/code&gt; at &lt;code&gt;position&lt;/code&gt; looks like an</TD></TR><TR><TD CLASS="l">464</TD><TD>         * anonymous class definition. &lt;code&gt;position&lt;/code&gt; must be to the left of the opening</TD></TR><TR><TD CLASS="l">465</TD><TD>         * parenthesis of the definition's parameter list.</TD></TR><TR><TD CLASS="l">466</TD><TD>         *</TD></TR><TR><TD CLASS="l">467</TD><TD>         * @param document the document being modified</TD></TR><TR><TD CLASS="l">468</TD><TD>         * @param partitioning the document partitioning</TD></TR><TR><TD CLASS="l">469</TD><TD>         * @param scanner the scanner</TD></TR><TR><TD CLASS="l"><A NAME="21">470</A></TD><TD>         * @param position the first character position in &lt;code&gt;document&lt;/code&gt; to be considered</TD></TR><TR><TD CLASS="l">471</TD><TD>         * @return &lt;code&gt;true&lt;/code&gt; if the content of &lt;code&gt;document&lt;/code&gt; looks like an anonymous class definition, &lt;code&gt;false&lt;/code&gt; otherwise</TD></TR><TR><TD CLASS="l">472</TD><TD>         */</TD></TR><TR><TD CLASS="l">473</TD><TD>        private static boolean looksLikeAnonymousClassDef(IDocument document, String partitioning, JavaHeuristicScanner scanner, int position) {</TD></TR><TR CLASS="z"><TD CLASS="l">474</TD><TD>                int previousCommaParenEqual= scanner.scanBackward(position - 1, JavaHeuristicScanner.UNBOUND, new char[] {',', '(', '='});</TD></TR><TR CLASS="z"><TD CLASS="l">475</TD><TD>                if (previousCommaParenEqual == -1 || position &lt; previousCommaParenEqual + 5) // 2 for borders, 3 for &#34;new&#34;</TD></TR><TR CLASS="z"><TD CLASS="l">476</TD><TD>                        return false;</TD></TR><TR><TD CLASS="l">477</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">478</TD><TD>                if (isNewMatch(document, previousCommaParenEqual + 1, position - previousCommaParenEqual - 2, partitioning))</TD></TR><TR CLASS="z"><TD CLASS="l">479</TD><TD>                        return true;</TD></TR><TR><TD CLASS="l">480</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">481</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">482</TD><TD>        }</TD></TR><TR><TD CLASS="l">483</TD><TD> </TD></TR><TR><TD CLASS="l">484</TD><TD>        /**</TD></TR><TR><TD CLASS="l">485</TD><TD>         * Checks whether &lt;code&gt;position&lt;/code&gt; resides in a default (Java) partition of &lt;code&gt;document&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">486</TD><TD>         *</TD></TR><TR><TD CLASS="l">487</TD><TD>         * @param document the document being modified</TD></TR><TR><TD CLASS="l">488</TD><TD>         * @param position the position to be checked</TD></TR><TR><TD CLASS="l"><A NAME="1c">489</A></TD><TD>         * @param partitioning the document partitioning</TD></TR><TR><TD CLASS="l">490</TD><TD>         * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;position&lt;/code&gt; is in the default partition of &lt;code&gt;document&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise</TD></TR><TR><TD CLASS="l">491</TD><TD>         */</TD></TR><TR><TD CLASS="l">492</TD><TD>        private static boolean isDefaultPartition(IDocument document, int position, String partitioning) {</TD></TR><TR CLASS="z"><TD CLASS="l">493</TD><TD>                Assert.isTrue(position &gt;= 0);</TD></TR><TR CLASS="z"><TD CLASS="l">494</TD><TD>                Assert.isTrue(position &lt;= document.getLength());</TD></TR><TR><TD CLASS="l">495</TD><TD> </TD></TR><TR><TD CLASS="l">496</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">497</TD><TD>                        ITypedRegion region= TextUtilities.getPartition(document, partitioning, position, false);</TD></TR><TR CLASS="z"><TD CLASS="l">498</TD><TD>                        return region.getType().equals(IDocument.DEFAULT_CONTENT_TYPE);</TD></TR><TR><TD CLASS="l">499</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">500</TD><TD>                } catch (BadLocationException e) {</TD></TR><TR><TD CLASS="l">501</TD><TD>                }</TD></TR><TR><TD CLASS="l">502</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">503</TD><TD>                return false;</TD></TR><TR><TD CLASS="l"><A NAME="1b">504</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">505</TD><TD> </TD></TR><TR><TD CLASS="l">506</TD><TD>        private boolean isClosed(IDocument document, int offset, int length) {</TD></TR><TR><TD CLASS="l">507</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">508</TD><TD>                CompilationUnitInfo info= getCompilationUnitForMethod(document, offset);</TD></TR><TR CLASS="z"><TD CLASS="l">509</TD><TD>                if (info == null)</TD></TR><TR CLASS="z"><TD CLASS="l">510</TD><TD>                        return false;</TD></TR><TR><TD CLASS="l">511</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">512</TD><TD>                JavaScriptUnit compilationUnit= null;</TD></TR><TR><TD CLASS="l">513</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">514</TD><TD>                        ASTParser parser= ASTParser.newParser(AST.JLS3);</TD></TR><TR CLASS="z"><TD CLASS="l">515</TD><TD>                        parser.setSource(info.buffer);</TD></TR><TR CLASS="z"><TD CLASS="l">516</TD><TD>                        compilationUnit= (JavaScriptUnit) parser.createAST(null);</TD></TR><TR CLASS="z"><TD CLASS="l">517</TD><TD>                } catch (ArrayIndexOutOfBoundsException x) {</TD></TR><TR><TD CLASS="l">518</TD><TD>                        // work around for parser problem</TD></TR><TR CLASS="z"><TD CLASS="l">519</TD><TD>                        return false;</TD></TR><TR><TD CLASS="l">520</TD><TD>                }</TD></TR><TR><TD CLASS="l">521</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">522</TD><TD>                IProblem[] problems= compilationUnit.getProblems();</TD></TR><TR CLASS="z"><TD CLASS="l">523</TD><TD>                for (int i= 0; i != problems.length; ++i) {</TD></TR><TR CLASS="z"><TD CLASS="l">524</TD><TD>                        if (problems[i].getID() == IProblem.UnmatchedBracket)</TD></TR><TR CLASS="z"><TD CLASS="l">525</TD><TD>                                return true;</TD></TR><TR><TD CLASS="l">526</TD><TD>                }</TD></TR><TR><TD CLASS="l">527</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">528</TD><TD>                final int relativeOffset= offset - info.delta;</TD></TR><TR><TD CLASS="l">529</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">530</TD><TD>                ASTNode node= NodeFinder.perform(compilationUnit, relativeOffset, length);</TD></TR><TR><TD CLASS="l">531</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>                if (length == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">533</TD><TD>                        while (node != null &amp;&amp; (relativeOffset == node.getStartPosition() || relativeOffset == node.getStartPosition() + node.getLength()))</TD></TR><TR CLASS="z"><TD CLASS="l">534</TD><TD>                                node= node.getParent();</TD></TR><TR><TD CLASS="l">535</TD><TD>                }</TD></TR><TR><TD CLASS="l">536</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">537</TD><TD>                if (node == null)</TD></TR><TR CLASS="z"><TD CLASS="l">538</TD><TD>                        return false;</TD></TR><TR><TD CLASS="l">539</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">540</TD><TD>                switch (node.getNodeType()) {</TD></TR><TR><TD CLASS="l">541</TD><TD>                        case ASTNode.BLOCK:</TD></TR><TR CLASS="z"><TD CLASS="l">542</TD><TD>                                return getBlockBalance(document, offset, fPartitioning) &lt;= 0;</TD></TR><TR><TD CLASS="l">543</TD><TD> </TD></TR><TR><TD CLASS="l">544</TD><TD>                        case ASTNode.IF_STATEMENT:</TD></TR><TR><TD CLASS="l">545</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">546</TD><TD>                                IfStatement ifStatement= (IfStatement) node;</TD></TR><TR CLASS="z"><TD CLASS="l">547</TD><TD>                                Expression expression= ifStatement.getExpression();</TD></TR><TR CLASS="z"><TD CLASS="l">548</TD><TD>                                IRegion expressionRegion= createRegion(expression, info.delta);</TD></TR><TR CLASS="z"><TD CLASS="l">549</TD><TD>                                Statement thenStatement= ifStatement.getThenStatement();</TD></TR><TR CLASS="z"><TD CLASS="l">550</TD><TD>                                IRegion thenRegion= createRegion(thenStatement, info.delta);</TD></TR><TR><TD CLASS="l">551</TD><TD> </TD></TR><TR><TD CLASS="l">552</TD><TD>                                // between expression and then statement</TD></TR><TR CLASS="z"><TD CLASS="l">553</TD><TD>                                if (expressionRegion.getOffset() + expressionRegion.getLength() &lt;= offset &amp;&amp; offset + length &lt;= thenRegion.getOffset())</TD></TR><TR CLASS="z"><TD CLASS="l">554</TD><TD>                                        return thenStatement != null;</TD></TR><TR><TD CLASS="l">555</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">556</TD><TD>                                Statement elseStatement= ifStatement.getElseStatement();</TD></TR><TR CLASS="z"><TD CLASS="l">557</TD><TD>                                IRegion elseRegion= createRegion(elseStatement, info.delta);</TD></TR><TR><TD CLASS="l">558</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">559</TD><TD>                                if (elseStatement != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">560</TD><TD>                                        int sourceOffset= thenRegion.getOffset() + thenRegion.getLength();</TD></TR><TR CLASS="z"><TD CLASS="l">561</TD><TD>                                        int sourceLength= elseRegion.getOffset() - sourceOffset;</TD></TR><TR CLASS="z"><TD CLASS="l">562</TD><TD>                                        IRegion elseToken= getToken(document, new Region(sourceOffset, sourceLength), ITerminalSymbols.TokenNameelse);</TD></TR><TR CLASS="z"><TD CLASS="l">563</TD><TD>                                        return elseToken != null &amp;&amp; elseToken.getOffset() + elseToken.getLength() &lt;= offset &amp;&amp; offset + length &lt; elseRegion.getOffset();</TD></TR><TR><TD CLASS="l">564</TD><TD>                                }</TD></TR><TR><TD CLASS="l">565</TD><TD>                        }</TD></TR><TR><TD CLASS="l">566</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">567</TD><TD> </TD></TR><TR><TD CLASS="l">568</TD><TD>                        case ASTNode.WHILE_STATEMENT:</TD></TR><TR><TD CLASS="l">569</TD><TD>                        case ASTNode.FOR_STATEMENT:</TD></TR><TR><TD CLASS="l">570</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">571</TD><TD>                                Expression expression= node.getNodeType() == ASTNode.WHILE_STATEMENT ? ((WhileStatement) node).getExpression() : ((ForStatement) node).getExpression();</TD></TR><TR CLASS="z"><TD CLASS="l">572</TD><TD>                                IRegion expressionRegion= createRegion(expression, info.delta);</TD></TR><TR CLASS="z"><TD CLASS="l">573</TD><TD>                                Statement body= node.getNodeType() == ASTNode.WHILE_STATEMENT ? ((WhileStatement) node).getBody() : ((ForStatement) node).getBody();</TD></TR><TR CLASS="z"><TD CLASS="l">574</TD><TD>                                IRegion bodyRegion= createRegion(body, info.delta);</TD></TR><TR><TD CLASS="l">575</TD><TD> </TD></TR><TR><TD CLASS="l">576</TD><TD>                                // between expression and body statement</TD></TR><TR CLASS="z"><TD CLASS="l">577</TD><TD>                                if (expressionRegion.getOffset() + expressionRegion.getLength() &lt;= offset &amp;&amp; offset + length &lt;= bodyRegion.getOffset())</TD></TR><TR CLASS="z"><TD CLASS="l">578</TD><TD>                                        return body != null;</TD></TR><TR><TD CLASS="l">579</TD><TD>                        }</TD></TR><TR><TD CLASS="l">580</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">581</TD><TD> </TD></TR><TR><TD CLASS="l">582</TD><TD>                        case ASTNode.DO_STATEMENT:</TD></TR><TR><TD CLASS="l">583</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">584</TD><TD>                                DoStatement doStatement= (DoStatement) node;</TD></TR><TR CLASS="z"><TD CLASS="l">585</TD><TD>                                IRegion doRegion= createRegion(doStatement, info.delta);</TD></TR><TR CLASS="z"><TD CLASS="l">586</TD><TD>                                Statement body= doStatement.getBody();</TD></TR><TR CLASS="z"><TD CLASS="l">587</TD><TD>                                IRegion bodyRegion= createRegion(body, info.delta);</TD></TR><TR><TD CLASS="l">588</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">589</TD><TD>                                if (doRegion.getOffset() + doRegion.getLength() &lt;= offset &amp;&amp; offset + length &lt;= bodyRegion.getOffset())</TD></TR><TR CLASS="z"><TD CLASS="l">590</TD><TD>                                        return body != null;</TD></TR><TR><TD CLASS="l">591</TD><TD>                        }</TD></TR><TR><TD CLASS="l">592</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">593</TD><TD>                }</TD></TR><TR><TD CLASS="l">594</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">595</TD><TD>                return true;</TD></TR><TR><TD CLASS="l">596</TD><TD>        }</TD></TR><TR><TD CLASS="l">597</TD><TD> </TD></TR><TR><TD CLASS="l">598</TD><TD>        /**</TD></TR><TR><TD CLASS="l">599</TD><TD>         * Installs a java partitioner with &lt;code&gt;document&lt;/code&gt;.</TD></TR><TR><TD CLASS="l"><A NAME="1a">600</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">601</TD><TD>         * @param document the document</TD></TR><TR><TD CLASS="l">602</TD><TD>         */</TD></TR><TR><TD CLASS="l">603</TD><TD>        private static void installJavaStuff(Document document) {</TD></TR><TR CLASS="z"><TD CLASS="l">604</TD><TD>                String[] types= new String[] {</TD></TR><TR CLASS="z"><TD CLASS="l">605</TD><TD>                                                                          IJavaScriptPartitions.JAVA_DOC,</TD></TR><TR CLASS="z"><TD CLASS="l">606</TD><TD>                                                                          IJavaScriptPartitions.JAVA_MULTI_LINE_COMMENT,</TD></TR><TR CLASS="z"><TD CLASS="l">607</TD><TD>                                                                          IJavaScriptPartitions.JAVA_SINGLE_LINE_COMMENT,</TD></TR><TR CLASS="z"><TD CLASS="l">608</TD><TD>                                                                          IJavaScriptPartitions.JAVA_STRING,</TD></TR><TR CLASS="z"><TD CLASS="l">609</TD><TD>                                                                          IJavaScriptPartitions.JAVA_CHARACTER,</TD></TR><TR CLASS="z"><TD CLASS="l">610</TD><TD>                                                                          IDocument.DEFAULT_CONTENT_TYPE</TD></TR><TR><TD CLASS="l">611</TD><TD>                };</TD></TR><TR CLASS="z"><TD CLASS="l">612</TD><TD>                FastPartitioner partitioner= new FastPartitioner(new FastJavaPartitionScanner(), types);</TD></TR><TR CLASS="z"><TD CLASS="l">613</TD><TD>                partitioner.connect(document);</TD></TR><TR CLASS="z"><TD CLASS="l">614</TD><TD>                document.setDocumentPartitioner(IJavaScriptPartitions.JAVA_PARTITIONING, partitioner);</TD></TR><TR CLASS="z"><TD CLASS="l">615</TD><TD>        }</TD></TR><TR><TD CLASS="l">616</TD><TD> </TD></TR><TR><TD CLASS="l">617</TD><TD>        /**</TD></TR><TR><TD CLASS="l">618</TD><TD>         * Installs a java partitioner with &lt;code&gt;document&lt;/code&gt;.</TD></TR><TR><TD CLASS="l"><A NAME="22">619</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">620</TD><TD>         * @param document the document</TD></TR><TR><TD CLASS="l">621</TD><TD>         */</TD></TR><TR><TD CLASS="l">622</TD><TD>        private static void removeJavaStuff(Document document) {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="29">623</A></TD><TD>                document.setDocumentPartitioner(IJavaScriptPartitions.JAVA_PARTITIONING, null);</TD></TR><TR CLASS="z"><TD CLASS="l">624</TD><TD>        }</TD></TR><TR><TD CLASS="l">625</TD><TD> </TD></TR><TR><TD CLASS="l">626</TD><TD>        private void smartPaste(IDocument document, DocumentCommand command) {</TD></TR><TR CLASS="z"><TD CLASS="l">627</TD><TD>                int newOffset= command.offset;</TD></TR><TR CLASS="z"><TD CLASS="l">628</TD><TD>                int newLength= command.length;</TD></TR><TR CLASS="z"><TD CLASS="l">629</TD><TD>                String newText= command.text;</TD></TR><TR><TD CLASS="l">630</TD><TD> </TD></TR><TR><TD CLASS="l">631</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">632</TD><TD>                        JavaHeuristicScanner scanner= new JavaHeuristicScanner(document);</TD></TR><TR CLASS="z"><TD CLASS="l">633</TD><TD>                        JavaIndenter indenter= new JavaIndenter(document, scanner, fProject);</TD></TR><TR CLASS="z"><TD CLASS="l">634</TD><TD>                        int offset= newOffset;</TD></TR><TR><TD CLASS="l">635</TD><TD> </TD></TR><TR><TD CLASS="l">636</TD><TD>                        // reference position to get the indent from</TD></TR><TR CLASS="z"><TD CLASS="l">637</TD><TD>                        int refOffset= indenter.findReferencePosition(offset);</TD></TR><TR CLASS="z"><TD CLASS="l">638</TD><TD>                        if (refOffset == JavaHeuristicScanner.NOT_FOUND)</TD></TR><TR CLASS="z"><TD CLASS="l">639</TD><TD>                                return;</TD></TR><TR CLASS="z"><TD CLASS="l">640</TD><TD>                        int peerOffset= getPeerPosition(document, command);</TD></TR><TR CLASS="z"><TD CLASS="l">641</TD><TD>                        peerOffset= indenter.findReferencePosition(peerOffset);</TD></TR><TR CLASS="z"><TD CLASS="l">642</TD><TD>                        refOffset= Math.min(refOffset, peerOffset);</TD></TR><TR><TD CLASS="l">643</TD><TD> </TD></TR><TR><TD CLASS="l">644</TD><TD>                        // eat any WS before the insertion to the beginning of the line</TD></TR><TR CLASS="z"><TD CLASS="l">645</TD><TD>                        int firstLine= 1; // don't format the first line per default, as it has other content before it</TD></TR><TR CLASS="z"><TD CLASS="l">646</TD><TD>                        IRegion line= document.getLineInformationOfOffset(offset);</TD></TR><TR CLASS="z"><TD CLASS="l">647</TD><TD>                        String notSelected= document.get(line.getOffset(), offset - line.getOffset());</TD></TR><TR CLASS="z"><TD CLASS="l">648</TD><TD>                        if (notSelected.trim().length() == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">649</TD><TD>                                newLength += notSelected.length();</TD></TR><TR CLASS="z"><TD CLASS="l">650</TD><TD>                                newOffset= line.getOffset();</TD></TR><TR CLASS="z"><TD CLASS="l">651</TD><TD>                                firstLine= 0;</TD></TR><TR><TD CLASS="l">652</TD><TD>                        }</TD></TR><TR><TD CLASS="l">653</TD><TD> </TD></TR><TR><TD CLASS="l">654</TD><TD>                        // prefix: the part we need for formatting but won't paste</TD></TR><TR CLASS="z"><TD CLASS="l">655</TD><TD>                        IRegion refLine= document.getLineInformationOfOffset(refOffset);</TD></TR><TR CLASS="z"><TD CLASS="l">656</TD><TD>                        String prefix= document.get(refLine.getOffset(), newOffset - refLine.getOffset());</TD></TR><TR><TD CLASS="l">657</TD><TD> </TD></TR><TR><TD CLASS="l">658</TD><TD>                        // handle the indentation computation inside a temporary document</TD></TR><TR CLASS="z"><TD CLASS="l">659</TD><TD>                        Document temp= new Document(prefix + newText);</TD></TR><TR CLASS="z"><TD CLASS="l">660</TD><TD>                        DocumentRewriteSession session= temp.startRewriteSession(DocumentRewriteSessionType.STRICTLY_SEQUENTIAL);</TD></TR><TR CLASS="z"><TD CLASS="l">661</TD><TD>                        scanner= new JavaHeuristicScanner(temp);</TD></TR><TR CLASS="z"><TD CLASS="l">662</TD><TD>                        indenter= new JavaIndenter(temp, scanner, fProject);</TD></TR><TR CLASS="z"><TD CLASS="l">663</TD><TD>                        installJavaStuff(temp);</TD></TR><TR><TD CLASS="l">664</TD><TD> </TD></TR><TR><TD CLASS="l">665</TD><TD>                        // indent the first and second line</TD></TR><TR><TD CLASS="l">666</TD><TD>                        // compute the relative indentation difference from the second line</TD></TR><TR><TD CLASS="l">667</TD><TD>                        // (as the first might be partially selected) and use the value to</TD></TR><TR><TD CLASS="l">668</TD><TD>                        // indent all other lines.</TD></TR><TR CLASS="z"><TD CLASS="l">669</TD><TD>                        boolean isIndentDetected= false;</TD></TR><TR CLASS="z"><TD CLASS="l">670</TD><TD>                        StringBuffer addition= new StringBuffer();</TD></TR><TR CLASS="z"><TD CLASS="l">671</TD><TD>                        int insertLength= 0;</TD></TR><TR CLASS="z"><TD CLASS="l">672</TD><TD>                        int first= document.computeNumberOfLines(prefix) + firstLine; // don't format first line</TD></TR><TR CLASS="z"><TD CLASS="l">673</TD><TD>                        int lines= temp.getNumberOfLines();</TD></TR><TR CLASS="z"><TD CLASS="l">674</TD><TD>                        int tabLength= getVisualTabLengthPreference();</TD></TR><TR CLASS="z"><TD CLASS="l">675</TD><TD>                        boolean changed= false;</TD></TR><TR CLASS="z"><TD CLASS="l">676</TD><TD>                        for (int l= first; l &lt; lines; l++) { // we don't change the number of lines while adding indents</TD></TR><TR><TD CLASS="l">677</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">678</TD><TD>                                IRegion r= temp.getLineInformation(l);</TD></TR><TR CLASS="z"><TD CLASS="l">679</TD><TD>                                int lineOffset= r.getOffset();</TD></TR><TR CLASS="z"><TD CLASS="l">680</TD><TD>                                int lineLength= r.getLength();</TD></TR><TR><TD CLASS="l">681</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">682</TD><TD>                                if (lineLength == 0) // don't modify empty lines</TD></TR><TR CLASS="z"><TD CLASS="l">683</TD><TD>                                        continue;</TD></TR><TR><TD CLASS="l">684</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">685</TD><TD>                                if (!isIndentDetected) {</TD></TR><TR><TD CLASS="l">686</TD><TD> </TD></TR><TR><TD CLASS="l">687</TD><TD>                                        // indent the first pasted line</TD></TR><TR CLASS="z"><TD CLASS="l">688</TD><TD>                                        String current= getCurrentIndent(temp, l);</TD></TR><TR CLASS="z"><TD CLASS="l">689</TD><TD>                                        StringBuffer correct= indenter.computeIndentation(lineOffset);</TD></TR><TR CLASS="z"><TD CLASS="l">690</TD><TD>                                        if (correct == null)</TD></TR><TR CLASS="z"><TD CLASS="l">691</TD><TD>                                                return; // bail out</TD></TR><TR><TD CLASS="l">692</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">693</TD><TD>                                        insertLength= subtractIndent(correct, current, addition, tabLength);</TD></TR><TR CLASS="z"><TD CLASS="l">694</TD><TD>                                        if (l != first &amp;&amp; temp.get(lineOffset, lineLength).trim().length() != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">695</TD><TD>                                                isIndentDetected= true;</TD></TR><TR CLASS="z"><TD CLASS="l">696</TD><TD>                                                if (insertLength == 0) {</TD></TR><TR><TD CLASS="l">697</TD><TD>                                                         // no adjustment needed, bail out</TD></TR><TR CLASS="z"><TD CLASS="l">698</TD><TD>                                                        if (firstLine == 0) {</TD></TR><TR><TD CLASS="l">699</TD><TD>                                                                // but we still need to adjust the first line</TD></TR><TR CLASS="z"><TD CLASS="l">700</TD><TD>                                                                command.offset= newOffset;</TD></TR><TR CLASS="z"><TD CLASS="l">701</TD><TD>                                                                command.length= newLength;</TD></TR><TR CLASS="z"><TD CLASS="l">702</TD><TD>                                                                if (changed)</TD></TR><TR CLASS="z"><TD CLASS="l">703</TD><TD>                                                                        break; // still need to get the leading indent of the first line</TD></TR><TR><TD CLASS="l">704</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">705</TD><TD>                                                        return;</TD></TR><TR><TD CLASS="l">706</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">707</TD><TD>                                                removeJavaStuff(temp);</TD></TR><TR><TD CLASS="l">708</TD><TD>                                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">709</TD><TD>                                                changed= insertLength != 0;</TD></TR><TR><TD CLASS="l">710</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">711</TD><TD>                                }</TD></TR><TR><TD CLASS="l">712</TD><TD> </TD></TR><TR><TD CLASS="l">713</TD><TD>                                // relatively indent all pasted lines</TD></TR><TR CLASS="z"><TD CLASS="l">714</TD><TD>                                if (insertLength &gt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">715</TD><TD>                                        addIndent(temp, l, addition, tabLength);</TD></TR><TR CLASS="z"><TD CLASS="l">716</TD><TD>                                else if (insertLength &lt; 0)</TD></TR><TR CLASS="z"><TD CLASS="l">717</TD><TD>                                        cutIndent(temp, l, -insertLength, tabLength);</TD></TR><TR><TD CLASS="l">718</TD><TD> </TD></TR><TR><TD CLASS="l">719</TD><TD>                        }</TD></TR><TR><TD CLASS="l">720</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">721</TD><TD>                        temp.stopRewriteSession(session);</TD></TR><TR CLASS="z"><TD CLASS="l">722</TD><TD>                        newText= temp.get(prefix.length(), temp.getLength() - prefix.length());</TD></TR><TR><TD CLASS="l">723</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">724</TD><TD>                        command.offset= newOffset;</TD></TR><TR CLASS="z"><TD CLASS="l">725</TD><TD>                        command.length= newLength;</TD></TR><TR CLASS="z"><TD CLASS="l">726</TD><TD>                        command.text= newText;</TD></TR><TR><TD CLASS="l">727</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">728</TD><TD>                } catch (BadLocationException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">729</TD><TD>                        JavaScriptPlugin.log(e);</TD></TR><TR><TD CLASS="l">730</TD><TD>                }</TD></TR><TR><TD CLASS="l">731</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">732</TD><TD>        }</TD></TR><TR><TD CLASS="l">733</TD><TD> </TD></TR><TR><TD CLASS="l">734</TD><TD>        /**</TD></TR><TR><TD CLASS="l">735</TD><TD>         * Returns the indentation of the line &lt;code&gt;line&lt;/code&gt; in &lt;code&gt;document&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">736</TD><TD>         * The returned string may contain pairs of leading slashes that are considered</TD></TR><TR><TD CLASS="l">737</TD><TD>         * part of the indentation. The space before the asterisk in a javadoc-like</TD></TR><TR><TD CLASS="l">738</TD><TD>         * comment is not considered part of the indentation.</TD></TR><TR><TD CLASS="l">739</TD><TD>         *</TD></TR><TR><TD CLASS="l">740</TD><TD>         * @param document the document</TD></TR><TR><TD CLASS="l">741</TD><TD>         * @param line the line</TD></TR><TR><TD CLASS="l"><A NAME="13">742</A></TD><TD>         * @return the indentation of &lt;code&gt;line&lt;/code&gt; in &lt;code&gt;document&lt;/code&gt;</TD></TR><TR><TD CLASS="l">743</TD><TD>         * @throws BadLocationException if the document is changed concurrently</TD></TR><TR><TD CLASS="l">744</TD><TD>         */</TD></TR><TR><TD CLASS="l">745</TD><TD>        private static String getCurrentIndent(Document document, int line) throws BadLocationException {</TD></TR><TR CLASS="z"><TD CLASS="l">746</TD><TD>                IRegion region= document.getLineInformation(line);</TD></TR><TR CLASS="z"><TD CLASS="l">747</TD><TD>                int from= region.getOffset();</TD></TR><TR CLASS="z"><TD CLASS="l">748</TD><TD>                int endOffset= region.getOffset() + region.getLength();</TD></TR><TR><TD CLASS="l">749</TD><TD> </TD></TR><TR><TD CLASS="l">750</TD><TD>                // go behind line comments</TD></TR><TR CLASS="z"><TD CLASS="l">751</TD><TD>                int to= from;</TD></TR><TR CLASS="z"><TD CLASS="l">752</TD><TD>                while (to &lt; endOffset - 2 &amp;&amp; document.get(to, 2).equals(LINE_COMMENT))</TD></TR><TR CLASS="z"><TD CLASS="l">753</TD><TD>                        to += 2;</TD></TR><TR><TD CLASS="l">754</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">755</TD><TD>                while (to &lt; endOffset) {</TD></TR><TR CLASS="z"><TD CLASS="l">756</TD><TD>                        char ch= document.getChar(to);</TD></TR><TR CLASS="z"><TD CLASS="l">757</TD><TD>                        if (!Character.isWhitespace(ch))</TD></TR><TR CLASS="z"><TD CLASS="l">758</TD><TD>                                break;</TD></TR><TR CLASS="z"><TD CLASS="l">759</TD><TD>                        to++;</TD></TR><TR><TD CLASS="l">760</TD><TD>                }</TD></TR><TR><TD CLASS="l">761</TD><TD> </TD></TR><TR><TD CLASS="l">762</TD><TD>                // don't count the space before javadoc like, asterisk-style comment lines</TD></TR><TR CLASS="z"><TD CLASS="l">763</TD><TD>                if (to &gt; from &amp;&amp; to &lt; endOffset - 1 &amp;&amp; document.get(to - 1, 2).equals(&#34; *&#34;)) { //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">764</TD><TD>                        String type= TextUtilities.getContentType(document, IJavaScriptPartitions.JAVA_PARTITIONING, to, true);</TD></TR><TR CLASS="z"><TD CLASS="l">765</TD><TD>                        if (type.equals(IJavaScriptPartitions.JAVA_DOC) || type.equals(IJavaScriptPartitions.JAVA_MULTI_LINE_COMMENT))</TD></TR><TR CLASS="z"><TD CLASS="l">766</TD><TD>                                to--;</TD></TR><TR><TD CLASS="l">767</TD><TD>                }</TD></TR><TR><TD CLASS="l">768</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">769</TD><TD>                return document.get(from, to - from);</TD></TR><TR><TD CLASS="l">770</TD><TD>        }</TD></TR><TR><TD CLASS="l">771</TD><TD> </TD></TR><TR><TD CLASS="l">772</TD><TD>        /**</TD></TR><TR><TD CLASS="l">773</TD><TD>         * Computes the difference of two indentations and returns the difference in</TD></TR><TR><TD CLASS="l">774</TD><TD>         * length of current and correct. If the return value is positive, &lt;code&gt;addition&lt;/code&gt;</TD></TR><TR><TD CLASS="l">775</TD><TD>         * is initialized with a substring of that length of &lt;code&gt;correct&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">776</TD><TD>         *</TD></TR><TR><TD CLASS="l">777</TD><TD>         * @param correct the correct indentation</TD></TR><TR><TD CLASS="l">778</TD><TD>         * @param current the current indentation (might contain non-whitespace)</TD></TR><TR><TD CLASS="l">779</TD><TD>         * @param difference a string buffer - if the return value is positive, it will be cleared and set to the substring of &lt;code&gt;current&lt;/code&gt; of that length</TD></TR><TR><TD CLASS="l"><A NAME="2a">780</A></TD><TD>         * @param tabLength the length of a tab</TD></TR><TR><TD CLASS="l">781</TD><TD>         * @return the difference in length of &lt;code&gt;correct&lt;/code&gt; and &lt;code&gt;current&lt;/code&gt;</TD></TR><TR><TD CLASS="l">782</TD><TD>         */</TD></TR><TR><TD CLASS="l">783</TD><TD>        private int subtractIndent(CharSequence correct, CharSequence current, StringBuffer difference, int tabLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">784</TD><TD>                int c1= computeVisualLength(correct, tabLength);</TD></TR><TR CLASS="z"><TD CLASS="l">785</TD><TD>                int c2= computeVisualLength(current, tabLength);</TD></TR><TR CLASS="z"><TD CLASS="l">786</TD><TD>                int diff= c1 - c2;</TD></TR><TR CLASS="z"><TD CLASS="l">787</TD><TD>                if (diff &lt;= 0)</TD></TR><TR CLASS="z"><TD CLASS="l">788</TD><TD>                        return diff;</TD></TR><TR><TD CLASS="l">789</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">790</TD><TD>                difference.setLength(0);</TD></TR><TR CLASS="z"><TD CLASS="l">791</TD><TD>                int len= 0, i= 0;</TD></TR><TR CLASS="z"><TD CLASS="l">792</TD><TD>                while (len &lt; diff) {</TD></TR><TR CLASS="z"><TD CLASS="l">793</TD><TD>                        char c= correct.charAt(i++);</TD></TR><TR CLASS="z"><TD CLASS="l">794</TD><TD>                        difference.append(c);</TD></TR><TR CLASS="z"><TD CLASS="l">795</TD><TD>                        len += computeVisualLength(c, tabLength);</TD></TR><TR><TD CLASS="l">796</TD><TD>                }</TD></TR><TR><TD CLASS="l">797</TD><TD> </TD></TR><TR><TD CLASS="l">798</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">799</TD><TD>                return diff;</TD></TR><TR><TD CLASS="l">800</TD><TD>        }</TD></TR><TR><TD CLASS="l">801</TD><TD> </TD></TR><TR><TD CLASS="l">802</TD><TD>        /**</TD></TR><TR><TD CLASS="l">803</TD><TD>         * Indents line &lt;code&gt;line&lt;/code&gt; in &lt;code&gt;document&lt;/code&gt; with &lt;code&gt;indent&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">804</TD><TD>         * Leaves leading comment signs alone.</TD></TR><TR><TD CLASS="l">805</TD><TD>         *</TD></TR><TR><TD CLASS="l">806</TD><TD>         * @param document the document</TD></TR><TR><TD CLASS="l">807</TD><TD>         * @param line the line</TD></TR><TR><TD CLASS="l">808</TD><TD>         * @param indent the indentation to insert</TD></TR><TR><TD CLASS="l"><A NAME="3">809</A></TD><TD>         * @param tabLength the length of a tab</TD></TR><TR><TD CLASS="l">810</TD><TD>         * @throws BadLocationException on concurrent document modification</TD></TR><TR><TD CLASS="l">811</TD><TD>         */</TD></TR><TR><TD CLASS="l">812</TD><TD>        private void addIndent(Document document, int line, CharSequence indent, int tabLength) throws BadLocationException {</TD></TR><TR CLASS="z"><TD CLASS="l">813</TD><TD>                IRegion region= document.getLineInformation(line);</TD></TR><TR CLASS="z"><TD CLASS="l">814</TD><TD>                int insert= region.getOffset();</TD></TR><TR CLASS="z"><TD CLASS="l">815</TD><TD>                int endOffset= region.getOffset() + region.getLength();</TD></TR><TR><TD CLASS="l">816</TD><TD> </TD></TR><TR><TD CLASS="l">817</TD><TD>                // Compute insert after all leading line comment markers</TD></TR><TR CLASS="z"><TD CLASS="l">818</TD><TD>                int newInsert= insert;</TD></TR><TR CLASS="z"><TD CLASS="l">819</TD><TD>                while (newInsert &lt; endOffset - 2 &amp;&amp; document.get(newInsert, 2).equals(LINE_COMMENT))</TD></TR><TR CLASS="z"><TD CLASS="l">820</TD><TD>                        newInsert += 2;</TD></TR><TR><TD CLASS="l">821</TD><TD> </TD></TR><TR><TD CLASS="l">822</TD><TD>                // Heuristic to check whether it is commented code or just a comment</TD></TR><TR CLASS="z"><TD CLASS="l">823</TD><TD>                if (newInsert &gt; insert) {</TD></TR><TR CLASS="z"><TD CLASS="l">824</TD><TD>                        int whitespaceCount= 0;</TD></TR><TR CLASS="z"><TD CLASS="l">825</TD><TD>                        int i= newInsert;</TD></TR><TR CLASS="z"><TD CLASS="l">826</TD><TD>                        while (i &lt; endOffset - 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">827</TD><TD>                                 char ch= document.get(i, 1).charAt(0);</TD></TR><TR CLASS="z"><TD CLASS="l">828</TD><TD>                                 if (!Character.isWhitespace(ch))</TD></TR><TR CLASS="z"><TD CLASS="l">829</TD><TD>                                         break;</TD></TR><TR CLASS="z"><TD CLASS="l">830</TD><TD>                                 whitespaceCount= whitespaceCount + computeVisualLength(ch, tabLength);</TD></TR><TR CLASS="z"><TD CLASS="l">831</TD><TD>                                 i++;</TD></TR><TR><TD CLASS="l">832</TD><TD>                        }</TD></TR><TR><TD CLASS="l">833</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">834</TD><TD>                        if (whitespaceCount != 0 &amp;&amp; whitespaceCount &gt;= CodeFormatterUtil.getIndentWidth(fProject))</TD></TR><TR CLASS="z"><TD CLASS="l">835</TD><TD>                                insert= newInsert;</TD></TR><TR><TD CLASS="l">836</TD><TD>                }</TD></TR><TR><TD CLASS="l">837</TD><TD> </TD></TR><TR><TD CLASS="l">838</TD><TD>                // Insert indent</TD></TR><TR CLASS="z"><TD CLASS="l">839</TD><TD>                document.replace(insert, 0, indent.toString());</TD></TR><TR CLASS="z"><TD CLASS="l">840</TD><TD>        }</TD></TR><TR><TD CLASS="l">841</TD><TD> </TD></TR><TR><TD CLASS="l">842</TD><TD>        /**</TD></TR><TR><TD CLASS="l">843</TD><TD>         * Cuts the visual equivalent of &lt;code&gt;toDelete&lt;/code&gt; characters out of the</TD></TR><TR><TD CLASS="l">844</TD><TD>         * indentation of line &lt;code&gt;line&lt;/code&gt; in &lt;code&gt;document&lt;/code&gt;. Leaves</TD></TR><TR><TD CLASS="l">845</TD><TD>         * leading comment signs alone.</TD></TR><TR><TD CLASS="l">846</TD><TD>         *</TD></TR><TR><TD CLASS="l">847</TD><TD>         * @param document the document</TD></TR><TR><TD CLASS="l">848</TD><TD>         * @param line the line</TD></TR><TR><TD CLASS="l">849</TD><TD>         * @param toDelete the number of space equivalents to delete</TD></TR><TR><TD CLASS="l"><A NAME="c">850</A></TD><TD>         * @param tabLength the length of a tab</TD></TR><TR><TD CLASS="l">851</TD><TD>         * @throws BadLocationException on concurrent document modification</TD></TR><TR><TD CLASS="l">852</TD><TD>         */</TD></TR><TR><TD CLASS="l">853</TD><TD>        private void cutIndent(Document document, int line, int toDelete, int tabLength) throws BadLocationException {</TD></TR><TR CLASS="z"><TD CLASS="l">854</TD><TD>                IRegion region= document.getLineInformation(line);</TD></TR><TR CLASS="z"><TD CLASS="l">855</TD><TD>                int from= region.getOffset();</TD></TR><TR CLASS="z"><TD CLASS="l">856</TD><TD>                int endOffset= region.getOffset() + region.getLength();</TD></TR><TR><TD CLASS="l">857</TD><TD> </TD></TR><TR><TD CLASS="l">858</TD><TD>                // go behind line comments</TD></TR><TR CLASS="z"><TD CLASS="l">859</TD><TD>                while (from &lt; endOffset - 2 &amp;&amp; document.get(from, 2).equals(LINE_COMMENT))</TD></TR><TR CLASS="z"><TD CLASS="l">860</TD><TD>                        from += 2;</TD></TR><TR><TD CLASS="l">861</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">862</TD><TD>                int to= from;</TD></TR><TR CLASS="z"><TD CLASS="l">863</TD><TD>                while (toDelete &gt; 0 &amp;&amp; to &lt; endOffset) {</TD></TR><TR CLASS="z"><TD CLASS="l">864</TD><TD>                        char ch= document.getChar(to);</TD></TR><TR CLASS="z"><TD CLASS="l">865</TD><TD>                        if (!Character.isWhitespace(ch))</TD></TR><TR CLASS="z"><TD CLASS="l">866</TD><TD>                                break;</TD></TR><TR CLASS="z"><TD CLASS="l">867</TD><TD>                        toDelete -= computeVisualLength(ch, tabLength);</TD></TR><TR CLASS="z"><TD CLASS="l">868</TD><TD>                        if (toDelete &gt;= 0)</TD></TR><TR CLASS="z"><TD CLASS="l">869</TD><TD>                                to++;</TD></TR><TR><TD CLASS="l">870</TD><TD>                        else</TD></TR><TR><TD CLASS="l">871</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">872</TD><TD>                }</TD></TR><TR><TD CLASS="l">873</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">874</TD><TD>                document.replace(from, to - from, &#34;&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">875</TD><TD>        }</TD></TR><TR><TD CLASS="l">876</TD><TD> </TD></TR><TR><TD CLASS="l">877</TD><TD>        /**</TD></TR><TR><TD CLASS="l">878</TD><TD>         * Returns the visual length of a given &lt;code&gt;CharSequence&lt;/code&gt; taking into</TD></TR><TR><TD CLASS="l">879</TD><TD>         * account the visual tabulator length.</TD></TR><TR><TD CLASS="l">880</TD><TD>         *</TD></TR><TR><TD CLASS="l">881</TD><TD>         * @param seq the string to measure</TD></TR><TR><TD CLASS="l"><A NAME="8">882</A></TD><TD>         * @param tabLength the length of a tab</TD></TR><TR><TD CLASS="l">883</TD><TD>         * @return the visual length of &lt;code&gt;seq&lt;/code&gt;</TD></TR><TR><TD CLASS="l">884</TD><TD>         */</TD></TR><TR><TD CLASS="l">885</TD><TD>        private int computeVisualLength(CharSequence seq, int tabLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">886</TD><TD>                int size= 0;</TD></TR><TR><TD CLASS="l">887</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">888</TD><TD>                for (int i= 0; i &lt; seq.length(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">889</TD><TD>                        char ch= seq.charAt(i);</TD></TR><TR CLASS="z"><TD CLASS="l">890</TD><TD>                        if (ch == '\t') {</TD></TR><TR CLASS="z"><TD CLASS="l">891</TD><TD>                                if (tabLength != 0)</TD></TR><TR CLASS="z"><TD CLASS="l">892</TD><TD>                                        size += tabLength - size % tabLength;</TD></TR><TR><TD CLASS="l">893</TD><TD>                                // else: size stays the same</TD></TR><TR><TD CLASS="l">894</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">895</TD><TD>                                size++;</TD></TR><TR><TD CLASS="l">896</TD><TD>                        }</TD></TR><TR><TD CLASS="l">897</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">898</TD><TD>                return size;</TD></TR><TR><TD CLASS="l">899</TD><TD>        }</TD></TR><TR><TD CLASS="l">900</TD><TD> </TD></TR><TR><TD CLASS="l">901</TD><TD>        /**</TD></TR><TR><TD CLASS="l">902</TD><TD>         * Returns the visual length of a given character taking into</TD></TR><TR><TD CLASS="l">903</TD><TD>         * account the visual tabulator length.</TD></TR><TR><TD CLASS="l">904</TD><TD>         *</TD></TR><TR><TD CLASS="l">905</TD><TD>         * @param ch the character to measure</TD></TR><TR><TD CLASS="l"><A NAME="9">906</A></TD><TD>         * @param tabLength the length of a tab</TD></TR><TR><TD CLASS="l">907</TD><TD>         * @return the visual length of &lt;code&gt;ch&lt;/code&gt;</TD></TR><TR><TD CLASS="l">908</TD><TD>         */</TD></TR><TR><TD CLASS="l">909</TD><TD>        private int computeVisualLength(char ch, int tabLength) {</TD></TR><TR CLASS="z"><TD CLASS="l">910</TD><TD>                if (ch == '\t')</TD></TR><TR CLASS="z"><TD CLASS="l">911</TD><TD>                        return tabLength;</TD></TR><TR><TD CLASS="l">912</TD><TD>                else</TD></TR><TR CLASS="z"><TD CLASS="l">913</TD><TD>                        return 1;</TD></TR><TR><TD CLASS="l">914</TD><TD>        }</TD></TR><TR><TD CLASS="l">915</TD><TD> </TD></TR><TR><TD CLASS="l">916</TD><TD>        /**</TD></TR><TR><TD CLASS="l">917</TD><TD>         * The preference setting for the visual tabulator display.</TD></TR><TR><TD CLASS="l"><A NAME="19">918</A></TD><TD>         *</TD></TR><TR><TD CLASS="l">919</TD><TD>         * @return the number of spaces displayed for a tabulator in the editor</TD></TR><TR><TD CLASS="l">920</TD><TD>         */</TD></TR><TR><TD CLASS="l">921</TD><TD>        private int getVisualTabLengthPreference() {</TD></TR><TR CLASS="z"><TD CLASS="l">922</TD><TD>                return CodeFormatterUtil.getTabWidth(fProject);</TD></TR><TR><TD CLASS="l">923</TD><TD>        }</TD></TR><TR><TD CLASS="l">924</TD><TD> </TD></TR><TR><TD CLASS="l">925</TD><TD>        /**</TD></TR><TR><TD CLASS="l">926</TD><TD>         * The preference setting that tells whether to insert spaces when pressing the Tab key.</TD></TR><TR><TD CLASS="l">927</TD><TD>         *</TD></TR><TR><TD CLASS="l"><A NAME="1d">928</A></TD><TD>         * @return &lt;code&gt;true&lt;/code&gt; if spaces are inserted when pressing the Tab key</TD></TR><TR><TD CLASS="l">929</TD><TD>         * @since 3.5</TD></TR><TR><TD CLASS="l">930</TD><TD>         */</TD></TR><TR><TD CLASS="l">931</TD><TD>        private boolean isInsertingSpacesForTab() {</TD></TR><TR CLASS="z"><TD CLASS="l">932</TD><TD>                return JavaScriptCore.SPACE.equals(getCoreOption(fProject, DefaultCodeFormatterConstants.FORMATTER_TAB_CHAR));</TD></TR><TR><TD CLASS="l">933</TD><TD>        }</TD></TR><TR><TD CLASS="l">934</TD><TD> </TD></TR><TR><TD CLASS="l">935</TD><TD>        /**</TD></TR><TR><TD CLASS="l">936</TD><TD>         * Returns the possibly &lt;code&gt;project&lt;/code&gt;-specific core preference defined under</TD></TR><TR><TD CLASS="l">937</TD><TD>         * &lt;code&gt;key&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">938</TD><TD>         *</TD></TR><TR><TD CLASS="l">939</TD><TD>         * @param project the project to get the preference from, or &lt;code&gt;null&lt;/code&gt; to get the global</TD></TR><TR><TD CLASS="l">940</TD><TD>         *            preference</TD></TR><TR><TD CLASS="l">941</TD><TD>         * @param key the key of the preference</TD></TR><TR><TD CLASS="l"><A NAME="12">942</A></TD><TD>         * @return the value of the preference</TD></TR><TR><TD CLASS="l">943</TD><TD>         * @since 3.5</TD></TR><TR><TD CLASS="l">944</TD><TD>         */</TD></TR><TR><TD CLASS="l">945</TD><TD>        private static String getCoreOption(IJavaScriptProject project, String key) {</TD></TR><TR CLASS="z"><TD CLASS="l">946</TD><TD>                if (project == null)</TD></TR><TR CLASS="z"><TD CLASS="l">947</TD><TD>                        return JavaScriptCore.getOption(key);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="15">948</A></TD><TD>                return project.getOption(key, true);</TD></TR><TR><TD CLASS="l">949</TD><TD>        }</TD></TR><TR><TD CLASS="l">950</TD><TD> </TD></TR><TR><TD CLASS="l">951</TD><TD>        private int getPeerPosition(IDocument document, DocumentCommand command) {</TD></TR><TR CLASS="z"><TD CLASS="l">952</TD><TD>                if (document.getLength() == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">953</TD><TD>                        return 0;</TD></TR><TR><TD CLASS="l">954</TD><TD>            /*</TD></TR><TR><TD CLASS="l">955</TD><TD>             * Search for scope closers in the pasted text and find their opening peers</TD></TR><TR><TD CLASS="l">956</TD><TD>             * in the document.</TD></TR><TR><TD CLASS="l">957</TD><TD>             */</TD></TR><TR CLASS="z"><TD CLASS="l">958</TD><TD>            Document pasted= new Document(command.text);</TD></TR><TR CLASS="z"><TD CLASS="l">959</TD><TD>            installJavaStuff(pasted);</TD></TR><TR CLASS="z"><TD CLASS="l">960</TD><TD>            int firstPeer= command.offset;</TD></TR><TR><TD CLASS="l">961</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">962</TD><TD>            JavaHeuristicScanner pScanner= new JavaHeuristicScanner(pasted);</TD></TR><TR CLASS="z"><TD CLASS="l">963</TD><TD>            JavaHeuristicScanner dScanner= new JavaHeuristicScanner(document);</TD></TR><TR><TD CLASS="l">964</TD><TD> </TD></TR><TR><TD CLASS="l">965</TD><TD>            // add scope relevant after context to peer search</TD></TR><TR CLASS="z"><TD CLASS="l">966</TD><TD>            int afterToken= dScanner.nextToken(command.offset + command.length, JavaHeuristicScanner.UNBOUND);</TD></TR><TR><TD CLASS="l">967</TD><TD>            try {</TD></TR><TR CLASS="z"><TD CLASS="l">968</TD><TD>                        switch (afterToken) {</TD></TR><TR><TD CLASS="l">969</TD><TD>                        case Symbols.TokenRBRACE:</TD></TR><TR CLASS="z"><TD CLASS="l">970</TD><TD>                                pasted.replace(pasted.getLength(), 0, &#34;}&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">971</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">972</TD><TD>                        case Symbols.TokenRPAREN:</TD></TR><TR CLASS="z"><TD CLASS="l">973</TD><TD>                                pasted.replace(pasted.getLength(), 0, &#34;)&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">974</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">975</TD><TD>                        case Symbols.TokenRBRACKET:</TD></TR><TR CLASS="z"><TD CLASS="l">976</TD><TD>                                pasted.replace(pasted.getLength(), 0, &#34;]&#34;); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">977</TD><TD>                                break;</TD></TR><TR CLASS="z"><TD CLASS="l">978</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">979</TD><TD>                } catch (BadLocationException e) {</TD></TR><TR><TD CLASS="l">980</TD><TD>                        // cannot happen</TD></TR><TR CLASS="z"><TD CLASS="l">981</TD><TD>                        Assert.isTrue(false);</TD></TR><TR><TD CLASS="l">982</TD><TD>                }</TD></TR><TR><TD CLASS="l">983</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">984</TD><TD>            int pPos= 0; // paste text position (increasing from 0)</TD></TR><TR CLASS="z"><TD CLASS="l">985</TD><TD>            int dPos= Math.max(0, command.offset - 1); // document position (decreasing from paste offset)</TD></TR><TR CLASS="z"><TD CLASS="l">986</TD><TD>            while (true) {</TD></TR><TR CLASS="z"><TD CLASS="l">987</TD><TD>                    int token= pScanner.nextToken(pPos, JavaHeuristicScanner.UNBOUND);</TD></TR><TR CLASS="z"><TD CLASS="l">988</TD><TD>                           pPos= pScanner.getPosition();</TD></TR><TR CLASS="z"><TD CLASS="l">989</TD><TD>                    switch (token) {</TD></TR><TR><TD CLASS="l">990</TD><TD>                            case Symbols.TokenLBRACE:</TD></TR><TR><TD CLASS="l">991</TD><TD>                            case Symbols.TokenLBRACKET:</TD></TR><TR><TD CLASS="l">992</TD><TD>                            case Symbols.TokenLPAREN:</TD></TR><TR CLASS="z"><TD CLASS="l">993</TD><TD>                                    pPos= skipScope(pScanner, pPos, token);</TD></TR><TR CLASS="z"><TD CLASS="l">994</TD><TD>                                    if (pPos == JavaHeuristicScanner.NOT_FOUND)</TD></TR><TR CLASS="z"><TD CLASS="l">995</TD><TD>                                            return firstPeer;</TD></TR><TR><TD CLASS="l">996</TD><TD>                                    break; // closed scope -&gt; keep searching</TD></TR><TR><TD CLASS="l">997</TD><TD>                            case Symbols.TokenRBRACE:</TD></TR><TR CLASS="z"><TD CLASS="l">998</TD><TD>                                    int peer= dScanner.findOpeningPeer(dPos, '{', '}');</TD></TR><TR CLASS="z"><TD CLASS="l">999</TD><TD>                                    dPos= peer - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">1000</TD><TD>                                    if (peer == JavaHeuristicScanner.NOT_FOUND)</TD></TR><TR CLASS="z"><TD CLASS="l">1001</TD><TD>                                            return firstPeer;</TD></TR><TR CLASS="z"><TD CLASS="l">1002</TD><TD>                                    firstPeer= peer;</TD></TR><TR CLASS="z"><TD CLASS="l">1003</TD><TD>                                    break; // keep searching</TD></TR><TR><TD CLASS="l">1004</TD><TD>                            case Symbols.TokenRBRACKET:</TD></TR><TR CLASS="z"><TD CLASS="l">1005</TD><TD>                                    peer= dScanner.findOpeningPeer(dPos, '[', ']');</TD></TR><TR CLASS="z"><TD CLASS="l">1006</TD><TD>                                    dPos= peer - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">1007</TD><TD>                                    if (peer == JavaHeuristicScanner.NOT_FOUND)</TD></TR><TR CLASS="z"><TD CLASS="l">1008</TD><TD>                                            return firstPeer;</TD></TR><TR CLASS="z"><TD CLASS="l">1009</TD><TD>                                    firstPeer= peer;</TD></TR><TR CLASS="z"><TD CLASS="l">1010</TD><TD>                                    break; // keep searching</TD></TR><TR><TD CLASS="l">1011</TD><TD>                            case Symbols.TokenRPAREN:</TD></TR><TR CLASS="z"><TD CLASS="l">1012</TD><TD>                                    peer= dScanner.findOpeningPeer(dPos, '(', ')');</TD></TR><TR CLASS="z"><TD CLASS="l">1013</TD><TD>                                    dPos= peer - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">1014</TD><TD>                                    if (peer == JavaHeuristicScanner.NOT_FOUND)</TD></TR><TR CLASS="z"><TD CLASS="l">1015</TD><TD>                                            return firstPeer;</TD></TR><TR CLASS="z"><TD CLASS="l">1016</TD><TD>                                    firstPeer= peer;</TD></TR><TR CLASS="z"><TD CLASS="l">1017</TD><TD>                                    break; // keep searching</TD></TR><TR><TD CLASS="l">1018</TD><TD>                            case Symbols.TokenCASE:</TD></TR><TR><TD CLASS="l">1019</TD><TD>                            case Symbols.TokenDEFAULT:</TD></TR><TR CLASS="z"><TD CLASS="l">1020</TD><TD>                                    JavaIndenter indenter= new JavaIndenter(document, dScanner, fProject);</TD></TR><TR CLASS="z"><TD CLASS="l">1021</TD><TD>                                    peer= indenter.findReferencePosition(dPos, false, false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1022</TD><TD>                                    if (peer == JavaHeuristicScanner.NOT_FOUND)</TD></TR><TR CLASS="z"><TD CLASS="l">1023</TD><TD>                                            return firstPeer;</TD></TR><TR CLASS="z"><TD CLASS="l">1024</TD><TD>                                    firstPeer= peer;</TD></TR><TR CLASS="z"><TD CLASS="l">1025</TD><TD>                                    break; // keep searching</TD></TR><TR><TD CLASS="l">1026</TD><TD> </TD></TR><TR><TD CLASS="l">1027</TD><TD>                            case Symbols.TokenEOF:</TD></TR><TR CLASS="z"><TD CLASS="l">1028</TD><TD>                                    return firstPeer;</TD></TR><TR><TD CLASS="l">1029</TD><TD>                            default:</TD></TR><TR><TD CLASS="l">1030</TD><TD>                                    // keep searching</TD></TR><TR><TD CLASS="l">1031</TD><TD>                    }</TD></TR><TR><TD CLASS="l">1032</TD><TD>            }</TD></TR><TR><TD CLASS="l">1033</TD><TD>    }</TD></TR><TR><TD CLASS="l">1034</TD><TD> </TD></TR><TR><TD CLASS="l">1035</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1036</TD><TD>     * Skips the scope opened by &lt;code&gt;token&lt;/code&gt;.</TD></TR><TR><TD CLASS="l">1037</TD><TD>     *</TD></TR><TR><TD CLASS="l">1038</TD><TD>     * @param scanner the scanner</TD></TR><TR><TD CLASS="l">1039</TD><TD>     * @param start the start position</TD></TR><TR><TD CLASS="l"><A NAME="23">1040</A></TD><TD>     * @param token the token</TD></TR><TR><TD CLASS="l">1041</TD><TD>     * @return the position after the scope or &lt;code&gt;JavaHeuristicScanner.NOT_FOUND&lt;/code&gt;</TD></TR><TR><TD CLASS="l">1042</TD><TD>     */</TD></TR><TR><TD CLASS="l">1043</TD><TD>    private static int skipScope(JavaHeuristicScanner scanner, int start, int token) {</TD></TR><TR CLASS="z"><TD CLASS="l">1044</TD><TD>            int openToken= token;</TD></TR><TR><TD CLASS="l">1045</TD><TD>            int closeToken;</TD></TR><TR CLASS="z"><TD CLASS="l">1046</TD><TD>            switch (token) {</TD></TR><TR><TD CLASS="l">1047</TD><TD>                    case Symbols.TokenLPAREN:</TD></TR><TR CLASS="z"><TD CLASS="l">1048</TD><TD>                            closeToken= Symbols.TokenRPAREN;</TD></TR><TR CLASS="z"><TD CLASS="l">1049</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">1050</TD><TD>                    case Symbols.TokenLBRACKET:</TD></TR><TR CLASS="z"><TD CLASS="l">1051</TD><TD>                            closeToken= Symbols.TokenRBRACKET;</TD></TR><TR CLASS="z"><TD CLASS="l">1052</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">1053</TD><TD>                    case Symbols.TokenLBRACE:</TD></TR><TR CLASS="z"><TD CLASS="l">1054</TD><TD>                            closeToken= Symbols.TokenRBRACE;</TD></TR><TR CLASS="z"><TD CLASS="l">1055</TD><TD>                            break;</TD></TR><TR><TD CLASS="l">1056</TD><TD>                    default:</TD></TR><TR CLASS="z"><TD CLASS="l">1057</TD><TD>                            Assert.isTrue(false);</TD></TR><TR CLASS="z"><TD CLASS="l">1058</TD><TD>                            return -1; // dummy</TD></TR><TR><TD CLASS="l">1059</TD><TD>            }</TD></TR><TR><TD CLASS="l">1060</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1061</TD><TD>            int depth= 1;</TD></TR><TR CLASS="z"><TD CLASS="l">1062</TD><TD>            int p= start;</TD></TR><TR><TD CLASS="l">1063</TD><TD> </TD></TR><TR><TD CLASS="l">1064</TD><TD>            while (true) {</TD></TR><TR CLASS="z"><TD CLASS="l">1065</TD><TD>                    int tok= scanner.nextToken(p, JavaHeuristicScanner.UNBOUND);</TD></TR><TR CLASS="z"><TD CLASS="l">1066</TD><TD>                    p= scanner.getPosition();</TD></TR><TR><TD CLASS="l">1067</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1068</TD><TD>                    if (tok == openToken) {</TD></TR><TR CLASS="z"><TD CLASS="l">1069</TD><TD>                            depth++;</TD></TR><TR CLASS="z"><TD CLASS="l">1070</TD><TD>                    } else if (tok == closeToken) {</TD></TR><TR CLASS="z"><TD CLASS="l">1071</TD><TD>                            depth--;</TD></TR><TR CLASS="z"><TD CLASS="l">1072</TD><TD>                            if (depth == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1073</TD><TD>                                    return p + 1;</TD></TR><TR CLASS="z"><TD CLASS="l">1074</TD><TD>                    } else if (tok == Symbols.TokenEOF) {</TD></TR><TR CLASS="z"><TD CLASS="l">1075</TD><TD>                            return JavaHeuristicScanner.NOT_FOUND;</TD></TR><TR><TD CLASS="l">1076</TD><TD>                    }</TD></TR><TR><TD CLASS="l"><A NAME="1e">1077</A></TD><TD>            }</TD></TR><TR><TD CLASS="l">1078</TD><TD>    }</TD></TR><TR><TD CLASS="l">1079</TD><TD> </TD></TR><TR><TD CLASS="l">1080</TD><TD>    private boolean isLineDelimiter(IDocument document, String text) {</TD></TR><TR CLASS="z"><TD CLASS="l">1081</TD><TD>                String[] delimiters= document.getLegalLineDelimiters();</TD></TR><TR CLASS="z"><TD CLASS="l">1082</TD><TD>                if (delimiters != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1083</TD><TD>                        return TextUtilities.equals(delimiters, text) &gt; -1;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="27">1084</A></TD><TD>                return false;</TD></TR><TR><TD CLASS="l">1085</TD><TD>        }</TD></TR><TR><TD CLASS="l">1086</TD><TD> </TD></TR><TR><TD CLASS="l">1087</TD><TD>        private void smartIndentOnKeypress(IDocument document, DocumentCommand command) {</TD></TR><TR CLASS="z"><TD CLASS="l">1088</TD><TD>                switch (command.text.charAt(0)) {</TD></TR><TR><TD CLASS="l">1089</TD><TD>                        case '}':</TD></TR><TR CLASS="z"><TD CLASS="l">1090</TD><TD>                                smartIndentAfterClosingBracket(document, command);</TD></TR><TR CLASS="z"><TD CLASS="l">1091</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">1092</TD><TD>                        case '{':</TD></TR><TR CLASS="z"><TD CLASS="l">1093</TD><TD>                                smartIndentAfterOpeningBracket(document, command);</TD></TR><TR CLASS="z"><TD CLASS="l">1094</TD><TD>                                break;</TD></TR><TR><TD CLASS="l">1095</TD><TD>                        case 'e':</TD></TR><TR CLASS="z"><TD CLASS="l">1096</TD><TD>                                smartIndentUponE(document, command);</TD></TR><TR><TD CLASS="l">1097</TD><TD>                                break;</TD></TR><TR><TD CLASS="l"><A NAME="28">1098</A></TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1099</TD><TD>        }</TD></TR><TR><TD CLASS="l">1100</TD><TD> </TD></TR><TR><TD CLASS="l">1101</TD><TD>        private void smartIndentUponE(IDocument d, DocumentCommand c) {</TD></TR><TR CLASS="z"><TD CLASS="l">1102</TD><TD>                if (c.offset &lt; 4 || d.getLength() == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1103</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">1104</TD><TD> </TD></TR><TR><TD CLASS="l">1105</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1106</TD><TD>                        String content= d.get(c.offset - 3, 3);</TD></TR><TR CLASS="z"><TD CLASS="l">1107</TD><TD>                        if (content.equals(&#34;els&#34;)) { //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1108</TD><TD>                                JavaHeuristicScanner scanner= new JavaHeuristicScanner(d);</TD></TR><TR CLASS="z"><TD CLASS="l">1109</TD><TD>                                int p= c.offset - 3;</TD></TR><TR><TD CLASS="l">1110</TD><TD> </TD></TR><TR><TD CLASS="l">1111</TD><TD>                                // current line</TD></TR><TR CLASS="z"><TD CLASS="l">1112</TD><TD>                                int line= d.getLineOfOffset(p);</TD></TR><TR CLASS="z"><TD CLASS="l">1113</TD><TD>                                int lineOffset= d.getLineOffset(line);</TD></TR><TR><TD CLASS="l">1114</TD><TD> </TD></TR><TR><TD CLASS="l">1115</TD><TD>                                // make sure we don't have any leading comments etc.</TD></TR><TR CLASS="z"><TD CLASS="l">1116</TD><TD>                                if (d.get(lineOffset, p - lineOffset).trim().length() != 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1117</TD><TD>                                        return;</TD></TR><TR><TD CLASS="l">1118</TD><TD> </TD></TR><TR><TD CLASS="l">1119</TD><TD>                                // line of last Java code</TD></TR><TR CLASS="z"><TD CLASS="l">1120</TD><TD>                                int pos= scanner.findNonWhitespaceBackward(p - 1, JavaHeuristicScanner.UNBOUND);</TD></TR><TR CLASS="z"><TD CLASS="l">1121</TD><TD>                                if (pos == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">1122</TD><TD>                                        return;</TD></TR><TR CLASS="z"><TD CLASS="l">1123</TD><TD>                                int lastLine= d.getLineOfOffset(pos);</TD></TR><TR><TD CLASS="l">1124</TD><TD> </TD></TR><TR><TD CLASS="l">1125</TD><TD>                                // only shift if the last java line is further up and is a braceless block candidate</TD></TR><TR CLASS="z"><TD CLASS="l">1126</TD><TD>                                if (lastLine &lt; line) {</TD></TR><TR><TD CLASS="l">1127</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1128</TD><TD>                                        JavaIndenter indenter= new JavaIndenter(d, scanner, fProject);</TD></TR><TR CLASS="z"><TD CLASS="l">1129</TD><TD>                                        int ref= indenter.findReferencePosition(p, true, false, false, false);</TD></TR><TR CLASS="z"><TD CLASS="l">1130</TD><TD>                                        if (ref == JavaHeuristicScanner.NOT_FOUND)</TD></TR><TR CLASS="z"><TD CLASS="l">1131</TD><TD>                                                return;</TD></TR><TR CLASS="z"><TD CLASS="l">1132</TD><TD>                                        int refLine= d.getLineOfOffset(ref);</TD></TR><TR CLASS="z"><TD CLASS="l">1133</TD><TD>                                        String indent= getIndentOfLine(d, refLine);</TD></TR><TR><TD CLASS="l">1134</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1135</TD><TD>                                        if (indent != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1136</TD><TD>                                                c.text= indent.toString() + &#34;else&#34;; //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1137</TD><TD>                                                c.length += c.offset - lineOffset;</TD></TR><TR CLASS="z"><TD CLASS="l">1138</TD><TD>                                                c.offset= lineOffset;</TD></TR><TR><TD CLASS="l">1139</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1140</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1141</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1142</TD><TD>                                return;</TD></TR><TR><TD CLASS="l">1143</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1144</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1145</TD><TD>                        if (content.equals(&#34;cas&#34;)) { //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1146</TD><TD>                                JavaHeuristicScanner scanner= new JavaHeuristicScanner(d);</TD></TR><TR CLASS="z"><TD CLASS="l">1147</TD><TD>                                int p= c.offset - 3;</TD></TR><TR><TD CLASS="l">1148</TD><TD> </TD></TR><TR><TD CLASS="l">1149</TD><TD>                                // current line</TD></TR><TR CLASS="z"><TD CLASS="l">1150</TD><TD>                                int line= d.getLineOfOffset(p);</TD></TR><TR CLASS="z"><TD CLASS="l">1151</TD><TD>                                int lineOffset= d.getLineOffset(line);</TD></TR><TR><TD CLASS="l">1152</TD><TD> </TD></TR><TR><TD CLASS="l">1153</TD><TD>                                // make sure we don't have any leading comments etc.</TD></TR><TR CLASS="z"><TD CLASS="l">1154</TD><TD>                                if (d.get(lineOffset, p - lineOffset).trim().length() != 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1155</TD><TD>                                        return;</TD></TR><TR><TD CLASS="l">1156</TD><TD> </TD></TR><TR><TD CLASS="l">1157</TD><TD>                                // line of last Java code</TD></TR><TR CLASS="z"><TD CLASS="l">1158</TD><TD>                                int pos= scanner.findNonWhitespaceBackward(p - 1, JavaHeuristicScanner.UNBOUND);</TD></TR><TR CLASS="z"><TD CLASS="l">1159</TD><TD>                                if (pos == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">1160</TD><TD>                                        return;</TD></TR><TR CLASS="z"><TD CLASS="l">1161</TD><TD>                                int lastLine= d.getLineOfOffset(pos);</TD></TR><TR><TD CLASS="l">1162</TD><TD> </TD></TR><TR><TD CLASS="l">1163</TD><TD>                                // only shift if the last java line is further up and is a braceless block candidate</TD></TR><TR CLASS="z"><TD CLASS="l">1164</TD><TD>                                if (lastLine &lt; line) {</TD></TR><TR><TD CLASS="l">1165</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1166</TD><TD>                                        JavaIndenter indenter= new JavaIndenter(d, scanner, fProject);</TD></TR><TR CLASS="z"><TD CLASS="l">1167</TD><TD>                                        int ref= indenter.findReferencePosition(p, false, false, false, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1168</TD><TD>                                        if (ref == JavaHeuristicScanner.NOT_FOUND)</TD></TR><TR CLASS="z"><TD CLASS="l">1169</TD><TD>                                                return;</TD></TR><TR CLASS="z"><TD CLASS="l">1170</TD><TD>                                        int refLine= d.getLineOfOffset(ref);</TD></TR><TR CLASS="z"><TD CLASS="l">1171</TD><TD>                                        int nextToken= scanner.nextToken(ref, JavaHeuristicScanner.UNBOUND);</TD></TR><TR><TD CLASS="l">1172</TD><TD>                                        String indent;</TD></TR><TR CLASS="z"><TD CLASS="l">1173</TD><TD>                                        if (nextToken == Symbols.TokenCASE || nextToken == Symbols.TokenDEFAULT)</TD></TR><TR CLASS="z"><TD CLASS="l">1174</TD><TD>                                                indent= getIndentOfLine(d, refLine);</TD></TR><TR><TD CLASS="l">1175</TD><TD>                                        else // at the brace of the switch</TD></TR><TR CLASS="z"><TD CLASS="l">1176</TD><TD>                                                indent= indenter.computeIndentation(p).toString();</TD></TR><TR><TD CLASS="l">1177</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1178</TD><TD>                                        if (indent != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1179</TD><TD>                                                c.text= indent.toString() + &#34;case&#34;; //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1180</TD><TD>                                                c.length += c.offset - lineOffset;</TD></TR><TR CLASS="z"><TD CLASS="l">1181</TD><TD>                                                c.offset= lineOffset;</TD></TR><TR><TD CLASS="l">1182</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1183</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1184</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1185</TD><TD>                                return;</TD></TR><TR><TD CLASS="l">1186</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1187</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1188</TD><TD>                } catch (BadLocationException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1189</TD><TD>                        JavaScriptPlugin.log(e);</TD></TR><TR><TD CLASS="l">1190</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1191</TD><TD>        }</TD></TR><TR><TD CLASS="l">1192</TD><TD> </TD></TR><TR><TD CLASS="l">1193</TD><TD>        /*</TD></TR><TR><TD CLASS="l"><A NAME="b">1194</A></TD><TD>         * @see org.eclipse.jface.text.IAutoIndentStrategy#customizeDocumentCommand(org.eclipse.jface.text.IDocument, org.eclipse.jface.text.DocumentCommand)</TD></TR><TR><TD CLASS="l">1195</TD><TD>         */</TD></TR><TR><TD CLASS="l">1196</TD><TD>        public void customizeDocumentCommand(IDocument d, DocumentCommand c) {</TD></TR><TR><TD CLASS="l">1197</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1198</TD><TD>                        if (c.doit == false)</TD></TR><TR CLASS="z"><TD CLASS="l">1199</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">1200</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1201</TD><TD>                        clearCachedValues();</TD></TR><TR><TD CLASS="l">1202</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">1203</TD><TD>                        if (!fIsSmartMode) {</TD></TR><TR CLASS="z"><TD CLASS="l">1204</TD><TD>                                super.customizeDocumentCommand(d, c);</TD></TR><TR CLASS="z"><TD CLASS="l">1205</TD><TD>                                return;</TD></TR><TR><TD CLASS="l">1206</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1207</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">1208</TD><TD>                        if (!fIsSmartTab &amp;&amp; isRepresentingTab(c.text))</TD></TR><TR CLASS="z"><TD CLASS="l">1209</TD><TD>                                return;</TD></TR><TR><TD CLASS="l">1210</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">1211</TD><TD>                        if (c.length == 0 &amp;&amp; c.text != null &amp;&amp; isLineDelimiter(d, c.text))</TD></TR><TR CLASS="z"><TD CLASS="l">1212</TD><TD>                                smartIndentAfterNewLine(d, c);</TD></TR><TR CLASS="z"><TD CLASS="l">1213</TD><TD>                        else if (c.text.length() == 1)</TD></TR><TR CLASS="z"><TD CLASS="l">1214</TD><TD>                                smartIndentOnKeypress(d, c);</TD></TR><TR CLASS="z"><TD CLASS="l">1215</TD><TD>                        else if (c.text.length() &gt; 1 &amp;&amp; getPreferenceStore().getBoolean(PreferenceConstants.EDITOR_SMART_PASTE))</TD></TR><TR CLASS="z"><TD CLASS="l">1216</TD><TD>                                if (fViewer == null || fViewer.getTextWidget() == null || !fViewer.getTextWidget().getBlockSelection())</TD></TR><TR CLASS="z"><TD CLASS="l">1217</TD><TD>                                        smartPaste(d, c); // no smart backspace for paste</TD></TR><TR CLASS="z"><TD CLASS="l">1218</TD><TD>                } catch(IllegalArgumentException e) {</TD></TR><TR><TD CLASS="l">1219</TD><TD>                        // ignore</TD></TR><TR><TD CLASS="l">1220</TD><TD>                }</TD></TR><TR><TD CLASS="l">1221</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1222</TD><TD>        }</TD></TR><TR><TD CLASS="l">1223</TD><TD> </TD></TR><TR><TD CLASS="l">1224</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1225</TD><TD>         * Tells whether the given inserted string represents hitting the Tab key.</TD></TR><TR><TD CLASS="l">1226</TD><TD>         *</TD></TR><TR><TD CLASS="l">1227</TD><TD>         * @param text the text to check</TD></TR><TR><TD CLASS="l"><A NAME="20">1228</A></TD><TD>         * @return &lt;code&gt;true&lt;/code&gt; if the text represents hitting the Tab key</TD></TR><TR><TD CLASS="l">1229</TD><TD>         * @since 3.5</TD></TR><TR><TD CLASS="l">1230</TD><TD>         */</TD></TR><TR><TD CLASS="l">1231</TD><TD>        private boolean isRepresentingTab(String text) {</TD></TR><TR CLASS="z"><TD CLASS="l">1232</TD><TD>                if (text == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1233</TD><TD>                        return false;</TD></TR><TR><TD CLASS="l">1234</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1235</TD><TD>                if (isInsertingSpacesForTab()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1236</TD><TD>                        if (text.length() == 0 || text.length() &gt; getVisualTabLengthPreference())</TD></TR><TR CLASS="z"><TD CLASS="l">1237</TD><TD>                                return false;</TD></TR><TR CLASS="z"><TD CLASS="l">1238</TD><TD>                        for (int i= 0; i &lt; text.length(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1239</TD><TD>                                if (text.charAt(i) != ' ')</TD></TR><TR CLASS="z"><TD CLASS="l">1240</TD><TD>                                        return false;</TD></TR><TR><TD CLASS="l">1241</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1242</TD><TD>                        return true;</TD></TR><TR><TD CLASS="l">1243</TD><TD>                } else</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="16">1244</A></TD><TD>                        return text.length() == 1 &amp;&amp; text.charAt(0) == '\t';</TD></TR><TR><TD CLASS="l">1245</TD><TD>        }</TD></TR><TR><TD CLASS="l">1246</TD><TD> </TD></TR><TR><TD CLASS="l">1247</TD><TD>        private static IPreferenceStore getPreferenceStore() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5">1248</A></TD><TD>                return JavaScriptPlugin.getDefault().getCombinedPreferenceStore();</TD></TR><TR><TD CLASS="l">1249</TD><TD>        }</TD></TR><TR><TD CLASS="l">1250</TD><TD> </TD></TR><TR><TD CLASS="l">1251</TD><TD>        private boolean closeBrace() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4">1252</A></TD><TD>                return fCloseBrace;</TD></TR><TR><TD CLASS="l">1253</TD><TD>        }</TD></TR><TR><TD CLASS="l">1254</TD><TD> </TD></TR><TR><TD CLASS="l">1255</TD><TD>        private void clearCachedValues() {</TD></TR><TR CLASS="z"><TD CLASS="l">1256</TD><TD>        IPreferenceStore preferenceStore= getPreferenceStore();</TD></TR><TR CLASS="z"><TD CLASS="l">1257</TD><TD>                fCloseBrace= preferenceStore.getBoolean(PreferenceConstants.EDITOR_CLOSE_BRACES);</TD></TR><TR CLASS="z"><TD CLASS="l">1258</TD><TD>                fIsSmartTab= preferenceStore.getBoolean(PreferenceConstants.EDITOR_SMART_TAB);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="7">1259</A></TD><TD>                fIsSmartMode= computeSmartMode();</TD></TR><TR CLASS="z"><TD CLASS="l">1260</TD><TD>        }</TD></TR><TR><TD CLASS="l">1261</TD><TD> </TD></TR><TR><TD CLASS="l">1262</TD><TD>        private boolean computeSmartMode() {</TD></TR><TR CLASS="z"><TD CLASS="l">1263</TD><TD>                IWorkbenchPage page= JavaScriptPlugin.getActivePage();</TD></TR><TR CLASS="z"><TD CLASS="l">1264</TD><TD>                if (page != null)  {</TD></TR><TR CLASS="z"><TD CLASS="l">1265</TD><TD>                        IEditorPart part= page.getActiveEditor();</TD></TR><TR CLASS="z"><TD CLASS="l">1266</TD><TD>                        if (part instanceof ITextEditorExtension3) {</TD></TR><TR CLASS="z"><TD CLASS="l">1267</TD><TD>                                ITextEditorExtension3 extension= (ITextEditorExtension3) part;</TD></TR><TR CLASS="z"><TD CLASS="l">1268</TD><TD>                                return extension.getInsertMode() == ITextEditorExtension3.SMART_INSERT;</TD></TR><TR><TD CLASS="l">1269</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1270</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1271</TD><TD>                return false;</TD></TR><TR><TD CLASS="l"><A NAME="11">1272</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">1273</TD><TD> </TD></TR><TR><TD CLASS="l">1274</TD><TD>        private static CompilationUnitInfo getCompilationUnitForMethod(IDocument document, int offset) {</TD></TR><TR><TD CLASS="l">1275</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1276</TD><TD>                        JavaHeuristicScanner scanner= new JavaHeuristicScanner(document);</TD></TR><TR><TD CLASS="l">1277</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1278</TD><TD>                        IRegion sourceRange= scanner.findSurroundingBlock(offset);</TD></TR><TR CLASS="z"><TD CLASS="l">1279</TD><TD>                        if (sourceRange == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1280</TD><TD>                                return null;</TD></TR><TR CLASS="z"><TD CLASS="l">1281</TD><TD>                        String source= document.get(sourceRange.getOffset(), sourceRange.getLength());</TD></TR><TR><TD CLASS="l">1282</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1283</TD><TD>                        StringBuffer contents= new StringBuffer();</TD></TR><TR CLASS="z"><TD CLASS="l">1284</TD><TD>                        contents.append(&#34;class ____C{void ____m()&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1285</TD><TD>                        final int methodOffset= contents.length();</TD></TR><TR CLASS="z"><TD CLASS="l">1286</TD><TD>                        contents.append(source);</TD></TR><TR CLASS="z"><TD CLASS="l">1287</TD><TD>                        contents.append('}');</TD></TR><TR><TD CLASS="l">1288</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1289</TD><TD>                        char[] buffer= contents.toString().toCharArray();</TD></TR><TR><TD CLASS="l">1290</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1291</TD><TD>                        return new CompilationUnitInfo(buffer, sourceRange.getOffset() - methodOffset);</TD></TR><TR><TD CLASS="l">1292</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1293</TD><TD>                } catch (BadLocationException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1294</TD><TD>                        JavaScriptPlugin.log(e);</TD></TR><TR><TD CLASS="l">1295</TD><TD>                }</TD></TR><TR><TD CLASS="l">1296</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1297</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">1298</TD><TD>        }</TD></TR><TR><TD CLASS="l">1299</TD><TD> </TD></TR><TR><TD CLASS="l">1300</TD><TD>        /**</TD></TR><TR><TD CLASS="l">1301</TD><TD>         * Returns the block balance, i.e. zero if the blocks are balanced at &lt;code&gt;offset&lt;/code&gt;, a</TD></TR><TR><TD CLASS="l">1302</TD><TD>         * negative number if there are more closing than opening braces, and a positive number if there</TD></TR><TR><TD CLASS="l">1303</TD><TD>         * are more opening than closing braces.</TD></TR><TR><TD CLASS="l">1304</TD><TD>         * </TD></TR><TR><TD CLASS="l">1305</TD><TD>         * @param document the document</TD></TR><TR><TD CLASS="l">1306</TD><TD>         * @param offset the offset</TD></TR><TR><TD CLASS="l"><A NAME="e">1307</A></TD><TD>         * @param partitioning the partitioning</TD></TR><TR><TD CLASS="l">1308</TD><TD>         * @return the block balance</TD></TR><TR><TD CLASS="l">1309</TD><TD>         */</TD></TR><TR><TD CLASS="l">1310</TD><TD>        private static int getBlockBalance(IDocument document, int offset, String partitioning) {</TD></TR><TR CLASS="z"><TD CLASS="l">1311</TD><TD>                if (offset &lt; 1)</TD></TR><TR CLASS="z"><TD CLASS="l">1312</TD><TD>                        return -1;</TD></TR><TR CLASS="z"><TD CLASS="l">1313</TD><TD>                if (offset &gt;= document.getLength())</TD></TR><TR CLASS="z"><TD CLASS="l">1314</TD><TD>                        return 1;</TD></TR><TR><TD CLASS="l">1315</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1316</TD><TD>                int begin= offset;</TD></TR><TR CLASS="z"><TD CLASS="l">1317</TD><TD>                int end= offset - 1;</TD></TR><TR><TD CLASS="l">1318</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1319</TD><TD>                JavaHeuristicScanner scanner= new JavaHeuristicScanner(document);</TD></TR><TR><TD CLASS="l">1320</TD><TD> </TD></TR><TR><TD CLASS="l">1321</TD><TD>                while (true) {</TD></TR><TR CLASS="z"><TD CLASS="l">1322</TD><TD>                        begin= scanner.findOpeningPeer(begin - 1, '{', '}');</TD></TR><TR CLASS="z"><TD CLASS="l">1323</TD><TD>                        end= scanner.findClosingPeer(end + 1, '{', '}');</TD></TR><TR CLASS="z"><TD CLASS="l">1324</TD><TD>                        if (begin == -1 &amp;&amp; end == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">1325</TD><TD>                                return 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1326</TD><TD>                        if (begin == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">1327</TD><TD>                                return -1;</TD></TR><TR CLASS="z"><TD CLASS="l">1328</TD><TD>                        if (end == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">1329</TD><TD>                                return 1;</TD></TR><TR><TD CLASS="l"><A NAME="a">1330</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">1331</TD><TD>        }</TD></TR><TR><TD CLASS="l">1332</TD><TD> </TD></TR><TR><TD CLASS="l">1333</TD><TD>        private static IRegion createRegion(ASTNode node, int delta) {</TD></TR><TR CLASS="z"><TD CLASS="l">1334</TD><TD>                return node == null ? null : new Region(node.getStartPosition() + delta, node.getLength());</TD></TR><TR><TD CLASS="l">1335</TD><TD>        }</TD></TR><TR><TD CLASS="l">1336</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="18">1337</A></TD><TD>        private static IRegion getToken(IDocument document, IRegion scanRegion, int tokenId)  {</TD></TR><TR><TD CLASS="l">1338</TD><TD> </TD></TR><TR><TD CLASS="l">1339</TD><TD>                try {</TD></TR><TR><TD CLASS="l">1340</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1341</TD><TD>                        final String source= document.get(scanRegion.getOffset(), scanRegion.getLength());</TD></TR><TR><TD CLASS="l">1342</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1343</TD><TD>                        fgScanner.setSource(source.toCharArray());</TD></TR><TR><TD CLASS="l">1344</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1345</TD><TD>                        int id= fgScanner.getNextToken();</TD></TR><TR CLASS="z"><TD CLASS="l">1346</TD><TD>                        while (id != ITerminalSymbols.TokenNameEOF &amp;&amp; id != tokenId)</TD></TR><TR CLASS="z"><TD CLASS="l">1347</TD><TD>                                id= fgScanner.getNextToken();</TD></TR><TR><TD CLASS="l">1348</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1349</TD><TD>                        if (id == ITerminalSymbols.TokenNameEOF)</TD></TR><TR CLASS="z"><TD CLASS="l">1350</TD><TD>                                return null;</TD></TR><TR><TD CLASS="l">1351</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1352</TD><TD>                        int tokenOffset= fgScanner.getCurrentTokenStartPosition();</TD></TR><TR CLASS="z"><TD CLASS="l">1353</TD><TD>                        int tokenLength= fgScanner.getCurrentTokenEndPosition() + 1 - tokenOffset; // inclusive end</TD></TR><TR CLASS="z"><TD CLASS="l">1354</TD><TD>                        return new Region(tokenOffset + scanRegion.getOffset(), tokenLength);</TD></TR><TR><TD CLASS="l">1355</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1356</TD><TD>                } catch (InvalidInputException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">1357</TD><TD>                        return null;</TD></TR><TR CLASS="z"><TD CLASS="l">1358</TD><TD>                } catch (BadLocationException x) {</TD></TR><TR CLASS="z"><TD CLASS="l">1359</TD><TD>                        return null;</TD></TR><TR><TD CLASS="l">1360</TD><TD>                }</TD></TR><TR><TD CLASS="l">1361</TD><TD>        }</TD></TR><TR><TD CLASS="l">1362</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../xslUnitTestCoverage.html">all classes</A>][<A HREF="17a.html">org.eclipse.wst.jsdt.internal.ui.text.java</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://www.eclemma.org/support.html">EMMA 2.0.5312 EclEmma Fix 1</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>