<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="tl"><A HREF="http://www.eclemma.org/">EMMA</A> Coverage Report (generated Tue Jun 09 19:59:05 GMT 2009)</TH></TR><TR><TD CLASS="nv">[<A HREF="../xslUnitTestCoverage.html">all classes</A>][<A HREF="12f.html">org.eclipse.wst.jsdt.internal.core.search.matching</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">MatchLocator.java</SPAN>]</H2><TABLE CELLSPACING="0" WIDTH="100%"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>MatchLocator.java</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/89)</TD><TD CLASS="h">0%   (0/7000)</TD><TD CLASS="h">0%   (0/1490)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" CELLSPACING="0" WIDTH="100%"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">MatchLocator</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/75)</TD><TD CLASS="h">0%   (0/6735)</TD><TD CLASS="h">0%   (0/1433)</TD></TR><TR><TD CLASS="f"><A HREF="#0">&lt;static initializer&gt;</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">MatchLocator (SearchPattern, SearchRequestor, IJavaScriptSearchScope, IProgre...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#3">accept (IBinaryType, PackageBinding, AccessRestriction): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">accept (ICompilationUnit, AccessRestriction): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/50)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#5">accept (ISourceType [], PackageBinding, AccessRestriction): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/59)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">accept (LibraryAPIs): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#7">addWorkingCopies (InternalSearchPattern, SearchDocument [], IJavaScriptUnit [...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/91)</TD><TD CLASS="h">0%   (0/21)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">basicParser (): Parser</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#9">cacheBinaryType (IType, IBinaryType): BinaryTypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/60)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">computeSuperTypeNames (IType): char [][][]</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/53)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR><TD CLASS="f"><A HREF="#b">createAndPattern (SearchPattern, SearchPattern): SearchPattern</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">createHandle (AbstractMethodDeclaration, IJavaScriptElement): IJavaScriptElement</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/76)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR><TD CLASS="f"><A HREF="#d">createHandle (AbstractVariableDeclaration, IJavaScriptElement): IJavaScriptEl...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/64)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">createHandle (FieldDeclaration, TypeDeclaration, IJavaScriptElement): IJavaSc...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/59)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="f"><A HREF="#f">createHandle (InferredAttribute, InferredType, IJavaScriptElement): IJavaScri...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">createHierarchyResolver (IType, PossibleMatch []): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/77)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR><TD CLASS="f"><A HREF="#11">createImportHandle (ImportReference): IJavaScriptElement</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/53)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">createMethodHandle (IJavaScriptElement, String, String []): IJavaScriptElement</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/60)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR><TD CLASS="f"><A HREF="#13">createPackageDeclarationHandle (CompilationUnitDeclaration): IJavaScriptElement</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/32)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">createTypeHandle (String): IType</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#15">doParse (ICompilationUnit, AccessRestriction): CompilationUnitDeclaration</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/28)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">encloses (IJavaScriptElement): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#17">findIndexMatches (InternalSearchPattern, Index, IndexQueryRequestor, SearchPa...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">findLastTypeArgumentInfo (TypeReference): long</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/76)</TD><TD CLASS="h">0%   (0/19)</TD></TR><TR><TD CLASS="f"><A HREF="#19">getBinaryInfo (ClassFile, IResource): IBinaryType</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">getFocusType (): IType</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">getMethodBinding (MethodPattern): MethodBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/227)</TD><TD CLASS="h">0%   (0/52)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">getMethodBodies (CompilationUnitDeclaration, MatchingNodeSet): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/71)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">getParticipant (): SearchParticipant</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">getProjectOrJar (IJavaScriptElement): IJavaScriptElement</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">getType (Object, char []): TypeBinding</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/53)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">hasAlreadyDefinedType (CompilationUnitDeclaration): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#21">initialize (JavaProject, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/73)</TD><TD CLASS="h">0%   (0/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">locateMatches (JavaProject, PossibleMatch [], int, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/272)</TD><TD CLASS="h">0%   (0/62)</TD></TR><TR><TD CLASS="f"><A HREF="#23">locateMatches (JavaProject, PossibleMatchSet, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/54)</TD><TD CLASS="h">0%   (0/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">locateMatches (SearchDocument []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/343)</TD><TD CLASS="h">0%   (0/81)</TD></TR><TR><TD CLASS="f"><A HREF="#25">locatePackageDeclarations (SearchParticipant): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">locatePackageDeclarations (SearchPattern, SearchParticipant): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/209)</TD><TD CLASS="h">0%   (0/44)</TD></TR><TR><TD CLASS="f"><A HREF="#27">lookupType (ReferenceBinding): IType</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/134)</TD><TD CLASS="h">0%   (0/32)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">newDeclarationMatch (IJavaScriptElement, Binding, int, int, int): SearchMatch</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#29">newDeclarationMatch (IJavaScriptElement, Binding, int, int, int, SearchPartic...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/86)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">newFieldReferenceMatch (IJavaScriptElement, Binding, int, int, int, ASTNode):...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/66)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">newLocalVariableReferenceMatch (IJavaScriptElement, int, int, int, ASTNode): ...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/59)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2c">newMethodReferenceMatch (IJavaScriptElement, Binding, int, int, int, boolean,...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/45)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR><TD CLASS="f"><A HREF="#2d">newPackageReferenceMatch (IJavaScriptElement, int, int, int, ASTNode): Search...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2e">newTypeParameterReferenceMatch (IJavaScriptElement, int, int, int, ASTNode): ...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/29)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#2f">newTypeReferenceMatch (IJavaScriptElement, Binding, int, ASTNode): TypeRefere...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#30">newTypeReferenceMatch (IJavaScriptElement, Binding, int, int, int, ASTNode): ...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#31">parseAndBuildBindings (PossibleMatch, boolean): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/144)</TD><TD CLASS="h">0%   (0/25)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#32">process (PossibleMatch, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/163)</TD><TD CLASS="h">0%   (0/39)</TD></TR><TR><TD CLASS="f"><A HREF="#33">processMetadata (MetadataFile): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/148)</TD><TD CLASS="h">0%   (0/32)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#34">projectOrJarFocus (InternalSearchPattern): IJavaScriptElement</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/11)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#35">purgeMethodStatements (AbstractMethodDeclaration): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/16)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#36">purgeMethodStatements (TypeDeclaration, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/82)</TD><TD CLASS="h">0%   (0/16)</TD></TR><TR><TD CLASS="f"><A HREF="#37">reduceParseTree (CompilationUnitDeclaration): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/48)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#38">report (SearchMatch): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/239)</TD><TD CLASS="h">0%   (0/53)</TD></TR><TR><TD CLASS="f"><A HREF="#39">reportAccurateEnumConstructorReference (SearchMatch, FieldDeclaration, Alloca...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/95)</TD><TD CLASS="h">0%   (0/23)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3a">reportAccurateFieldReference (SearchMatch [], QualifiedNameReference): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/173)</TD><TD CLASS="h">0%   (0/49)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">reportAccurateParameterizedMethodReference (SearchMatch, ASTNode, TypeReferen...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/123)</TD><TD CLASS="h">0%   (0/30)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">reportAccurateParameterizedTypeReference (SearchMatch, TypeReference, int, Ty...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/157)</TD><TD CLASS="h">0%   (0/31)</TD></TR><TR><TD CLASS="f"><A HREF="#3d">reportAccurateTypeReference (SearchMatch, ASTNode, char []): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/82)</TD><TD CLASS="h">0%   (0/22)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">reportBinaryMemberDeclaration (IResource, IMember, Binding, IBinaryType, int)...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/68)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">reportMatching (CompilationUnitDeclaration, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/676)</TD><TD CLASS="h">0%   (0/114)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#40">reportMatching (FieldDeclaration, FieldDeclaration [], TypeDeclaration, IJava...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/311)</TD><TD CLASS="h">0%   (0/61)</TD></TR><TR><TD CLASS="f"><A HREF="#41">reportMatching (IJavaScriptElement, int, MatchingNodeSet, int): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/30)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">reportMatching (InferredAttribute, InferredType, IJavaScriptElement, int, boo...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#43">reportMatching (InferredType, IJavaScriptElement, int, MatchingNodeSet, int):...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/86)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">reportMatching (LocalDeclaration, LocalDeclaration [], TypeDeclaration, IJava...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/127)</TD><TD CLASS="h">0%   (0/26)</TD></TR><TR><TD CLASS="f"><A HREF="#45">reportMatching (TypeDeclaration, AbstractMethodDeclaration, IJavaScriptElemen...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/212)</TD><TD CLASS="h">0%   (0/46)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">reportMatching (TypeDeclaration, IJavaScriptElement, int, MatchingNodeSet, in...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/489)</TD><TD CLASS="h">0%   (0/89)</TD></TR><TR><TD CLASS="f"><A HREF="#47">reportMatching (TypeParameter [], IJavaScriptElement, IJavaScriptElement, Bin...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/131)</TD><TD CLASS="h">0%   (0/22)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">reportMatchingSuper (TypeReference, IJavaScriptElement, Binding, MatchingNode...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/99)</TD><TD CLASS="h">0%   (0/17)</TD></TR><TR><TD CLASS="f"><A HREF="#49">setFocus (InternalSearchPattern, IJavaScriptElement): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">typeInHierarchy (ReferenceBinding): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/40)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#4b">workingCopiesThatCanSeeFocus (IJavaScriptUnit [], IJavaScriptElement, boolean...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/57)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#b">MatchLocator$1</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/35)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR><TD CLASS="f"><A HREF="#b">MatchLocator$1 (int, int, SearchPattern, SearchPattern): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4e">currentPattern (): SearchPattern</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#4f">hasNextQuery (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">resetQuery (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#51">MatchLocator$2</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#51">MatchLocator$2 (MatchLocator): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#53">compare (Object, Object): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#54">MatchLocator$LocalDeclarationVisitor</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/95)</TD><TD CLASS="h">0%   (0/21)</TD></TR><TR><TD CLASS="f"><A HREF="#54">MatchLocator$LocalDeclarationVisitor (MatchLocator, IJavaScriptElement, Bindi...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/20)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#56">visit (TypeDeclaration, BlockScope): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/75)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#57">MatchLocator$ReportMatchingVisitor</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/91)</TD><TD CLASS="h">0%   (0/18)</TD></TR><TR><TD CLASS="f"><A HREF="#57">MatchLocator$ReportMatchingVisitor (MatchLocator, MatchingNodeSet, boolean, I...</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/18)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#59">visit (LocalDeclaration, BlockScope): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/37)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#5a">visit (MethodDeclaration, Scope): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/36)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#5b">MatchLocator$WorkingCopyDocument</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#5b">MatchLocator$WorkingCopyDocument (IJavaScriptUnit, SearchParticipant): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5d">toString (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#5e">MatchLocator$WrappedCoreException</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#5e">MatchLocator$WrappedCoreException (CoreException): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/3)</TD></TR></TABLE><P></P><TABLE CLASS="s" CELLSPACING="0" WIDTH="100%"><TR CLASS="z"><TD CLASS="l">1</TD><TD>/*******************************************************************************</TD></TR><TR><TD CLASS="l">2</TD><TD> * Copyright (c) 2000, 2009 IBM Corporation and others.</TD></TR><TR><TD CLASS="l">3</TD><TD> * All rights reserved. This program and the accompanying materials</TD></TR><TR><TD CLASS="l">4</TD><TD> * are made available under the terms of the Eclipse Public License v1.0</TD></TR><TR><TD CLASS="l">5</TD><TD> * which accompanies this distribution, and is available at</TD></TR><TR><TD CLASS="l">6</TD><TD> * http://www.eclipse.org/legal/epl-v10.html</TD></TR><TR><TD CLASS="l">7</TD><TD> *</TD></TR><TR><TD CLASS="l">8</TD><TD> * Contributors:</TD></TR><TR><TD CLASS="l">9</TD><TD> *     IBM Corporation - initial API and implementation</TD></TR><TR><TD CLASS="l">10</TD><TD> *******************************************************************************/</TD></TR><TR><TD CLASS="l">11</TD><TD>package org.eclipse.wst.jsdt.internal.core.search.matching;</TD></TR><TR><TD CLASS="l">12</TD><TD> </TD></TR><TR><TD CLASS="l">13</TD><TD>import java.io.IOException;</TD></TR><TR><TD CLASS="l">14</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">15</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">16</TD><TD>import java.util.HashSet;</TD></TR><TR><TD CLASS="l">17</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">18</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">19</TD><TD> </TD></TR><TR><TD CLASS="l">20</TD><TD>import org.eclipse.core.resources.IResource;</TD></TR><TR><TD CLASS="l">21</TD><TD>import org.eclipse.core.runtime.CoreException;</TD></TR><TR><TD CLASS="l">22</TD><TD>import org.eclipse.core.runtime.IPath;</TD></TR><TR><TD CLASS="l">23</TD><TD>import org.eclipse.core.runtime.IProgressMonitor;</TD></TR><TR><TD CLASS="l">24</TD><TD>import org.eclipse.core.runtime.OperationCanceledException;</TD></TR><TR><TD CLASS="l">25</TD><TD>import org.eclipse.wst.jsdt.core.IClassFile;</TD></TR><TR><TD CLASS="l">26</TD><TD>import org.eclipse.wst.jsdt.core.IField;</TD></TR><TR><TD CLASS="l">27</TD><TD>import org.eclipse.wst.jsdt.core.IFunction;</TD></TR><TR><TD CLASS="l">28</TD><TD>import org.eclipse.wst.jsdt.core.IJavaScriptElement;</TD></TR><TR><TD CLASS="l">29</TD><TD>import org.eclipse.wst.jsdt.core.IJavaScriptProject;</TD></TR><TR><TD CLASS="l">30</TD><TD>import org.eclipse.wst.jsdt.core.IMember;</TD></TR><TR><TD CLASS="l">31</TD><TD>import org.eclipse.wst.jsdt.core.IPackageFragment;</TD></TR><TR><TD CLASS="l">32</TD><TD>import org.eclipse.wst.jsdt.core.ISourceRange;</TD></TR><TR><TD CLASS="l">33</TD><TD>import org.eclipse.wst.jsdt.core.IType;</TD></TR><TR><TD CLASS="l">34</TD><TD>import org.eclipse.wst.jsdt.core.ITypeRoot;</TD></TR><TR><TD CLASS="l">35</TD><TD>import org.eclipse.wst.jsdt.core.JavaScriptModelException;</TD></TR><TR><TD CLASS="l">36</TD><TD>import org.eclipse.wst.jsdt.core.Signature;</TD></TR><TR><TD CLASS="l">37</TD><TD>import org.eclipse.wst.jsdt.core.compiler.CharOperation;</TD></TR><TR><TD CLASS="l">38</TD><TD>import org.eclipse.wst.jsdt.core.compiler.IProblem;</TD></TR><TR><TD CLASS="l">39</TD><TD>import org.eclipse.wst.jsdt.core.compiler.InvalidInputException;</TD></TR><TR><TD CLASS="l">40</TD><TD>import org.eclipse.wst.jsdt.core.infer.InferredAttribute;</TD></TR><TR><TD CLASS="l">41</TD><TD>import org.eclipse.wst.jsdt.core.infer.InferredMethod;</TD></TR><TR><TD CLASS="l">42</TD><TD>import org.eclipse.wst.jsdt.core.infer.InferredType;</TD></TR><TR><TD CLASS="l">43</TD><TD>import org.eclipse.wst.jsdt.core.search.FieldDeclarationMatch;</TD></TR><TR><TD CLASS="l">44</TD><TD>import org.eclipse.wst.jsdt.core.search.FieldReferenceMatch;</TD></TR><TR><TD CLASS="l">45</TD><TD>import org.eclipse.wst.jsdt.core.search.IJavaScriptSearchScope;</TD></TR><TR><TD CLASS="l">46</TD><TD>import org.eclipse.wst.jsdt.core.search.LocalVariableDeclarationMatch;</TD></TR><TR><TD CLASS="l">47</TD><TD>import org.eclipse.wst.jsdt.core.search.LocalVariableReferenceMatch;</TD></TR><TR><TD CLASS="l">48</TD><TD>import org.eclipse.wst.jsdt.core.search.MethodDeclarationMatch;</TD></TR><TR><TD CLASS="l">49</TD><TD>import org.eclipse.wst.jsdt.core.search.MethodReferenceMatch;</TD></TR><TR><TD CLASS="l">50</TD><TD>import org.eclipse.wst.jsdt.core.search.PackageDeclarationMatch;</TD></TR><TR><TD CLASS="l">51</TD><TD>import org.eclipse.wst.jsdt.core.search.PackageReferenceMatch;</TD></TR><TR><TD CLASS="l">52</TD><TD>import org.eclipse.wst.jsdt.core.search.SearchDocument;</TD></TR><TR><TD CLASS="l">53</TD><TD>import org.eclipse.wst.jsdt.core.search.SearchMatch;</TD></TR><TR><TD CLASS="l">54</TD><TD>import org.eclipse.wst.jsdt.core.search.SearchParticipant;</TD></TR><TR><TD CLASS="l">55</TD><TD>import org.eclipse.wst.jsdt.core.search.SearchPattern;</TD></TR><TR><TD CLASS="l">56</TD><TD>import org.eclipse.wst.jsdt.core.search.SearchRequestor;</TD></TR><TR><TD CLASS="l">57</TD><TD>import org.eclipse.wst.jsdt.core.search.TypeDeclarationMatch;</TD></TR><TR><TD CLASS="l">58</TD><TD>import org.eclipse.wst.jsdt.core.search.TypeParameterReferenceMatch;</TD></TR><TR><TD CLASS="l">59</TD><TD>import org.eclipse.wst.jsdt.core.search.TypeReferenceMatch;</TD></TR><TR><TD CLASS="l">60</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ASTVisitor;</TD></TR><TR><TD CLASS="l">61</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.CompilationResult;</TD></TR><TR><TD CLASS="l">62</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.DefaultErrorHandlingPolicies;</TD></TR><TR><TD CLASS="l">63</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.ASTNode;</TD></TR><TR><TD CLASS="l">64</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.AbstractMethodDeclaration;</TD></TR><TR><TD CLASS="l">65</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.AbstractVariableDeclaration;</TD></TR><TR><TD CLASS="l">66</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.AllocationExpression;</TD></TR><TR><TD CLASS="l">67</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.Argument;</TD></TR><TR><TD CLASS="l">68</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.ArrayTypeReference;</TD></TR><TR><TD CLASS="l">69</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.Block;</TD></TR><TR><TD CLASS="l">70</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.CompilationUnitDeclaration;</TD></TR><TR><TD CLASS="l">71</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.FieldDeclaration;</TD></TR><TR><TD CLASS="l">72</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.ImportReference;</TD></TR><TR><TD CLASS="l">73</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.Initializer;</TD></TR><TR><TD CLASS="l">74</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.LocalDeclaration;</TD></TR><TR><TD CLASS="l">75</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.MethodDeclaration;</TD></TR><TR><TD CLASS="l">76</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;</TD></TR><TR><TD CLASS="l">77</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.ParameterizedSingleTypeReference;</TD></TR><TR><TD CLASS="l">78</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.ProgramElement;</TD></TR><TR><TD CLASS="l">79</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.QualifiedAllocationExpression;</TD></TR><TR><TD CLASS="l">80</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.QualifiedNameReference;</TD></TR><TR><TD CLASS="l">81</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.QualifiedTypeReference;</TD></TR><TR><TD CLASS="l">82</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.TypeDeclaration;</TD></TR><TR><TD CLASS="l">83</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.TypeParameter;</TD></TR><TR><TD CLASS="l">84</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.ast.TypeReference;</TD></TR><TR><TD CLASS="l">85</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.classfmt.ClassFileConstants;</TD></TR><TR><TD CLASS="l">86</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.env.AccessRestriction;</TD></TR><TR><TD CLASS="l">87</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.env.IBinaryType;</TD></TR><TR><TD CLASS="l">88</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.env.ICompilationUnit;</TD></TR><TR><TD CLASS="l">89</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.env.INameEnvironment;</TD></TR><TR><TD CLASS="l">90</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.env.ISourceType;</TD></TR><TR><TD CLASS="l">91</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.impl.CompilerOptions;</TD></TR><TR><TD CLASS="l">92</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.impl.ITypeRequestor;</TD></TR><TR><TD CLASS="l">93</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.BinaryTypeBinding;</TD></TR><TR><TD CLASS="l">94</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.Binding;</TD></TR><TR><TD CLASS="l">95</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.BlockScope;</TD></TR><TR><TD CLASS="l">96</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.ClassScope;</TD></TR><TR><TD CLASS="l">97</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.CompilationUnitScope;</TD></TR><TR><TD CLASS="l">98</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.LookupEnvironment;</TD></TR><TR><TD CLASS="l">99</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.MethodBinding;</TD></TR><TR><TD CLASS="l">100</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.PackageBinding;</TD></TR><TR><TD CLASS="l">101</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.ProblemMethodBinding;</TD></TR><TR><TD CLASS="l">102</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.ProblemReasons;</TD></TR><TR><TD CLASS="l">103</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.ReferenceBinding;</TD></TR><TR><TD CLASS="l">104</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.Scope;</TD></TR><TR><TD CLASS="l">105</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.TagBits;</TD></TR><TR><TD CLASS="l">106</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.TypeBinding;</TD></TR><TR><TD CLASS="l">107</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.lookup.TypeVariableBinding;</TD></TR><TR><TD CLASS="l">108</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.parser.Parser;</TD></TR><TR><TD CLASS="l">109</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.parser.Scanner;</TD></TR><TR><TD CLASS="l">110</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.parser.SourceTypeConverter;</TD></TR><TR><TD CLASS="l">111</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.parser.TerminalTokens;</TD></TR><TR><TD CLASS="l">112</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.problem.AbortCompilation;</TD></TR><TR><TD CLASS="l">113</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.problem.AbortCompilationUnit;</TD></TR><TR><TD CLASS="l">114</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.problem.DefaultProblemFactory;</TD></TR><TR><TD CLASS="l">115</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.problem.ProblemReporter;</TD></TR><TR><TD CLASS="l">116</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.util.HashtableOfIntValues;</TD></TR><TR><TD CLASS="l">117</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.util.Messages;</TD></TR><TR><TD CLASS="l">118</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.util.SimpleLookupTable;</TD></TR><TR><TD CLASS="l">119</TD><TD>import org.eclipse.wst.jsdt.internal.compiler.util.SimpleSet;</TD></TR><TR><TD CLASS="l">120</TD><TD>import org.eclipse.wst.jsdt.internal.core.BinaryMember;</TD></TR><TR><TD CLASS="l">121</TD><TD>import org.eclipse.wst.jsdt.internal.core.BinaryType;</TD></TR><TR><TD CLASS="l">122</TD><TD>import org.eclipse.wst.jsdt.internal.core.ClassFile;</TD></TR><TR><TD CLASS="l">123</TD><TD>import org.eclipse.wst.jsdt.internal.core.CompilationUnit;</TD></TR><TR><TD CLASS="l">124</TD><TD>import org.eclipse.wst.jsdt.internal.core.JavaElement;</TD></TR><TR><TD CLASS="l">125</TD><TD>import org.eclipse.wst.jsdt.internal.core.JavaModelManager;</TD></TR><TR><TD CLASS="l">126</TD><TD>import org.eclipse.wst.jsdt.internal.core.JavaProject;</TD></TR><TR><TD CLASS="l">127</TD><TD>import org.eclipse.wst.jsdt.internal.core.LibraryFragmentRoot;</TD></TR><TR><TD CLASS="l">128</TD><TD>import org.eclipse.wst.jsdt.internal.core.LocalVariable;</TD></TR><TR><TD CLASS="l">129</TD><TD>import org.eclipse.wst.jsdt.internal.core.MetadataFile;</TD></TR><TR><TD CLASS="l">130</TD><TD>import org.eclipse.wst.jsdt.internal.core.NameLookup;</TD></TR><TR><TD CLASS="l">131</TD><TD>import org.eclipse.wst.jsdt.internal.core.Openable;</TD></TR><TR><TD CLASS="l">132</TD><TD>import org.eclipse.wst.jsdt.internal.core.SearchableEnvironment;</TD></TR><TR><TD CLASS="l">133</TD><TD>import org.eclipse.wst.jsdt.internal.core.SourceMapper;</TD></TR><TR><TD CLASS="l">134</TD><TD>import org.eclipse.wst.jsdt.internal.core.SourceMethod;</TD></TR><TR><TD CLASS="l">135</TD><TD>import org.eclipse.wst.jsdt.internal.core.SourceTypeElementInfo;</TD></TR><TR><TD CLASS="l">136</TD><TD>import org.eclipse.wst.jsdt.internal.core.hierarchy.HierarchyResolver;</TD></TR><TR><TD CLASS="l">137</TD><TD>import org.eclipse.wst.jsdt.internal.core.index.Index;</TD></TR><TR><TD CLASS="l">138</TD><TD>import org.eclipse.wst.jsdt.internal.core.search.BasicSearchEngine;</TD></TR><TR><TD CLASS="l">139</TD><TD>import org.eclipse.wst.jsdt.internal.core.search.HierarchyScope;</TD></TR><TR><TD CLASS="l">140</TD><TD>import org.eclipse.wst.jsdt.internal.core.search.IndexQueryRequestor;</TD></TR><TR><TD CLASS="l">141</TD><TD>import org.eclipse.wst.jsdt.internal.core.search.IndexSelector;</TD></TR><TR><TD CLASS="l">142</TD><TD>import org.eclipse.wst.jsdt.internal.core.search.JavaSearchDocument;</TD></TR><TR><TD CLASS="l">143</TD><TD>import org.eclipse.wst.jsdt.internal.core.util.HandleFactory;</TD></TR><TR><TD CLASS="l">144</TD><TD>import org.eclipse.wst.jsdt.internal.core.util.Util;</TD></TR><TR><TD CLASS="l">145</TD><TD>import org.eclipse.wst.jsdt.internal.oaametadata.LibraryAPIs;</TD></TR><TR><TD CLASS="l">146</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="0">147</A></TD><TD>public class MatchLocator implements ITypeRequestor {</TD></TR><TR><TD CLASS="l">148</TD><TD> </TD></TR><TR><TD CLASS="l">149</TD><TD>public static final int MAX_AT_ONCE;</TD></TR><TR><TD CLASS="l">150</TD><TD>static {</TD></TR><TR CLASS="z"><TD CLASS="l">151</TD><TD>        long maxMemory = Runtime.getRuntime().maxMemory();</TD></TR><TR CLASS="z"><TD CLASS="l">152</TD><TD>        int ratio = (int) Math.round(((double) maxMemory) / (64 * 0x100000));</TD></TR><TR CLASS="z"><TD CLASS="l">153</TD><TD>        switch (ratio) {</TD></TR><TR><TD CLASS="l">154</TD><TD>                case 0:</TD></TR><TR><TD CLASS="l">155</TD><TD>                case 1:</TD></TR><TR CLASS="z"><TD CLASS="l">156</TD><TD>                        MAX_AT_ONCE = 100;</TD></TR><TR CLASS="z"><TD CLASS="l">157</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">158</TD><TD>                case 2:</TD></TR><TR CLASS="z"><TD CLASS="l">159</TD><TD>                        MAX_AT_ONCE = 200;</TD></TR><TR CLASS="z"><TD CLASS="l">160</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">161</TD><TD>                case 3:</TD></TR><TR CLASS="z"><TD CLASS="l">162</TD><TD>                        MAX_AT_ONCE = 300;</TD></TR><TR CLASS="z"><TD CLASS="l">163</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">164</TD><TD>                default:</TD></TR><TR CLASS="z"><TD CLASS="l">165</TD><TD>                        MAX_AT_ONCE = 400;</TD></TR><TR><TD CLASS="l">166</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">167</TD><TD>        }</TD></TR><TR><TD CLASS="l">168</TD><TD>}</TD></TR><TR><TD CLASS="l">169</TD><TD> </TD></TR><TR><TD CLASS="l">170</TD><TD>// permanent state</TD></TR><TR><TD CLASS="l">171</TD><TD>public SearchPattern pattern;</TD></TR><TR><TD CLASS="l">172</TD><TD>public PatternLocator patternLocator;</TD></TR><TR><TD CLASS="l">173</TD><TD>public int matchContainer;</TD></TR><TR><TD CLASS="l">174</TD><TD>public SearchRequestor requestor;</TD></TR><TR><TD CLASS="l">175</TD><TD>public IJavaScriptSearchScope scope;</TD></TR><TR><TD CLASS="l">176</TD><TD>public IProgressMonitor progressMonitor;</TD></TR><TR><TD CLASS="l">177</TD><TD> </TD></TR><TR><TD CLASS="l">178</TD><TD>public org.eclipse.wst.jsdt.core.IJavaScriptUnit[] workingCopies;</TD></TR><TR><TD CLASS="l">179</TD><TD>public HandleFactory handleFactory;</TD></TR><TR><TD CLASS="l">180</TD><TD> </TD></TR><TR><TD CLASS="l">181</TD><TD>// cache of all super type names if scope is hierarchy scope</TD></TR><TR><TD CLASS="l">182</TD><TD>public char[][][] allSuperTypeNames;</TD></TR><TR><TD CLASS="l">183</TD><TD> </TD></TR><TR><TD CLASS="l">184</TD><TD>// the following is valid for the current project</TD></TR><TR><TD CLASS="l">185</TD><TD>public MatchLocatorParser parser;</TD></TR><TR><TD CLASS="l">186</TD><TD>private Parser basicParser;</TD></TR><TR><TD CLASS="l">187</TD><TD>public INameEnvironment nameEnvironment;</TD></TR><TR><TD CLASS="l">188</TD><TD>public NameLookup nameLookup;</TD></TR><TR><TD CLASS="l">189</TD><TD>public LookupEnvironment lookupEnvironment;</TD></TR><TR><TD CLASS="l">190</TD><TD>public HierarchyResolver hierarchyResolver;</TD></TR><TR><TD CLASS="l">191</TD><TD> </TD></TR><TR><TD CLASS="l">192</TD><TD>public CompilerOptions options;</TD></TR><TR><TD CLASS="l">193</TD><TD> </TD></TR><TR><TD CLASS="l">194</TD><TD>// management of PossibleMatch to be processed</TD></TR><TR><TD CLASS="l">195</TD><TD>public int numberOfMatches; // (numberOfMatches - 1) is the last unit in matchesToProcess</TD></TR><TR><TD CLASS="l">196</TD><TD>public PossibleMatch[] matchesToProcess;</TD></TR><TR><TD CLASS="l">197</TD><TD>public PossibleMatch currentPossibleMatch;</TD></TR><TR><TD CLASS="l">198</TD><TD> </TD></TR><TR><TD CLASS="l">199</TD><TD>/*</TD></TR><TR><TD CLASS="l">200</TD><TD> * Time spent in the IJavaScriptSearchResultCollector</TD></TR><TR><TD CLASS="l">201</TD><TD> */</TD></TR><TR CLASS="z"><TD CLASS="l">202</TD><TD>public long resultCollectorTime = 0;</TD></TR><TR><TD CLASS="l">203</TD><TD> </TD></TR><TR><TD CLASS="l">204</TD><TD>// Progress information</TD></TR><TR><TD CLASS="l">205</TD><TD>int progressStep;</TD></TR><TR><TD CLASS="l">206</TD><TD>int progressWorked;</TD></TR><TR><TD CLASS="l">207</TD><TD> </TD></TR><TR><TD CLASS="l">208</TD><TD>// Binding resolution and cache</TD></TR><TR><TD CLASS="l">209</TD><TD>CompilationUnitScope unitScope;</TD></TR><TR><TD CLASS="l">210</TD><TD>SimpleLookupTable bindings;</TD></TR><TR><TD CLASS="l">211</TD><TD> </TD></TR><TR><TD CLASS="l">212</TD><TD>// Cache for method handles</TD></TR><TR><TD CLASS="l">213</TD><TD>HashSet methodHandles;</TD></TR><TR><TD CLASS="l">214</TD><TD> </TD></TR><TR><TD CLASS="l">215</TD><TD> </TD></TR><TR><TD CLASS="l">216</TD><TD>class ReportMatchingVisitor extends ASTVisitor</TD></TR><TR><TD CLASS="l">217</TD><TD>{</TD></TR><TR><TD CLASS="l">218</TD><TD>        MatchingNodeSet nodeSet;</TD></TR><TR><TD CLASS="l">219</TD><TD>        boolean matchedClassContainer;</TD></TR><TR><TD CLASS="l">220</TD><TD>        IJavaScriptElement enclosingElement;</TD></TR><TR><TD CLASS="l"><A NAME="57">221</A></TD><TD>        boolean typeInHierarchy;</TD></TR><TR><TD CLASS="l">222</TD><TD>        CoreException exception;</TD></TR><TR><TD CLASS="l">223</TD><TD> </TD></TR><TR><TD CLASS="l">224</TD><TD>        public ReportMatchingVisitor(MatchingNodeSet nodeSet, boolean matchedClassContainer, IJavaScriptElement enclosingElement, boolean typeInHierarchy) {</TD></TR><TR CLASS="z"><TD CLASS="l">225</TD><TD>                super();</TD></TR><TR CLASS="z"><TD CLASS="l">226</TD><TD>                this.nodeSet = nodeSet;</TD></TR><TR CLASS="z"><TD CLASS="l">227</TD><TD>                this.matchedClassContainer = matchedClassContainer;</TD></TR><TR CLASS="z"><TD CLASS="l">228</TD><TD>                this.enclosingElement = enclosingElement;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="59">229</A></TD><TD>                this.typeInHierarchy = typeInHierarchy;</TD></TR><TR CLASS="z"><TD CLASS="l">230</TD><TD>        }</TD></TR><TR><TD CLASS="l">231</TD><TD> </TD></TR><TR><TD CLASS="l">232</TD><TD>        public boolean visit(LocalDeclaration localDeclaration, BlockScope scope) {</TD></TR><TR CLASS="z"><TD CLASS="l">233</TD><TD>                Integer level = (Integer) nodeSet.matchingNodes.removeKey(localDeclaration);</TD></TR><TR CLASS="z"><TD CLASS="l">234</TD><TD>                int accuracy = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR><TD CLASS="l">235</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">236</TD><TD>                        reportMatching(localDeclaration, null, null, enclosingElement, accuracy, typeInHierarchy, nodeSet);</TD></TR><TR CLASS="z"><TD CLASS="l">237</TD><TD>                } catch (CoreException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">238</TD><TD>                        exception=e;</TD></TR><TR><TD CLASS="l">239</TD><TD>                }</TD></TR><TR><TD CLASS="l">240</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5a">241</A></TD><TD>                return false;</TD></TR><TR><TD CLASS="l">242</TD><TD>        }</TD></TR><TR><TD CLASS="l">243</TD><TD> </TD></TR><TR><TD CLASS="l">244</TD><TD>        public boolean visit(MethodDeclaration methodDeclaration, Scope parentScope) {</TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>                Integer level = (Integer) nodeSet.matchingNodes.removeKey(methodDeclaration);</TD></TR><TR CLASS="z"><TD CLASS="l">246</TD><TD>                int value = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR><TD CLASS="l">247</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">248</TD><TD>                        reportMatching(null, methodDeclaration, enclosingElement, value, typeInHierarchy, nodeSet);</TD></TR><TR CLASS="z"><TD CLASS="l">249</TD><TD>                } catch (CoreException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">250</TD><TD>                        exception=e;</TD></TR><TR><TD CLASS="l">251</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">252</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">253</TD><TD>        }</TD></TR><TR><TD CLASS="l">254</TD><TD> </TD></TR><TR><TD CLASS="l">255</TD><TD>}</TD></TR><TR><TD CLASS="l">256</TD><TD> </TD></TR><TR><TD CLASS="l">257</TD><TD> </TD></TR><TR><TD CLASS="l">258</TD><TD>/**</TD></TR><TR><TD CLASS="l">259</TD><TD> * An ast visitor that visits local type declarations.</TD></TR><TR><TD CLASS="l">260</TD><TD> */</TD></TR><TR><TD CLASS="l">261</TD><TD>public class LocalDeclarationVisitor extends ASTVisitor {</TD></TR><TR><TD CLASS="l"><A NAME="54">262</A></TD><TD>        IJavaScriptElement enclosingElement;</TD></TR><TR><TD CLASS="l">263</TD><TD>        Binding enclosingElementBinding;</TD></TR><TR><TD CLASS="l">264</TD><TD>        MatchingNodeSet nodeSet;</TD></TR><TR CLASS="z"><TD CLASS="l">265</TD><TD>        HashtableOfIntValues occurrencesCounts = new HashtableOfIntValues(); // key = class name (char[]), value = occurrenceCount (int)</TD></TR><TR CLASS="z"><TD CLASS="l">266</TD><TD>        public LocalDeclarationVisitor(IJavaScriptElement enclosingElement, Binding enclosingElementBinding, MatchingNodeSet nodeSet) {</TD></TR><TR CLASS="z"><TD CLASS="l">267</TD><TD>                this.enclosingElement = enclosingElement;</TD></TR><TR CLASS="z"><TD CLASS="l">268</TD><TD>                this.enclosingElementBinding = enclosingElementBinding;</TD></TR><TR CLASS="z"><TD CLASS="l">269</TD><TD>                this.nodeSet = nodeSet;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="56">270</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">271</TD><TD>        public boolean visit(TypeDeclaration typeDeclaration, BlockScope unused) {</TD></TR><TR><TD CLASS="l">272</TD><TD>                try {</TD></TR><TR><TD CLASS="l">273</TD><TD>                        char[] simpleName;</TD></TR><TR CLASS="z"><TD CLASS="l">274</TD><TD>                        if ((typeDeclaration.bits &amp; ASTNode.IsAnonymousType) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>                                simpleName = CharOperation.NO_CHAR;</TD></TR><TR><TD CLASS="l">276</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">277</TD><TD>                                simpleName = typeDeclaration.name;</TD></TR><TR><TD CLASS="l">278</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">279</TD><TD>                        int occurrenceCount = occurrencesCounts.get(simpleName);</TD></TR><TR CLASS="z"><TD CLASS="l">280</TD><TD>                        if (occurrenceCount == HashtableOfIntValues.NO_VALUE) {</TD></TR><TR CLASS="z"><TD CLASS="l">281</TD><TD>                                occurrenceCount = 1;</TD></TR><TR><TD CLASS="l">282</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">283</TD><TD>                                occurrenceCount = occurrenceCount + 1;</TD></TR><TR><TD CLASS="l">284</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">285</TD><TD>                        occurrencesCounts.put(simpleName, occurrenceCount);</TD></TR><TR CLASS="z"><TD CLASS="l">286</TD><TD>                        if ((typeDeclaration.bits &amp; ASTNode.IsAnonymousType) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">287</TD><TD>                                reportMatching(typeDeclaration, this.enclosingElement, -1, nodeSet, occurrenceCount);</TD></TR><TR><TD CLASS="l">288</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">289</TD><TD>                                Integer level = (Integer) nodeSet.matchingNodes.removeKey(typeDeclaration);</TD></TR><TR CLASS="z"><TD CLASS="l">290</TD><TD>                                reportMatching(typeDeclaration, this.enclosingElement, level != null ? level.intValue() : -1, nodeSet, occurrenceCount);</TD></TR><TR><TD CLASS="l">291</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">292</TD><TD>                        return false; // don't visit members as this was done during reportMatching(...)</TD></TR><TR CLASS="z"><TD CLASS="l">293</TD><TD>                } catch (CoreException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">294</TD><TD>                        throw new WrappedCoreException(e);</TD></TR><TR><TD CLASS="l">295</TD><TD>                }</TD></TR><TR><TD CLASS="l">296</TD><TD>        }</TD></TR><TR><TD CLASS="l">297</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="5b">298</A></TD><TD> </TD></TR><TR><TD CLASS="l">299</TD><TD>public static class WorkingCopyDocument extends JavaSearchDocument {</TD></TR><TR><TD CLASS="l">300</TD><TD>        public org.eclipse.wst.jsdt.core.IJavaScriptUnit workingCopy;</TD></TR><TR><TD CLASS="l">301</TD><TD>        WorkingCopyDocument(org.eclipse.wst.jsdt.core.IJavaScriptUnit workingCopy, SearchParticipant participant) {</TD></TR><TR CLASS="z"><TD CLASS="l">302</TD><TD>                super(workingCopy.getPath().toString(), participant);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="5d">303</A></TD><TD>                this.charContents = ((CompilationUnit)workingCopy).getContents();</TD></TR><TR CLASS="z"><TD CLASS="l">304</TD><TD>                this.workingCopy = workingCopy;</TD></TR><TR CLASS="z"><TD CLASS="l">305</TD><TD>        }</TD></TR><TR><TD CLASS="l">306</TD><TD>        public String toString() {</TD></TR><TR CLASS="z"><TD CLASS="l">307</TD><TD>                return &#34;WorkingCopyDocument for &#34; + getPath(); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">308</TD><TD>        }</TD></TR><TR><TD CLASS="l">309</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="5e">310</A></TD><TD> </TD></TR><TR><TD CLASS="l">311</TD><TD>public static class WrappedCoreException extends RuntimeException {</TD></TR><TR><TD CLASS="l">312</TD><TD>        private static final long serialVersionUID = 8354329870126121212L; // backward compatible</TD></TR><TR><TD CLASS="l">313</TD><TD>        public CoreException coreException;</TD></TR><TR CLASS="z"><TD CLASS="l">314</TD><TD>        public WrappedCoreException(CoreException coreException) {</TD></TR><TR CLASS="z"><TD CLASS="l">315</TD><TD>                this.coreException = coreException;</TD></TR><TR CLASS="z"><TD CLASS="l">316</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="7">317</A></TD><TD>}</TD></TR><TR><TD CLASS="l">318</TD><TD> </TD></TR><TR><TD CLASS="l">319</TD><TD>public static SearchDocument[] addWorkingCopies(InternalSearchPattern pattern, SearchDocument[] indexMatches, org.eclipse.wst.jsdt.core.IJavaScriptUnit[] copies, SearchParticipant participant) {</TD></TR><TR><TD CLASS="l">320</TD><TD>        // working copies take precedence over corresponding compilation units</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>        HashMap workingCopyDocuments = workingCopiesThatCanSeeFocus(copies, pattern.focus, pattern.isPolymorphicSearch(), participant);</TD></TR><TR CLASS="z"><TD CLASS="l">322</TD><TD>        SearchDocument[] matches = null;</TD></TR><TR CLASS="z"><TD CLASS="l">323</TD><TD>        int length = indexMatches.length;</TD></TR><TR CLASS="z"><TD CLASS="l">324</TD><TD>        for (int i = 0; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">325</TD><TD>                SearchDocument searchDocument = indexMatches[i];</TD></TR><TR CLASS="z"><TD CLASS="l">326</TD><TD>                if (searchDocument.getParticipant() == participant) {</TD></TR><TR CLASS="z"><TD CLASS="l">327</TD><TD>                        SearchDocument workingCopyDocument = (SearchDocument) workingCopyDocuments.remove(searchDocument.getPath());</TD></TR><TR CLASS="z"><TD CLASS="l">328</TD><TD>                        if (workingCopyDocument != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">329</TD><TD>                                if (matches == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">330</TD><TD>                                        System.arraycopy(indexMatches, 0, matches = new SearchDocument[length], 0, length);</TD></TR><TR><TD CLASS="l">331</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">332</TD><TD>                                matches[i] = workingCopyDocument;</TD></TR><TR><TD CLASS="l">333</TD><TD>                        }</TD></TR><TR><TD CLASS="l">334</TD><TD>                }</TD></TR><TR><TD CLASS="l">335</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">336</TD><TD>        if (matches == null) { // no working copy</TD></TR><TR CLASS="z"><TD CLASS="l">337</TD><TD>                matches = indexMatches;</TD></TR><TR><TD CLASS="l">338</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">339</TD><TD>        int remainingWorkingCopiesSize = workingCopyDocuments.size();</TD></TR><TR CLASS="z"><TD CLASS="l">340</TD><TD>        if (remainingWorkingCopiesSize != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">341</TD><TD>                System.arraycopy(matches, 0, matches = new SearchDocument[length+remainingWorkingCopiesSize], 0, length);</TD></TR><TR CLASS="z"><TD CLASS="l">342</TD><TD>                Iterator iterator = workingCopyDocuments.values().iterator();</TD></TR><TR CLASS="z"><TD CLASS="l">343</TD><TD>                int index = length;</TD></TR><TR CLASS="z"><TD CLASS="l">344</TD><TD>                while (iterator.hasNext()) {</TD></TR><TR CLASS="z"><TD CLASS="l">345</TD><TD>                        matches[index++] = (SearchDocument) iterator.next();</TD></TR><TR><TD CLASS="l">346</TD><TD>                }</TD></TR><TR><TD CLASS="l">347</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="49">348</A></TD><TD>        return matches;</TD></TR><TR><TD CLASS="l">349</TD><TD>}</TD></TR><TR><TD CLASS="l">350</TD><TD> </TD></TR><TR><TD CLASS="l">351</TD><TD>public static void setFocus(InternalSearchPattern pattern, IJavaScriptElement focus) {</TD></TR><TR CLASS="z"><TD CLASS="l">352</TD><TD>        pattern.focus = focus;</TD></TR><TR CLASS="z"><TD CLASS="l">353</TD><TD>}</TD></TR><TR><TD CLASS="l">354</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="4b">355</A></TD><TD>/*</TD></TR><TR><TD CLASS="l">356</TD><TD> * Returns the working copies that can see the given focus.</TD></TR><TR><TD CLASS="l">357</TD><TD> */</TD></TR><TR><TD CLASS="l">358</TD><TD>private static HashMap workingCopiesThatCanSeeFocus(org.eclipse.wst.jsdt.core.IJavaScriptUnit[] copies, IJavaScriptElement focus, boolean isPolymorphicSearch, SearchParticipant participant) {</TD></TR><TR CLASS="z"><TD CLASS="l">359</TD><TD>        if (copies == null) return new HashMap();</TD></TR><TR CLASS="z"><TD CLASS="l">360</TD><TD>        if (focus != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">361</TD><TD>                while (!(focus instanceof IJavaScriptProject)) {</TD></TR><TR CLASS="z"><TD CLASS="l">362</TD><TD>                        focus = focus.getParent();</TD></TR><TR><TD CLASS="l">363</TD><TD>                }</TD></TR><TR><TD CLASS="l">364</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">365</TD><TD>        HashMap result = new HashMap();</TD></TR><TR CLASS="z"><TD CLASS="l">366</TD><TD>        for (int i=0, length = copies.length; i&lt;length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">367</TD><TD>                org.eclipse.wst.jsdt.core.IJavaScriptUnit workingCopy = copies[i];</TD></TR><TR CLASS="z"><TD CLASS="l">368</TD><TD>                IPath projectOrJar = MatchLocator.getProjectOrJar(workingCopy).getPath();</TD></TR><TR CLASS="z"><TD CLASS="l">369</TD><TD>                if (focus == null || IndexSelector.canSeeFocus(focus, isPolymorphicSearch, projectOrJar)) {</TD></TR><TR CLASS="z"><TD CLASS="l">370</TD><TD>                        result.put(</TD></TR><TR CLASS="z"><TD CLASS="l">371</TD><TD>                                workingCopy.getPath().toString(),</TD></TR><TR CLASS="z"><TD CLASS="l">372</TD><TD>                                new WorkingCopyDocument(workingCopy, participant)</TD></TR><TR><TD CLASS="l">373</TD><TD>                        );</TD></TR><TR><TD CLASS="l">374</TD><TD>                }</TD></TR><TR><TD CLASS="l">375</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">376</TD><TD>        return result;</TD></TR><TR><TD CLASS="l"><A NAME="b">377</A></TD><TD>}</TD></TR><TR><TD CLASS="l">378</TD><TD> </TD></TR><TR><TD CLASS="l">379</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="4e">380</A></TD><TD>public static SearchPattern createAndPattern(final SearchPattern leftPattern, final SearchPattern rightPattern) {</TD></TR><TR CLASS="z"><TD CLASS="l">381</TD><TD>        return new AndPattern(0/*no kind*/, 0/*no rule*/) {</TD></TR><TR CLASS="z"><TD CLASS="l">382</TD><TD>                SearchPattern current = leftPattern;</TD></TR><TR><TD CLASS="l"><A NAME="4f">383</A></TD><TD>                public SearchPattern currentPattern() {</TD></TR><TR CLASS="z"><TD CLASS="l">384</TD><TD>                        return this.current;</TD></TR><TR><TD CLASS="l">385</TD><TD>                }</TD></TR><TR><TD CLASS="l">386</TD><TD>                protected boolean hasNextQuery() {</TD></TR><TR CLASS="z"><TD CLASS="l">387</TD><TD>                        if (this.current == leftPattern) {</TD></TR><TR CLASS="z"><TD CLASS="l">388</TD><TD>                                this.current = rightPattern;</TD></TR><TR CLASS="z"><TD CLASS="l">389</TD><TD>                                return true;</TD></TR><TR><TD CLASS="l"><A NAME="50">390</A></TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">391</TD><TD>                        return false;</TD></TR><TR><TD CLASS="l">392</TD><TD>                }</TD></TR><TR><TD CLASS="l">393</TD><TD>                protected void resetQuery() {</TD></TR><TR CLASS="z"><TD CLASS="l">394</TD><TD>                        this.current = leftPattern;</TD></TR><TR CLASS="z"><TD CLASS="l">395</TD><TD>                }</TD></TR><TR><TD CLASS="l">396</TD><TD>        };</TD></TR><TR><TD CLASS="l">397</TD><TD>}</TD></TR><TR><TD CLASS="l">398</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="17">399</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">400</TD><TD> * Query a given index for matching entries. Assumes the sender has opened the index and will close when finished.</TD></TR><TR><TD CLASS="l">401</TD><TD> */</TD></TR><TR><TD CLASS="l">402</TD><TD>public static void findIndexMatches(InternalSearchPattern pattern, Index index, IndexQueryRequestor requestor, SearchParticipant participant, IJavaScriptSearchScope scope, IProgressMonitor monitor) throws IOException {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1e">403</A></TD><TD>        pattern.findIndexMatches(index, requestor, participant, scope, monitor);</TD></TR><TR CLASS="z"><TD CLASS="l">404</TD><TD>}</TD></TR><TR><TD CLASS="l">405</TD><TD> </TD></TR><TR><TD CLASS="l">406</TD><TD>public static IJavaScriptElement getProjectOrJar(IJavaScriptElement element) {</TD></TR><TR CLASS="z"><TD CLASS="l">407</TD><TD>        while (!(element instanceof IJavaScriptProject) &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">408</TD><TD>                        !( element instanceof LibraryFragmentRoot)) {</TD></TR><TR CLASS="z"><TD CLASS="l">409</TD><TD>                element = element.getParent();</TD></TR><TR><TD CLASS="l">410</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="34">411</A></TD><TD>        return element;</TD></TR><TR><TD CLASS="l">412</TD><TD>}</TD></TR><TR><TD CLASS="l">413</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="2">414</A></TD><TD>public static IJavaScriptElement projectOrJarFocus(InternalSearchPattern pattern) {</TD></TR><TR CLASS="z"><TD CLASS="l">415</TD><TD>        return pattern == null || pattern.focus == null ? null : getProjectOrJar(pattern.focus);</TD></TR><TR><TD CLASS="l">416</TD><TD>}</TD></TR><TR><TD CLASS="l">417</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">418</TD><TD>public MatchLocator(</TD></TR><TR><TD CLASS="l">419</TD><TD>        SearchPattern pattern,</TD></TR><TR><TD CLASS="l">420</TD><TD>        SearchRequestor requestor,</TD></TR><TR><TD CLASS="l">421</TD><TD>        IJavaScriptSearchScope scope,</TD></TR><TR><TD CLASS="l">422</TD><TD>        IProgressMonitor progressMonitor) {</TD></TR><TR><TD CLASS="l">423</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">424</TD><TD>        this.pattern = pattern;</TD></TR><TR CLASS="z"><TD CLASS="l">425</TD><TD>        this.patternLocator = PatternLocator.patternLocator(this.pattern);</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>        this.matchContainer = this.patternLocator.matchContainer();</TD></TR><TR CLASS="z"><TD CLASS="l">427</TD><TD>        this.requestor = requestor;</TD></TR><TR CLASS="z"><TD CLASS="l">428</TD><TD>        this.scope = scope;</TD></TR><TR CLASS="z"><TD CLASS="l">429</TD><TD>        this.progressMonitor = progressMonitor;</TD></TR><TR CLASS="z"><TD CLASS="l">430</TD><TD>}</TD></TR><TR><TD CLASS="l">431</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="3">432</A></TD><TD> * Add an additional binary type</TD></TR><TR><TD CLASS="l">433</TD><TD> */</TD></TR><TR><TD CLASS="l">434</TD><TD>public void accept(IBinaryType binaryType, PackageBinding packageBinding, AccessRestriction accessRestriction) {</TD></TR><TR><TD CLASS="l">435</TD><TD>        /* commented out below is the original code with a compilation error */</TD></TR><TR CLASS="z"><TD CLASS="l">436</TD><TD>        System.out.println(&#34;Bad call to method-- IMPLEMENT MatchLocator. accept(IBinaryType binaryType, PackageBinding packageBinding, AccessRestriction accessRestriction) &#34;); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">437</TD><TD>        //this.lookupEnvironment.createBinaryTypeFrom(binaryType., packageBinding, accessRestriction);</TD></TR><TR CLASS="z"><TD CLASS="l">438</TD><TD>}</TD></TR><TR><TD CLASS="l">439</TD><TD>/**</TD></TR><TR><TD CLASS="l">440</TD><TD> * Add an additional compilation unit into the loop</TD></TR><TR><TD CLASS="l"><A NAME="4">441</A></TD><TD> *  -&gt;  build compilation unit declarations, their bindings and record their results.</TD></TR><TR><TD CLASS="l">442</TD><TD> */</TD></TR><TR><TD CLASS="l">443</TD><TD>public void accept(ICompilationUnit sourceUnit, AccessRestriction accessRestriction) {</TD></TR><TR><TD CLASS="l">444</TD><TD>        // Switch the current policy and compilation result for this unit to the requested one.</TD></TR><TR CLASS="z"><TD CLASS="l">445</TD><TD>        CompilationResult unitResult = new CompilationResult(sourceUnit, 1, 1, this.options.maxProblemsPerUnit);</TD></TR><TR><TD CLASS="l">446</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">447</TD><TD>                Parser parser = basicParser();</TD></TR><TR CLASS="z"><TD CLASS="l">448</TD><TD>                CompilationUnitDeclaration parsedUnit = parser.dietParse(sourceUnit, unitResult);</TD></TR><TR CLASS="z"><TD CLASS="l">449</TD><TD>                parser.inferTypes(parsedUnit, this.options);</TD></TR><TR CLASS="z"><TD CLASS="l">450</TD><TD>                this.lookupEnvironment.buildTypeBindings(parsedUnit, accessRestriction);</TD></TR><TR CLASS="z"><TD CLASS="l">451</TD><TD>                this.lookupEnvironment.completeTypeBindings(parsedUnit, true);</TD></TR><TR CLASS="z"><TD CLASS="l">452</TD><TD>        } catch (AbortCompilationUnit e) {</TD></TR><TR><TD CLASS="l">453</TD><TD>                // at this point, currentCompilationUnitResult may not be sourceUnit, but some other</TD></TR><TR><TD CLASS="l">454</TD><TD>                // one requested further along to resolve sourceUnit.</TD></TR><TR CLASS="z"><TD CLASS="l">455</TD><TD>                if (unitResult.compilationUnit == sourceUnit) { // only report once</TD></TR><TR><TD CLASS="l">456</TD><TD>                        //requestor.acceptResult(unitResult.tagAsAccepted());</TD></TR><TR><TD CLASS="l">457</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">458</TD><TD>                        throw e; // want to abort enclosing request to compile</TD></TR><TR><TD CLASS="l">459</TD><TD>                }</TD></TR><TR><TD CLASS="l">460</TD><TD>        }</TD></TR><TR><TD CLASS="l">461</TD><TD>        // Display unit error in debug mode</TD></TR><TR CLASS="z"><TD CLASS="l">462</TD><TD>        if (BasicSearchEngine.VERBOSE) {</TD></TR><TR CLASS="z"><TD CLASS="l">463</TD><TD>                if (unitResult.problemCount &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">464</TD><TD>                        System.out.println(unitResult);</TD></TR><TR><TD CLASS="l">465</TD><TD>                }</TD></TR><TR><TD CLASS="l">466</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">467</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="6">468</A></TD><TD> </TD></TR><TR><TD CLASS="l">469</TD><TD> </TD></TR><TR><TD CLASS="l">470</TD><TD>public void accept(LibraryAPIs libraryMetaData)</TD></TR><TR><TD CLASS="l">471</TD><TD>{</TD></TR><TR CLASS="z"><TD CLASS="l">472</TD><TD>        lookupEnvironment.buildTypeBindings(libraryMetaData);</TD></TR><TR><TD CLASS="l">473</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">474</TD><TD>}</TD></TR><TR><TD CLASS="l">475</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="5">476</A></TD><TD> * Add additional source types</TD></TR><TR><TD CLASS="l">477</TD><TD> */</TD></TR><TR><TD CLASS="l">478</TD><TD>public void accept(ISourceType[] sourceTypes, PackageBinding packageBinding, AccessRestriction accessRestriction) {</TD></TR><TR><TD CLASS="l">479</TD><TD>        // case of SearchableEnvironment of an IJavaScriptProject is used</TD></TR><TR CLASS="z"><TD CLASS="l">480</TD><TD>        ISourceType sourceType = sourceTypes[0];</TD></TR><TR CLASS="z"><TD CLASS="l">481</TD><TD>        while (sourceType.getEnclosingType() != null)</TD></TR><TR CLASS="z"><TD CLASS="l">482</TD><TD>                sourceType = sourceType.getEnclosingType();</TD></TR><TR CLASS="z"><TD CLASS="l">483</TD><TD>        if (sourceType instanceof SourceTypeElementInfo) {</TD></TR><TR><TD CLASS="l">484</TD><TD>                // get source</TD></TR><TR CLASS="z"><TD CLASS="l">485</TD><TD>                SourceTypeElementInfo elementInfo = (SourceTypeElementInfo) sourceType;</TD></TR><TR CLASS="z"><TD CLASS="l">486</TD><TD>                IType type = elementInfo.getHandle();</TD></TR><TR CLASS="z"><TD CLASS="l">487</TD><TD>                ICompilationUnit sourceUnit = (ICompilationUnit) type.getJavaScriptUnit();</TD></TR><TR CLASS="z"><TD CLASS="l">488</TD><TD>                accept(sourceUnit, accessRestriction);</TD></TR><TR><TD CLASS="l">489</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">490</TD><TD>                CompilationResult result = new CompilationResult(sourceType.getFileName(), sourceType.getPackageName(), 1, 1, 0);</TD></TR><TR CLASS="z"><TD CLASS="l">491</TD><TD>                CompilationUnitDeclaration unit =</TD></TR><TR CLASS="z"><TD CLASS="l">492</TD><TD>                        SourceTypeConverter.buildCompilationUnit(</TD></TR><TR CLASS="z"><TD CLASS="l">493</TD><TD>                                sourceTypes,</TD></TR><TR CLASS="z"><TD CLASS="l">494</TD><TD>                                SourceTypeConverter.FIELD_AND_METHOD // need field and methods</TD></TR><TR><TD CLASS="l">495</TD><TD>                                | SourceTypeConverter.MEMBER_TYPE, // need member types</TD></TR><TR><TD CLASS="l">496</TD><TD>                                // no need for field initialization</TD></TR><TR CLASS="z"><TD CLASS="l">497</TD><TD>                                this.lookupEnvironment.problemReporter,</TD></TR><TR CLASS="z"><TD CLASS="l">498</TD><TD>                                result);</TD></TR><TR CLASS="z"><TD CLASS="l">499</TD><TD>                this.lookupEnvironment.buildTypeBindings(unit, accessRestriction);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="8">500</A></TD><TD>                this.lookupEnvironment.completeTypeBindings(unit, true);</TD></TR><TR><TD CLASS="l">501</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">502</TD><TD>}</TD></TR><TR><TD CLASS="l">503</TD><TD>protected Parser basicParser() {</TD></TR><TR CLASS="z"><TD CLASS="l">504</TD><TD>        if (this.basicParser == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">505</TD><TD>                ProblemReporter problemReporter =</TD></TR><TR CLASS="z"><TD CLASS="l">506</TD><TD>                        new ProblemReporter(</TD></TR><TR CLASS="z"><TD CLASS="l">507</TD><TD>                                DefaultErrorHandlingPolicies.proceedWithAllProblems(),</TD></TR><TR CLASS="z"><TD CLASS="l">508</TD><TD>                                this.options,</TD></TR><TR CLASS="z"><TD CLASS="l">509</TD><TD>                                new DefaultProblemFactory());</TD></TR><TR CLASS="z"><TD CLASS="l">510</TD><TD>                this.basicParser = new Parser(problemReporter, false);</TD></TR><TR CLASS="z"><TD CLASS="l">511</TD><TD>                this.basicParser.reportOnlyOneSyntaxError = true;</TD></TR><TR><TD CLASS="l">512</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">513</TD><TD>        return this.basicParser;</TD></TR><TR><TD CLASS="l">514</TD><TD>}</TD></TR><TR><TD CLASS="l">515</TD><TD>/*</TD></TR><TR><TD CLASS="l">516</TD><TD> * Caches the given binary type in the lookup environment and returns it.</TD></TR><TR><TD CLASS="l"><A NAME="9">517</A></TD><TD> * Returns the existing one if already cached.</TD></TR><TR><TD CLASS="l">518</TD><TD> * Returns null if source type binding was cached.</TD></TR><TR><TD CLASS="l">519</TD><TD> */</TD></TR><TR><TD CLASS="l">520</TD><TD>protected BinaryTypeBinding cacheBinaryType(IType type, IBinaryType binaryType) throws JavaScriptModelException {</TD></TR><TR CLASS="z"><TD CLASS="l">521</TD><TD>        IType enclosingType = type.getDeclaringType();</TD></TR><TR CLASS="z"><TD CLASS="l">522</TD><TD>        if (enclosingType != null)</TD></TR><TR CLASS="z"><TD CLASS="l">523</TD><TD>                cacheBinaryType(enclosingType, null); // cache enclosing types first, so that binary type can be found in lookup enviroment</TD></TR><TR CLASS="z"><TD CLASS="l">524</TD><TD>        if (binaryType == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">525</TD><TD>                ClassFile classFile = (ClassFile) type.getClassFile();</TD></TR><TR><TD CLASS="l">526</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">527</TD><TD>                        binaryType = getBinaryInfo(classFile, classFile.getResource());</TD></TR><TR CLASS="z"><TD CLASS="l">528</TD><TD>                } catch (CoreException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">529</TD><TD>                        if (e instanceof JavaScriptModelException) {</TD></TR><TR CLASS="z"><TD CLASS="l">530</TD><TD>                                throw (JavaScriptModelException) e;</TD></TR><TR><TD CLASS="l">531</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>                                throw new JavaScriptModelException(e);</TD></TR><TR><TD CLASS="l">533</TD><TD>                        }</TD></TR><TR><TD CLASS="l">534</TD><TD>                }</TD></TR><TR><TD CLASS="l">535</TD><TD>        }</TD></TR><TR><TD CLASS="l">536</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">537</TD><TD>        BinaryTypeBinding binding = null; //this.lookupEnvironment.cacheBinaryType(type, (AccessRestriction)null /*no access restriction*/);</TD></TR><TR CLASS="z"><TD CLASS="l">538</TD><TD>        if (binding == null) { // it was already cached as a result of a previous query</TD></TR><TR CLASS="z"><TD CLASS="l">539</TD><TD>                char[][] compoundName = CharOperation.splitOn('.', type.getFullyQualifiedName().toCharArray());</TD></TR><TR CLASS="z"><TD CLASS="l">540</TD><TD>                ReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);</TD></TR><TR CLASS="z"><TD CLASS="l">541</TD><TD>                if (referenceBinding != null &amp;&amp; (referenceBinding instanceof BinaryTypeBinding))</TD></TR><TR CLASS="z"><TD CLASS="l">542</TD><TD>                        binding = (BinaryTypeBinding) referenceBinding; // if the binding could be found and if it comes from a binary type</TD></TR><TR><TD CLASS="l">543</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">544</TD><TD>        return binding;</TD></TR><TR><TD CLASS="l">545</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="a">546</A></TD><TD>/*</TD></TR><TR><TD CLASS="l">547</TD><TD> * Computes the super type names of the focus type if any.</TD></TR><TR><TD CLASS="l">548</TD><TD> */</TD></TR><TR><TD CLASS="l">549</TD><TD>protected char[][][] computeSuperTypeNames(IType focusType) {</TD></TR><TR CLASS="z"><TD CLASS="l">550</TD><TD>        String fullyQualifiedName = focusType.getFullyQualifiedName();</TD></TR><TR CLASS="z"><TD CLASS="l">551</TD><TD>        int lastDot = fullyQualifiedName.lastIndexOf('.');</TD></TR><TR CLASS="z"><TD CLASS="l">552</TD><TD>        char[] qualification = lastDot == -1 ? CharOperation.NO_CHAR : fullyQualifiedName.substring(0, lastDot).toCharArray();</TD></TR><TR CLASS="z"><TD CLASS="l">553</TD><TD>        char[] simpleName = focusType.getElementName().toCharArray();</TD></TR><TR><TD CLASS="l">554</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">555</TD><TD>        SuperTypeNamesCollector superTypeNamesCollector =</TD></TR><TR CLASS="z"><TD CLASS="l">556</TD><TD>                new SuperTypeNamesCollector(</TD></TR><TR CLASS="z"><TD CLASS="l">557</TD><TD>                        this.pattern,</TD></TR><TR CLASS="z"><TD CLASS="l">558</TD><TD>                        simpleName,</TD></TR><TR CLASS="z"><TD CLASS="l">559</TD><TD>                        qualification,</TD></TR><TR CLASS="z"><TD CLASS="l">560</TD><TD>                        new MatchLocator(this.pattern, this.requestor, this.scope, this.progressMonitor), // clone MatchLocator so that it has no side effect</TD></TR><TR CLASS="z"><TD CLASS="l">561</TD><TD>                        focusType,</TD></TR><TR CLASS="z"><TD CLASS="l">562</TD><TD>                        this.progressMonitor);</TD></TR><TR><TD CLASS="l">563</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">564</TD><TD>                this.allSuperTypeNames = superTypeNamesCollector.collect();</TD></TR><TR CLASS="z"><TD CLASS="l">565</TD><TD>        } catch (JavaScriptModelException e) {</TD></TR><TR><TD CLASS="l">566</TD><TD>                // problem collecting super type names: leave it null</TD></TR><TR><TD CLASS="l">567</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>        return this.allSuperTypeNames;</TD></TR><TR><TD CLASS="l">569</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="c">570</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">571</TD><TD> * Creates an IFunction from the given method declaration and type.</TD></TR><TR><TD CLASS="l">572</TD><TD> */</TD></TR><TR><TD CLASS="l">573</TD><TD>protected IJavaScriptElement createHandle(AbstractMethodDeclaration method, IJavaScriptElement parent) {</TD></TR><TR CLASS="z"><TD CLASS="l">574</TD><TD>        if (!(parent instanceof IType ||</TD></TR><TR CLASS="z"><TD CLASS="l">575</TD><TD>                        parent instanceof org.eclipse.wst.jsdt.core.IJavaScriptUnit ||</TD></TR><TR CLASS="z"><TD CLASS="l">576</TD><TD>                        parent instanceof org.eclipse.wst.jsdt.core.IClassFile</TD></TR><TR CLASS="z"><TD CLASS="l">577</TD><TD>                        )) return parent;</TD></TR><TR><TD CLASS="l">578</TD><TD> </TD></TR><TR><TD CLASS="l">579</TD><TD>//        IType type = (IType) parent;</TD></TR><TR CLASS="z"><TD CLASS="l">580</TD><TD>        Argument[] arguments = method.arguments;</TD></TR><TR CLASS="z"><TD CLASS="l">581</TD><TD>        int argCount = arguments == null ? 0 : arguments.length;</TD></TR><TR><TD CLASS="l">582</TD><TD>//        if (type.isBinary()) {</TD></TR><TR><TD CLASS="l">583</TD><TD>//                // don't cache the methods of the binary type</TD></TR><TR><TD CLASS="l">584</TD><TD>//                // fall thru if its a constructor with a synthetic argument... find it the slower way</TD></TR><TR><TD CLASS="l">585</TD><TD>//                ClassFileReader reader = classFileReader(type);</TD></TR><TR><TD CLASS="l">586</TD><TD>//                if (reader != null) {</TD></TR><TR><TD CLASS="l">587</TD><TD>//                        IBinaryMethod[] methods = reader.getMethods();</TD></TR><TR><TD CLASS="l">588</TD><TD>//                        if (methods != null) {</TD></TR><TR><TD CLASS="l">589</TD><TD>//                                // build arguments names</TD></TR><TR><TD CLASS="l">590</TD><TD>//                                boolean firstIsSynthetic = false;</TD></TR><TR><TD CLASS="l">591</TD><TD>//                                if (reader.isMember() &amp;&amp; method.isConstructor() &amp;&amp; !Flags.isStatic(reader.getModifiers())) { // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=48261</TD></TR><TR><TD CLASS="l">592</TD><TD>//                                        firstIsSynthetic = true;</TD></TR><TR><TD CLASS="l">593</TD><TD>//                                        argCount++;</TD></TR><TR><TD CLASS="l">594</TD><TD>//                                }</TD></TR><TR><TD CLASS="l">595</TD><TD>//                                char[][] argumentTypeNames = new char[argCount][];</TD></TR><TR><TD CLASS="l">596</TD><TD>//                                for (int i = 0; i &lt; argCount; i++) {</TD></TR><TR><TD CLASS="l">597</TD><TD>//                                        char[] typeName = null;</TD></TR><TR><TD CLASS="l">598</TD><TD>//                                        if (i == 0 &amp;&amp; firstIsSynthetic) {</TD></TR><TR><TD CLASS="l">599</TD><TD>//                                                typeName = type.getDeclaringType().getFullyQualifiedName().toCharArray();</TD></TR><TR><TD CLASS="l">600</TD><TD>//                                        } else if (arguments != null) {</TD></TR><TR><TD CLASS="l">601</TD><TD>//                                                TypeReference typeRef = arguments[firstIsSynthetic ? i - 1 : i].type;</TD></TR><TR><TD CLASS="l">602</TD><TD>//                                                typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');</TD></TR><TR><TD CLASS="l">603</TD><TD>//                                                for (int k = 0, dim = typeRef.dimensions(); k &lt; dim; k++)</TD></TR><TR><TD CLASS="l">604</TD><TD>//                                                        typeName = CharOperation.concat(typeName, new char[] {'[', ']'});</TD></TR><TR><TD CLASS="l">605</TD><TD>//                                        }</TD></TR><TR><TD CLASS="l">606</TD><TD>//                                        if (typeName == null) {</TD></TR><TR><TD CLASS="l">607</TD><TD>//                                                // invalid type name</TD></TR><TR><TD CLASS="l">608</TD><TD>//                                                return null;</TD></TR><TR><TD CLASS="l">609</TD><TD>//                                        }</TD></TR><TR><TD CLASS="l">610</TD><TD>//                                        argumentTypeNames[i] = typeName;</TD></TR><TR><TD CLASS="l">611</TD><TD>//                                }</TD></TR><TR><TD CLASS="l">612</TD><TD>//</TD></TR><TR><TD CLASS="l">613</TD><TD>//                                // return binary method</TD></TR><TR><TD CLASS="l">614</TD><TD>//                                return createBinaryMethodHandle(type, method.selector, argumentTypeNames);</TD></TR><TR><TD CLASS="l">615</TD><TD>//                        }</TD></TR><TR><TD CLASS="l">616</TD><TD>//                }</TD></TR><TR><TD CLASS="l">617</TD><TD>//                return null;</TD></TR><TR><TD CLASS="l">618</TD><TD>//        }</TD></TR><TR><TD CLASS="l">619</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">620</TD><TD>        String[] parameterTypeSignatures = new String[argCount];</TD></TR><TR CLASS="z"><TD CLASS="l">621</TD><TD>        if (arguments != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">622</TD><TD>                for (int i = 0; i &lt; argCount; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">623</TD><TD>                        TypeReference typeRef = arguments[i].type;</TD></TR><TR CLASS="z"><TD CLASS="l">624</TD><TD>                        char[] typeName = typeRef!=null ? CharOperation.concatWith(typeRef.getParameterizedTypeName(), '.')</TD></TR><TR CLASS="z"><TD CLASS="l">625</TD><TD>                                        : null;</TD></TR><TR CLASS="z"><TD CLASS="l">626</TD><TD>                        parameterTypeSignatures[i] = Signature.createTypeSignature(typeName, false);</TD></TR><TR><TD CLASS="l">627</TD><TD>                }</TD></TR><TR><TD CLASS="l">628</TD><TD>        }</TD></TR><TR><TD CLASS="l">629</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">630</TD><TD>        char [] methodName=method.isInferred()?method.inferredMethod.name:method.selector;</TD></TR><TR CLASS="z"><TD CLASS="l">631</TD><TD>        if (methodName==null)</TD></TR><TR CLASS="z"><TD CLASS="l">632</TD><TD>                return null;</TD></TR><TR CLASS="z"><TD CLASS="l">633</TD><TD>        return createMethodHandle(parent, new String(methodName), parameterTypeSignatures);</TD></TR><TR><TD CLASS="l">634</TD><TD>}</TD></TR><TR><TD CLASS="l">635</TD><TD>/*</TD></TR><TR><TD CLASS="l"><A NAME="12">636</A></TD><TD> * Create method handle.</TD></TR><TR><TD CLASS="l">637</TD><TD> * Store occurences for create handle to retrieve possible duplicate ones.</TD></TR><TR><TD CLASS="l">638</TD><TD> */</TD></TR><TR><TD CLASS="l">639</TD><TD>private IJavaScriptElement createMethodHandle(IJavaScriptElement parent, String methodName, String[] parameterTypeSignatures) {</TD></TR><TR CLASS="z"><TD CLASS="l">640</TD><TD>        IFunction methodHandle = null;</TD></TR><TR CLASS="z"><TD CLASS="l">641</TD><TD>        if (parent instanceof org.eclipse.wst.jsdt.core.IJavaScriptUnit) {</TD></TR><TR CLASS="z"><TD CLASS="l">642</TD><TD>                org.eclipse.wst.jsdt.core.IJavaScriptUnit compUnit = (org.eclipse.wst.jsdt.core.IJavaScriptUnit ) parent;</TD></TR><TR CLASS="z"><TD CLASS="l">643</TD><TD>                 methodHandle = compUnit.getFunction(methodName, parameterTypeSignatures);</TD></TR><TR><TD CLASS="l">644</TD><TD> </TD></TR><TR><TD CLASS="l">645</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">646</TD><TD>        else if (parent instanceof ICompilationUnit) {</TD></TR><TR CLASS="z"><TD CLASS="l">647</TD><TD>                org.eclipse.wst.jsdt.core.IClassFile classFile = (org.eclipse.wst.jsdt.core.IClassFile ) parent;</TD></TR><TR CLASS="z"><TD CLASS="l">648</TD><TD>                 methodHandle = classFile.getFunction(methodName, parameterTypeSignatures);</TD></TR><TR><TD CLASS="l">649</TD><TD> </TD></TR><TR><TD CLASS="l">650</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">651</TD><TD>        else if (parent instanceof IType) {</TD></TR><TR CLASS="z"><TD CLASS="l">652</TD><TD>                IType type = (IType) parent;</TD></TR><TR CLASS="z"><TD CLASS="l">653</TD><TD>                 methodHandle = type.getFunction(methodName, parameterTypeSignatures);</TD></TR><TR><TD CLASS="l">654</TD><TD> </TD></TR><TR><TD CLASS="l">655</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">656</TD><TD>        if (methodHandle instanceof SourceMethod) {</TD></TR><TR CLASS="z"><TD CLASS="l">657</TD><TD>                while (this.methodHandles.contains(methodHandle)) {</TD></TR><TR CLASS="z"><TD CLASS="l">658</TD><TD>                        ((SourceMethod) methodHandle).occurrenceCount++;</TD></TR><TR><TD CLASS="l">659</TD><TD>                }</TD></TR><TR><TD CLASS="l">660</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="f">661</A></TD><TD>        this.methodHandles.add(methodHandle);</TD></TR><TR CLASS="z"><TD CLASS="l">662</TD><TD>        return methodHandle;</TD></TR><TR><TD CLASS="l">663</TD><TD>}</TD></TR><TR><TD CLASS="l">664</TD><TD>protected IJavaScriptElement createHandle(InferredAttribute fieldDeclaration, InferredType typeDeclaration, IJavaScriptElement parent) {</TD></TR><TR CLASS="z"><TD CLASS="l">665</TD><TD>        if (parent instanceof ITypeRoot) {</TD></TR><TR CLASS="z"><TD CLASS="l">666</TD><TD>                ITypeRoot typeRoot = (ITypeRoot) parent;</TD></TR><TR CLASS="z"><TD CLASS="l">667</TD><TD>                parent=typeRoot.getType(new String(typeDeclaration.getName()));</TD></TR><TR><TD CLASS="l">668</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">669</TD><TD>        if (!(parent instanceof IType)) return parent;</TD></TR><TR><TD CLASS="l">670</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">671</TD><TD>        return ((IType) parent).getField(new String(fieldDeclaration.name));</TD></TR><TR><TD CLASS="l">672</TD><TD>}</TD></TR><TR><TD CLASS="l">673</TD><TD> </TD></TR><TR><TD CLASS="l">674</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="e">675</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">676</TD><TD> * Creates an IField from the given field declaration and type.</TD></TR><TR><TD CLASS="l">677</TD><TD> */</TD></TR><TR><TD CLASS="l">678</TD><TD>protected IJavaScriptElement createHandle(FieldDeclaration fieldDeclaration, TypeDeclaration typeDeclaration, IJavaScriptElement parent) {</TD></TR><TR CLASS="z"><TD CLASS="l">679</TD><TD>        if (!(parent instanceof IType)) return parent;</TD></TR><TR CLASS="z"><TD CLASS="l">680</TD><TD>        IType type = (IType) parent;</TD></TR><TR><TD CLASS="l">681</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">682</TD><TD>        switch (fieldDeclaration.getKind()) {</TD></TR><TR><TD CLASS="l">683</TD><TD>                case AbstractVariableDeclaration.FIELD :</TD></TR><TR><TD CLASS="l">684</TD><TD>                case AbstractVariableDeclaration.ENUM_CONSTANT :</TD></TR><TR CLASS="z"><TD CLASS="l">685</TD><TD>                        return ((IType) parent).getField(new String(fieldDeclaration.name));</TD></TR><TR><TD CLASS="l">686</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">687</TD><TD>        if (type.isBinary()) {</TD></TR><TR><TD CLASS="l">688</TD><TD>                // do not return initializer for binary types</TD></TR><TR><TD CLASS="l">689</TD><TD>                // see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=98378</TD></TR><TR CLASS="z"><TD CLASS="l">690</TD><TD>                return type;</TD></TR><TR><TD CLASS="l">691</TD><TD>        }</TD></TR><TR><TD CLASS="l">692</TD><TD>        // find occurence count of the given initializer in its type declaration</TD></TR><TR CLASS="z"><TD CLASS="l">693</TD><TD>        int occurrenceCount = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">694</TD><TD>        FieldDeclaration[] fields = typeDeclaration.fields;</TD></TR><TR CLASS="z"><TD CLASS="l">695</TD><TD>        for (int i = 0, length = fields.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">696</TD><TD>                if (fields[i].getKind() == AbstractVariableDeclaration.INITIALIZER) {</TD></TR><TR CLASS="z"><TD CLASS="l">697</TD><TD>                        occurrenceCount++;</TD></TR><TR CLASS="z"><TD CLASS="l">698</TD><TD>                        if (fields[i].equals(fieldDeclaration)) break;</TD></TR><TR><TD CLASS="l">699</TD><TD>                }</TD></TR><TR><TD CLASS="l">700</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">701</TD><TD>        return ((IType) parent).getInitializer(occurrenceCount);</TD></TR><TR><TD CLASS="l">702</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="d">703</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">704</TD><TD> * Create an handle for a local variable declartion (may be a local variable or type parameter).</TD></TR><TR><TD CLASS="l">705</TD><TD> */</TD></TR><TR><TD CLASS="l">706</TD><TD>protected IJavaScriptElement createHandle(AbstractVariableDeclaration variableDeclaration, IJavaScriptElement parent) {</TD></TR><TR CLASS="z"><TD CLASS="l">707</TD><TD>        switch (variableDeclaration.getKind()) {</TD></TR><TR><TD CLASS="l">708</TD><TD>                case AbstractVariableDeclaration.LOCAL_VARIABLE:</TD></TR><TR CLASS="z"><TD CLASS="l">709</TD><TD>                        String signature = (variableDeclaration.type!=null) ?</TD></TR><TR CLASS="z"><TD CLASS="l">710</TD><TD>                                        new String(variableDeclaration.type.resolvedType.signature()): Signature.SIG_ANY;</TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>                        return new LocalVariable((JavaElement)parent,</TD></TR><TR CLASS="z"><TD CLASS="l">712</TD><TD>                                new String(variableDeclaration.name),</TD></TR><TR CLASS="z"><TD CLASS="l">713</TD><TD>                                variableDeclaration.declarationSourceStart,</TD></TR><TR CLASS="z"><TD CLASS="l">714</TD><TD>                                variableDeclaration.declarationSourceEnd,</TD></TR><TR CLASS="z"><TD CLASS="l">715</TD><TD>                                variableDeclaration.sourceStart,</TD></TR><TR CLASS="z"><TD CLASS="l">716</TD><TD>                                variableDeclaration.sourceEnd,</TD></TR><TR CLASS="z"><TD CLASS="l">717</TD><TD>                                signature</TD></TR><TR><TD CLASS="l">718</TD><TD>                        );</TD></TR><TR><TD CLASS="l">719</TD><TD>                case AbstractVariableDeclaration.PARAMETER:</TD></TR><TR CLASS="z"><TD CLASS="l">720</TD><TD>                        return new LocalVariable((JavaElement)parent,</TD></TR><TR CLASS="z"><TD CLASS="l">721</TD><TD>                                new String(variableDeclaration.name),</TD></TR><TR CLASS="z"><TD CLASS="l">722</TD><TD>                                variableDeclaration.declarationSourceStart,</TD></TR><TR CLASS="z"><TD CLASS="l">723</TD><TD>                                variableDeclaration.declarationSourceEnd,</TD></TR><TR CLASS="z"><TD CLASS="l">724</TD><TD>                                variableDeclaration.sourceStart,</TD></TR><TR CLASS="z"><TD CLASS="l">725</TD><TD>                                variableDeclaration.sourceEnd,</TD></TR><TR CLASS="z"><TD CLASS="l">726</TD><TD>                                new String(variableDeclaration.type.resolvedType.signature())</TD></TR><TR><TD CLASS="l">727</TD><TD>                        );</TD></TR><TR><TD CLASS="l">728</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">729</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">730</TD><TD>}</TD></TR><TR><TD CLASS="l">731</TD><TD>/*</TD></TR><TR><TD CLASS="l">732</TD><TD> * Creates hierarchy resolver if needed.</TD></TR><TR><TD CLASS="l"><A NAME="10">733</A></TD><TD> * Returns whether focus is visible.</TD></TR><TR><TD CLASS="l">734</TD><TD> */</TD></TR><TR><TD CLASS="l">735</TD><TD>protected boolean createHierarchyResolver(IType focusType, PossibleMatch[] possibleMatches) {</TD></TR><TR><TD CLASS="l">736</TD><TD>        // cache focus type if not a possible match</TD></TR><TR CLASS="z"><TD CLASS="l">737</TD><TD>        char[][] compoundName = CharOperation.splitOn('.', focusType.getFullyQualifiedName().toCharArray());</TD></TR><TR CLASS="z"><TD CLASS="l">738</TD><TD>        boolean isPossibleMatch = false;</TD></TR><TR CLASS="z"><TD CLASS="l">739</TD><TD>        for (int i = 0, length = possibleMatches.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">740</TD><TD>                if (CharOperation.equals(possibleMatches[i].compoundName, compoundName)) {</TD></TR><TR CLASS="z"><TD CLASS="l">741</TD><TD>                        isPossibleMatch = true;</TD></TR><TR CLASS="z"><TD CLASS="l">742</TD><TD>                        break;</TD></TR><TR><TD CLASS="l">743</TD><TD>                }</TD></TR><TR><TD CLASS="l">744</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">745</TD><TD>        if (!isPossibleMatch) {</TD></TR><TR CLASS="z"><TD CLASS="l">746</TD><TD>                if (focusType.isBinary()) {</TD></TR><TR><TD CLASS="l">747</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">748</TD><TD>                                cacheBinaryType(focusType, null);</TD></TR><TR CLASS="z"><TD CLASS="l">749</TD><TD>                        } catch (JavaScriptModelException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">750</TD><TD>                                return false;</TD></TR><TR><TD CLASS="l">751</TD><TD>                        }</TD></TR><TR><TD CLASS="l">752</TD><TD>                } else {</TD></TR><TR><TD CLASS="l">753</TD><TD>                        // cache all types in the focus' compilation unit (even secondary types)</TD></TR><TR CLASS="z"><TD CLASS="l">754</TD><TD>                        accept((ICompilationUnit) focusType.getJavaScriptUnit(), null /*TODO no access restriction*/);</TD></TR><TR><TD CLASS="l">755</TD><TD>                }</TD></TR><TR><TD CLASS="l">756</TD><TD>        }</TD></TR><TR><TD CLASS="l">757</TD><TD> </TD></TR><TR><TD CLASS="l">758</TD><TD>        // resolve focus type</TD></TR><TR CLASS="z"><TD CLASS="l">759</TD><TD>        this.hierarchyResolver = new HierarchyResolver(this.lookupEnvironment, null/*hierarchy is not going to be computed*/);</TD></TR><TR CLASS="z"><TD CLASS="l">760</TD><TD>        ReferenceBinding binding = this.hierarchyResolver.setFocusType(compoundName);</TD></TR><TR CLASS="z"><TD CLASS="l">761</TD><TD>        return binding != null &amp;&amp; binding.isValidBinding() &amp;&amp; (binding.tagBits &amp; TagBits.HierarchyHasProblems) == 0;</TD></TR><TR><TD CLASS="l">762</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="11">763</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">764</TD><TD> * Creates an IImportDeclaration from the given import statement</TD></TR><TR><TD CLASS="l">765</TD><TD> */</TD></TR><TR><TD CLASS="l">766</TD><TD>protected IJavaScriptElement createImportHandle(ImportReference importRef) {</TD></TR><TR CLASS="z"><TD CLASS="l">767</TD><TD>        char[] importName = CharOperation.concatWith(importRef.getImportName(), '.');</TD></TR><TR CLASS="z"><TD CLASS="l">768</TD><TD>        if ((importRef.bits &amp; ASTNode.OnDemand) != 0)</TD></TR><TR CLASS="z"><TD CLASS="l">769</TD><TD>                importName = CharOperation.concat(importName, &#34;.*&#34; .toCharArray()); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">770</TD><TD>        Openable openable = this.currentPossibleMatch.openable;</TD></TR><TR CLASS="z"><TD CLASS="l">771</TD><TD>        if (openable instanceof CompilationUnit)</TD></TR><TR CLASS="z"><TD CLASS="l">772</TD><TD>                return ((CompilationUnit) openable).getImport(new String(importName));</TD></TR><TR><TD CLASS="l">773</TD><TD> </TD></TR><TR><TD CLASS="l">774</TD><TD>        // binary types do not contain import statements so just answer the top-level type as the element</TD></TR><TR CLASS="z"><TD CLASS="l">775</TD><TD>        IType binaryType = ((ClassFile) openable).getType();</TD></TR><TR CLASS="z"><TD CLASS="l">776</TD><TD>        String typeName = binaryType.getElementName();</TD></TR><TR CLASS="z"><TD CLASS="l">777</TD><TD>        int lastDollar = typeName.lastIndexOf('$');</TD></TR><TR CLASS="z"><TD CLASS="l">778</TD><TD>        if (lastDollar == -1) return binaryType;</TD></TR><TR CLASS="z"><TD CLASS="l">779</TD><TD>        return createTypeHandle(typeName.substring(0, lastDollar));</TD></TR><TR><TD CLASS="l">780</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="13">781</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">782</TD><TD> * Creates an IImportDeclaration from the given import statement</TD></TR><TR><TD CLASS="l">783</TD><TD> */</TD></TR><TR><TD CLASS="l">784</TD><TD>protected IJavaScriptElement createPackageDeclarationHandle(CompilationUnitDeclaration unit) {</TD></TR><TR CLASS="z"><TD CLASS="l">785</TD><TD>        if (unit.isPackageInfo()) {</TD></TR><TR CLASS="z"><TD CLASS="l">786</TD><TD>                char[] packName = CharOperation.concatWith(unit.currentPackage.getImportName(), '.');</TD></TR><TR CLASS="z"><TD CLASS="l">787</TD><TD>                Openable openable = this.currentPossibleMatch.openable;</TD></TR><TR CLASS="z"><TD CLASS="l">788</TD><TD>                if (openable instanceof CompilationUnit) {</TD></TR><TR CLASS="z"><TD CLASS="l">789</TD><TD>                        return ((CompilationUnit) openable).getPackageDeclaration(new String(packName));</TD></TR><TR><TD CLASS="l">790</TD><TD>                }</TD></TR><TR><TD CLASS="l">791</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">792</TD><TD>        return createTypeHandle(new String(unit.getMainTypeName()));</TD></TR><TR><TD CLASS="l">793</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="14">794</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">795</TD><TD> * Creates an IType from the given simple top level type name.</TD></TR><TR><TD CLASS="l">796</TD><TD> */</TD></TR><TR><TD CLASS="l">797</TD><TD>protected IType createTypeHandle(String simpleTypeName) {</TD></TR><TR CLASS="z"><TD CLASS="l">798</TD><TD>        Openable openable = this.currentPossibleMatch.openable;</TD></TR><TR CLASS="z"><TD CLASS="l">799</TD><TD>        if (openable instanceof CompilationUnit)</TD></TR><TR CLASS="z"><TD CLASS="l">800</TD><TD>                return ((CompilationUnit) openable).getType(simpleTypeName);</TD></TR><TR><TD CLASS="l">801</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">802</TD><TD>        IType binaryType = ((ClassFile) openable).getType(simpleTypeName);</TD></TR><TR><TD CLASS="l">803</TD><TD>//        String binaryTypeQualifiedName = binaryType.getTypeQualifiedName();</TD></TR><TR><TD CLASS="l">804</TD><TD>//        if (simpleTypeName.equals(binaryTypeQualifiedName))</TD></TR><TR CLASS="z"><TD CLASS="l">805</TD><TD>                return binaryType; // answer only top-level types, sometimes the classFile is for a member/local type</TD></TR><TR><TD CLASS="l">806</TD><TD> </TD></TR><TR><TD CLASS="l">807</TD><TD>//                // type name may be null for anonymous (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=164791)</TD></TR><TR><TD CLASS="l">808</TD><TD>//                String classFileName = simpleTypeName.length() == 0 ? binaryTypeQualifiedName : simpleTypeName;</TD></TR><TR><TD CLASS="l"><A NAME="16">809</A></TD><TD>//                IClassFile classFile = binaryType.getPackageFragment().getClassFile(classFileName + SuffixConstants.SUFFIX_STRING_class);</TD></TR><TR><TD CLASS="l">810</TD><TD>//                return classFile.getType();</TD></TR><TR><TD CLASS="l">811</TD><TD>}</TD></TR><TR><TD CLASS="l">812</TD><TD>protected boolean encloses(IJavaScriptElement element) {</TD></TR><TR CLASS="z"><TD CLASS="l">813</TD><TD>        return element != null &amp;&amp; this.scope.encloses(element);</TD></TR><TR><TD CLASS="l">814</TD><TD>}</TD></TR><TR><TD CLASS="l">815</TD><TD>/* (non-Javadoc)</TD></TR><TR><TD CLASS="l">816</TD><TD> * Return info about last type argument of a parameterized type reference.</TD></TR><TR><TD CLASS="l">817</TD><TD> * These info are made of concatenation of 2 int values which are respectively</TD></TR><TR><TD CLASS="l">818</TD><TD> *  depth and end position of the last type argument.</TD></TR><TR><TD CLASS="l">819</TD><TD> * For example, this method will return 0x300000020 for type ref List&lt;List&lt;List&lt;String&gt;&gt;&gt;</TD></TR><TR><TD CLASS="l"><A NAME="18">820</A></TD><TD> * if end position of type reference &#34;String&#34; equals 32.</TD></TR><TR><TD CLASS="l">821</TD><TD> */</TD></TR><TR><TD CLASS="l">822</TD><TD>private long findLastTypeArgumentInfo(TypeReference typeRef) {</TD></TR><TR><TD CLASS="l">823</TD><TD>        // Get last list of type arguments for parameterized qualified type reference</TD></TR><TR CLASS="z"><TD CLASS="l">824</TD><TD>        TypeReference lastTypeArgument = typeRef;</TD></TR><TR CLASS="z"><TD CLASS="l">825</TD><TD>        int depth = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">826</TD><TD>        while (true) {</TD></TR><TR CLASS="z"><TD CLASS="l">827</TD><TD>                TypeReference[] lastTypeArguments = null;</TD></TR><TR CLASS="z"><TD CLASS="l">828</TD><TD>                if (lastTypeArgument instanceof ParameterizedQualifiedTypeReference) {</TD></TR><TR CLASS="z"><TD CLASS="l">829</TD><TD>                        ParameterizedQualifiedTypeReference pqtRef = (ParameterizedQualifiedTypeReference) lastTypeArgument;</TD></TR><TR CLASS="z"><TD CLASS="l">830</TD><TD>                        for (int i=pqtRef.typeArguments.length-1; i&gt;=0 &amp;&amp; lastTypeArguments==null; i--) {</TD></TR><TR CLASS="z"><TD CLASS="l">831</TD><TD>                                lastTypeArguments = pqtRef.typeArguments[i];</TD></TR><TR><TD CLASS="l">832</TD><TD>                        }</TD></TR><TR><TD CLASS="l">833</TD><TD>                }</TD></TR><TR><TD CLASS="l">834</TD><TD>                // Get last type argument for single type reference of last list of argument of parameterized qualified type reference</TD></TR><TR CLASS="z"><TD CLASS="l">835</TD><TD>                TypeReference last = null;</TD></TR><TR CLASS="z"><TD CLASS="l">836</TD><TD>                if (lastTypeArgument instanceof ParameterizedSingleTypeReference || lastTypeArguments != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">837</TD><TD>                        if (lastTypeArguments == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">838</TD><TD>                                lastTypeArguments = ((ParameterizedSingleTypeReference)lastTypeArgument).typeArguments;</TD></TR><TR><TD CLASS="l">839</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">840</TD><TD>                        if (lastTypeArguments != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">841</TD><TD>                                for (int i=lastTypeArguments.length-1; i&gt;=0 &amp;&amp; last==null; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">842</TD><TD>                                        last = lastTypeArguments[i];</TD></TR><TR><TD CLASS="l">843</TD><TD>                                }</TD></TR><TR><TD CLASS="l">844</TD><TD>                        }</TD></TR><TR><TD CLASS="l">845</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">846</TD><TD>                if (last == null) break;</TD></TR><TR CLASS="z"><TD CLASS="l">847</TD><TD>                depth++;</TD></TR><TR CLASS="z"><TD CLASS="l">848</TD><TD>                lastTypeArgument = last;</TD></TR><TR><TD CLASS="l">849</TD><TD>        }</TD></TR><TR><TD CLASS="l"><A NAME="19">850</A></TD><TD>        // Current type reference is not parameterized. So, it is the last type argument</TD></TR><TR CLASS="z"><TD CLASS="l">851</TD><TD>        return (((long) depth) &lt;&lt; 32) + lastTypeArgument.sourceEnd;</TD></TR><TR><TD CLASS="l">852</TD><TD>}</TD></TR><TR><TD CLASS="l">853</TD><TD>protected IBinaryType getBinaryInfo(ClassFile classFile, IResource resource) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">854</TD><TD>        BinaryType binaryType = (BinaryType) classFile.getType();</TD></TR><TR CLASS="z"><TD CLASS="l">855</TD><TD>        if (classFile.isOpen())</TD></TR><TR CLASS="z"><TD CLASS="l">856</TD><TD>                return (IBinaryType) binaryType.getElementInfo(); // reuse the info from the java model cache</TD></TR><TR><TD CLASS="l">857</TD><TD> </TD></TR><TR><TD CLASS="l">858</TD><TD>        // create a temporary info</TD></TR><TR><TD CLASS="l">859</TD><TD>//        IBinaryType info;</TD></TR><TR><TD CLASS="l">860</TD><TD>//        try {</TD></TR><TR><TD CLASS="l">861</TD><TD>//                PackageFragment pkg = (PackageFragment) classFile.getParent();</TD></TR><TR><TD CLASS="l">862</TD><TD>//                PackageFragmentRoot root = (PackageFragmentRoot) pkg.getParent();</TD></TR><TR><TD CLASS="l">863</TD><TD>//                if (root.isArchive()) {</TD></TR><TR><TD CLASS="l">864</TD><TD>//                        // class file in a jar</TD></TR><TR><TD CLASS="l">865</TD><TD>//                        String classFileName = classFile.getElementName();</TD></TR><TR><TD CLASS="l">866</TD><TD>//                        String classFilePath = Util.concatWith(pkg.names, classFileName, '/');</TD></TR><TR><TD CLASS="l">867</TD><TD>//                        ZipFile zipFile = null;</TD></TR><TR><TD CLASS="l">868</TD><TD>//                        try {</TD></TR><TR><TD CLASS="l">869</TD><TD>//                                zipFile = ((JarPackageFragmentRoot) root).getJar();</TD></TR><TR><TD CLASS="l">870</TD><TD>//                                info = ClassFileReader.read(zipFile, classFilePath);</TD></TR><TR><TD CLASS="l">871</TD><TD>//                        } finally {</TD></TR><TR><TD CLASS="l">872</TD><TD>//                                JavaModelManager.getJavaModelManager().closeZipFile(zipFile);</TD></TR><TR><TD CLASS="l">873</TD><TD>//                        }</TD></TR><TR><TD CLASS="l">874</TD><TD>//                } else {</TD></TR><TR><TD CLASS="l">875</TD><TD>//                        // class file in a directory</TD></TR><TR><TD CLASS="l">876</TD><TD>//                        info = Util.newClassFileReader(resource);</TD></TR><TR><TD CLASS="l">877</TD><TD>//                }</TD></TR><TR><TD CLASS="l">878</TD><TD>//                if (info == null) throw binaryType.newNotPresentException();</TD></TR><TR><TD CLASS="l">879</TD><TD>//                return info;</TD></TR><TR><TD CLASS="l">880</TD><TD>//        } catch (ClassFormatException e) {</TD></TR><TR><TD CLASS="l">881</TD><TD>//                //e.printStackTrace();</TD></TR><TR><TD CLASS="l">882</TD><TD>//                return null;</TD></TR><TR><TD CLASS="l">883</TD><TD>//        } catch (java.io.IOException e) {</TD></TR><TR><TD CLASS="l">884</TD><TD>//                throw new JavaScriptModelException(e, IJavaScriptModelStatusConstants.IO_EXCEPTION);</TD></TR><TR><TD CLASS="l"><A NAME="1a">885</A></TD><TD>//        }</TD></TR><TR CLASS="z"><TD CLASS="l">886</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">887</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="1c">888</A></TD><TD>protected IType getFocusType() {</TD></TR><TR CLASS="z"><TD CLASS="l">889</TD><TD>        return this.scope instanceof HierarchyScope ? ((HierarchyScope) this.scope).focusType : null;</TD></TR><TR><TD CLASS="l">890</TD><TD>}</TD></TR><TR><TD CLASS="l">891</TD><TD>protected void getMethodBodies(CompilationUnitDeclaration unit, MatchingNodeSet nodeSet) {</TD></TR><TR CLASS="z"><TD CLASS="l">892</TD><TD>        if (unit.ignoreMethodBodies) {</TD></TR><TR CLASS="z"><TD CLASS="l">893</TD><TD>                unit.ignoreFurtherInvestigation = true;</TD></TR><TR CLASS="z"><TD CLASS="l">894</TD><TD>                return; // if initial diet parse did not work, no need to dig into method bodies.</TD></TR><TR><TD CLASS="l">895</TD><TD>        }</TD></TR><TR><TD CLASS="l">896</TD><TD> </TD></TR><TR><TD CLASS="l">897</TD><TD>        // save existing values to restore them at the end of the parsing process</TD></TR><TR><TD CLASS="l">898</TD><TD>        // see bug 47079 for more details</TD></TR><TR CLASS="z"><TD CLASS="l">899</TD><TD>        int[] oldLineEnds = this.parser.scanner.lineEnds;</TD></TR><TR CLASS="z"><TD CLASS="l">900</TD><TD>        int oldLinePtr = this.parser.scanner.linePtr;</TD></TR><TR><TD CLASS="l">901</TD><TD> </TD></TR><TR><TD CLASS="l">902</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">903</TD><TD>                CompilationResult compilationResult = unit.compilationResult;</TD></TR><TR CLASS="z"><TD CLASS="l">904</TD><TD>                this.parser.scanner.setSource(compilationResult);</TD></TR><TR><TD CLASS="l">905</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">906</TD><TD>                if (this.parser.javadocParser.checkDocComment) {</TD></TR><TR CLASS="z"><TD CLASS="l">907</TD><TD>                        char[] contents = compilationResult.compilationUnit.getContents();</TD></TR><TR CLASS="z"><TD CLASS="l">908</TD><TD>                        this.parser.javadocParser.scanner.setSource(contents);</TD></TR><TR><TD CLASS="l">909</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">910</TD><TD>                this.parser.nodeSet = nodeSet;</TD></TR><TR CLASS="z"><TD CLASS="l">911</TD><TD>                this.parser.parseBodies(unit);</TD></TR><TR CLASS="z"><TD CLASS="l">912</TD><TD>        } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">913</TD><TD>                this.parser.nodeSet = null;</TD></TR><TR><TD CLASS="l">914</TD><TD>                // this is done to prevent any side effects on the compilation unit result</TD></TR><TR><TD CLASS="l">915</TD><TD>                // line separator positions array.</TD></TR><TR CLASS="z"><TD CLASS="l">916</TD><TD>                this.parser.scanner.lineEnds = oldLineEnds;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1f">917</A></TD><TD>                this.parser.scanner.linePtr = oldLinePtr;</TD></TR><TR CLASS="z"><TD CLASS="l">918</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">919</TD><TD>}</TD></TR><TR><TD CLASS="l">920</TD><TD>protected TypeBinding getType(Object typeKey, char[] typeName) {</TD></TR><TR CLASS="z"><TD CLASS="l">921</TD><TD>        if (this.unitScope == null || typeName == null || typeName.length == 0) return null;</TD></TR><TR><TD CLASS="l">922</TD><TD>        // Try to get binding from cache</TD></TR><TR CLASS="z"><TD CLASS="l">923</TD><TD>        Binding binding = (Binding) this.bindings.get(typeKey);</TD></TR><TR CLASS="z"><TD CLASS="l">924</TD><TD>        if (binding != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">925</TD><TD>                if (binding instanceof TypeBinding &amp;&amp; binding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">926</TD><TD>                        return (TypeBinding) binding;</TD></TR><TR CLASS="z"><TD CLASS="l">927</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">928</TD><TD>        }</TD></TR><TR><TD CLASS="l">929</TD><TD>        // Get binding from unit scope</TD></TR><TR CLASS="z"><TD CLASS="l">930</TD><TD>        char[][] compoundName = CharOperation.splitOn('.', typeName);</TD></TR><TR CLASS="z"><TD CLASS="l">931</TD><TD>        TypeBinding typeBinding = this.unitScope.getType(compoundName, compoundName.length);</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="1b">932</A></TD><TD>        this.bindings.put(typeKey, typeBinding);</TD></TR><TR CLASS="z"><TD CLASS="l">933</TD><TD>        return typeBinding.isValidBinding() ? typeBinding : null;</TD></TR><TR><TD CLASS="l">934</TD><TD>}</TD></TR><TR><TD CLASS="l">935</TD><TD>public MethodBinding getMethodBinding(MethodPattern methodPattern) {</TD></TR><TR CLASS="z"><TD CLASS="l">936</TD><TD>        if (this.unitScope == null) return null;</TD></TR><TR><TD CLASS="l">937</TD><TD>        // Try to get binding from cache</TD></TR><TR CLASS="z"><TD CLASS="l">938</TD><TD>        Binding binding = (Binding) this.bindings.get(methodPattern);</TD></TR><TR CLASS="z"><TD CLASS="l">939</TD><TD>        if (binding != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">940</TD><TD>                if (binding instanceof MethodBinding &amp;&amp; binding.isValidBinding())</TD></TR><TR CLASS="z"><TD CLASS="l">941</TD><TD>                        return (MethodBinding) binding;</TD></TR><TR CLASS="z"><TD CLASS="l">942</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">943</TD><TD>        }</TD></TR><TR><TD CLASS="l">944</TD><TD>        //        Get binding from unit scope</TD></TR><TR CLASS="z"><TD CLASS="l">945</TD><TD>        char[] typeName = PatternLocator.qualifiedPattern(methodPattern.declaringSimpleName, methodPattern.declaringQualification);</TD></TR><TR CLASS="z"><TD CLASS="l">946</TD><TD>        if (typeName == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">947</TD><TD>                if (methodPattern.declaringType == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">948</TD><TD>                typeName = methodPattern.declaringType.getFullyQualifiedName().toCharArray();</TD></TR><TR><TD CLASS="l">949</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">950</TD><TD>        TypeBinding declaringTypeBinding = getType(typeName, typeName);</TD></TR><TR CLASS="z"><TD CLASS="l">951</TD><TD>        if (declaringTypeBinding != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">952</TD><TD>                if (declaringTypeBinding.isArrayType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">953</TD><TD>                        declaringTypeBinding = declaringTypeBinding.leafComponentType();</TD></TR><TR><TD CLASS="l">954</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">955</TD><TD>                if (!declaringTypeBinding.isBaseType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">956</TD><TD>                        char[][] parameterTypes = methodPattern.parameterSimpleNames;</TD></TR><TR CLASS="z"><TD CLASS="l">957</TD><TD>                        if (parameterTypes == null) return null;</TD></TR><TR CLASS="z"><TD CLASS="l">958</TD><TD>                        int paramTypeslength = parameterTypes.length;</TD></TR><TR CLASS="z"><TD CLASS="l">959</TD><TD>                        ReferenceBinding referenceBinding = (ReferenceBinding) declaringTypeBinding;</TD></TR><TR CLASS="z"><TD CLASS="l">960</TD><TD>                        MethodBinding[] methods = referenceBinding.getMethods(methodPattern.selector);</TD></TR><TR CLASS="z"><TD CLASS="l">961</TD><TD>                        int methodsLength = methods.length;</TD></TR><TR CLASS="z"><TD CLASS="l">962</TD><TD>                        TypeVariableBinding[] refTypeVariables = referenceBinding.typeVariables();</TD></TR><TR CLASS="z"><TD CLASS="l">963</TD><TD>                        int typeVarLength = refTypeVariables==null ? 0 : refTypeVariables.length;</TD></TR><TR CLASS="z"><TD CLASS="l">964</TD><TD>                        for (int i=0; i&lt;methodsLength; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">965</TD><TD>                                TypeBinding[] methodParameters = methods[i].parameters;</TD></TR><TR CLASS="z"><TD CLASS="l">966</TD><TD>                                int paramLength = methodParameters==null ? 0 : methodParameters.length;</TD></TR><TR CLASS="z"><TD CLASS="l">967</TD><TD>                                TypeVariableBinding[] methodTypeVariables = methods[i].typeVariables;</TD></TR><TR CLASS="z"><TD CLASS="l">968</TD><TD>                                int methTypeVarLength = methodTypeVariables==null ? 0 : methodTypeVariables.length;</TD></TR><TR CLASS="z"><TD CLASS="l">969</TD><TD>                                boolean found = false;</TD></TR><TR CLASS="z"><TD CLASS="l">970</TD><TD>                                if (methodParameters != null &amp;&amp; paramLength == paramTypeslength) {</TD></TR><TR CLASS="z"><TD CLASS="l">971</TD><TD>                                        for (int p=0; p&lt;paramLength; p++) {</TD></TR><TR CLASS="z"><TD CLASS="l">972</TD><TD>                                                if (CharOperation.equals(methodParameters[p].sourceName(), parameterTypes[p])) {</TD></TR><TR><TD CLASS="l">973</TD><TD>                                                        // param erasure match</TD></TR><TR CLASS="z"><TD CLASS="l">974</TD><TD>                                                        found = true;</TD></TR><TR><TD CLASS="l">975</TD><TD>                                                } else {</TD></TR><TR><TD CLASS="l">976</TD><TD>                                                        // type variable</TD></TR><TR CLASS="z"><TD CLASS="l">977</TD><TD>                                                        found = false;</TD></TR><TR CLASS="z"><TD CLASS="l">978</TD><TD>                                                        if (refTypeVariables != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">979</TD><TD>                                                                for (int v=0; v&lt;typeVarLength; v++) {</TD></TR><TR CLASS="z"><TD CLASS="l">980</TD><TD>                                                                        if (!CharOperation.equals(refTypeVariables[v].sourceName, parameterTypes[p])) {</TD></TR><TR CLASS="z"><TD CLASS="l">981</TD><TD>                                                                                found = false;</TD></TR><TR CLASS="z"><TD CLASS="l">982</TD><TD>                                                                                break;</TD></TR><TR><TD CLASS="l">983</TD><TD>                                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">984</TD><TD>                                                                        found = true;</TD></TR><TR><TD CLASS="l">985</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">986</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">987</TD><TD>                                                        if (!found &amp;&amp; methodTypeVariables != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">988</TD><TD>                                                                for (int v=0; v&lt;methTypeVarLength; v++) {</TD></TR><TR CLASS="z"><TD CLASS="l">989</TD><TD>                                                                        if (!CharOperation.equals(methodTypeVariables[v].sourceName, parameterTypes[p])) {</TD></TR><TR CLASS="z"><TD CLASS="l">990</TD><TD>                                                                                found = false;</TD></TR><TR CLASS="z"><TD CLASS="l">991</TD><TD>                                                                                break;</TD></TR><TR><TD CLASS="l">992</TD><TD>                                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">993</TD><TD>                                                                        found = true;</TD></TR><TR><TD CLASS="l">994</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">995</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">996</TD><TD>                                                        if (!found) break;</TD></TR><TR><TD CLASS="l">997</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">998</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">999</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1000</TD><TD>                                if (found) {</TD></TR><TR CLASS="z"><TD CLASS="l">1001</TD><TD>                                        this.bindings.put(methodPattern, methods[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">1002</TD><TD>                                        return methods[i];</TD></TR><TR><TD CLASS="l">1003</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1004</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1005</TD><TD>                }</TD></TR><TR><TD CLASS="l">1006</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="20">1007</A></TD><TD>        this.bindings.put(methodPattern, new ProblemMethodBinding(methodPattern.selector, null, ProblemReasons.NotFound));</TD></TR><TR CLASS="z"><TD CLASS="l">1008</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">1009</TD><TD>}</TD></TR><TR><TD CLASS="l">1010</TD><TD>protected boolean hasAlreadyDefinedType(CompilationUnitDeclaration parsedUnit) {</TD></TR><TR CLASS="z"><TD CLASS="l">1011</TD><TD>        CompilationResult result = parsedUnit.compilationResult;</TD></TR><TR CLASS="z"><TD CLASS="l">1012</TD><TD>        if (result == null) return false;</TD></TR><TR CLASS="z"><TD CLASS="l">1013</TD><TD>        for (int i = 0; i &lt; result.problemCount; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">1014</TD><TD>                if (result.problems[i].getID() == IProblem.DuplicateTypes)</TD></TR><TR CLASS="z"><TD CLASS="l">1015</TD><TD>                        return true;</TD></TR><TR CLASS="z"><TD CLASS="l">1016</TD><TD>        return false;</TD></TR><TR><TD CLASS="l">1017</TD><TD>}</TD></TR><TR><TD CLASS="l">1018</TD><TD>/**</TD></TR><TR><TD CLASS="l">1019</TD><TD> * Create a new parser for the given project, as well as a lookup environment.</TD></TR><TR><TD CLASS="l"><A NAME="21">1020</A></TD><TD> */</TD></TR><TR><TD CLASS="l">1021</TD><TD>public void initialize(JavaProject project, int possibleMatchSize) throws JavaScriptModelException {</TD></TR><TR><TD CLASS="l">1022</TD><TD>        // clean up name environment only if there are several possible match as it is reused</TD></TR><TR><TD CLASS="l">1023</TD><TD>        // when only one possible match (bug 58581)</TD></TR><TR CLASS="z"><TD CLASS="l">1024</TD><TD>        if (this.nameEnvironment != null &amp;&amp; possibleMatchSize != 1)</TD></TR><TR CLASS="z"><TD CLASS="l">1025</TD><TD>                this.nameEnvironment.cleanup();</TD></TR><TR><TD CLASS="l">1026</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1027</TD><TD>        SearchableEnvironment searchableEnvironment = project.newSearchableNameEnvironment(this.workingCopies);</TD></TR><TR><TD CLASS="l">1028</TD><TD> </TD></TR><TR><TD CLASS="l">1029</TD><TD>        // if only one possible match, a file name environment costs too much,</TD></TR><TR><TD CLASS="l">1030</TD><TD>        // so use the existing searchable  environment which will populate the java model</TD></TR><TR><TD CLASS="l">1031</TD><TD>        // only for this possible match and its required types.</TD></TR><TR CLASS="z"><TD CLASS="l">1032</TD><TD>        this.nameEnvironment = true//possibleMatchSize == 1</TD></TR><TR CLASS="z"><TD CLASS="l">1033</TD><TD>                ? (INameEnvironment) searchableEnvironment</TD></TR><TR><TD CLASS="l">1034</TD><TD>                : (INameEnvironment) new JavaSearchNameEnvironment(project, this.workingCopies);</TD></TR><TR><TD CLASS="l">1035</TD><TD> </TD></TR><TR><TD CLASS="l">1036</TD><TD>        // create lookup environment</TD></TR><TR CLASS="z"><TD CLASS="l">1037</TD><TD>        Map map = project.getOptions(true);</TD></TR><TR CLASS="z"><TD CLASS="l">1038</TD><TD>        map.put(CompilerOptions.OPTION_TaskTags, &#34;&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1039</TD><TD>        this.options = new CompilerOptions(map);</TD></TR><TR CLASS="z"><TD CLASS="l">1040</TD><TD>        ProblemReporter problemReporter =</TD></TR><TR CLASS="z"><TD CLASS="l">1041</TD><TD>                new ProblemReporter(</TD></TR><TR CLASS="z"><TD CLASS="l">1042</TD><TD>                        DefaultErrorHandlingPolicies.proceedWithAllProblems(),</TD></TR><TR CLASS="z"><TD CLASS="l">1043</TD><TD>                        this.options,</TD></TR><TR CLASS="z"><TD CLASS="l">1044</TD><TD>                        new DefaultProblemFactory());</TD></TR><TR CLASS="z"><TD CLASS="l">1045</TD><TD>        this.lookupEnvironment = new LookupEnvironment(this, this.options, problemReporter, this.nameEnvironment);</TD></TR><TR><TD CLASS="l">1046</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1047</TD><TD>        this.parser = MatchLocatorParser.createParser(problemReporter, this);</TD></TR><TR><TD CLASS="l">1048</TD><TD> </TD></TR><TR><TD CLASS="l">1049</TD><TD>        // basic parser needs also to be reset as project options may have changed</TD></TR><TR><TD CLASS="l">1050</TD><TD>        // see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=163072</TD></TR><TR CLASS="z"><TD CLASS="l">1051</TD><TD>        this.basicParser = null;</TD></TR><TR><TD CLASS="l">1052</TD><TD> </TD></TR><TR><TD CLASS="l">1053</TD><TD>        // remember project's name lookup</TD></TR><TR CLASS="z"><TD CLASS="l">1054</TD><TD>        this.nameLookup = searchableEnvironment.nameLookup;</TD></TR><TR><TD CLASS="l">1055</TD><TD> </TD></TR><TR><TD CLASS="l">1056</TD><TD>        // initialize queue of units</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="22">1057</A></TD><TD>        this.numberOfMatches = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1058</TD><TD>        this.matchesToProcess = new PossibleMatch[possibleMatchSize];</TD></TR><TR CLASS="z"><TD CLASS="l">1059</TD><TD>}</TD></TR><TR><TD CLASS="l">1060</TD><TD>protected void locateMatches(JavaProject javaProject, PossibleMatch[] possibleMatches, int start, int length) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1061</TD><TD>        initialize(javaProject, length);</TD></TR><TR><TD CLASS="l">1062</TD><TD> </TD></TR><TR><TD CLASS="l">1063</TD><TD>        // create and resolve binding (equivalent to beginCompilation() in Compiler)</TD></TR><TR CLASS="z"><TD CLASS="l">1064</TD><TD>        boolean mustResolvePattern = ((InternalSearchPattern)this.pattern).mustResolve;</TD></TR><TR CLASS="z"><TD CLASS="l">1065</TD><TD>        boolean mustResolve = mustResolvePattern;</TD></TR><TR CLASS="z"><TD CLASS="l">1066</TD><TD>        this.patternLocator.mayBeGeneric = this.options.sourceLevel &gt;= ClassFileConstants.JDK1_5;</TD></TR><TR CLASS="z"><TD CLASS="l">1067</TD><TD>        boolean bindingsWereCreated = mustResolve;</TD></TR><TR><TD CLASS="l">1068</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1069</TD><TD>                for (int i = start, maxUnits = start + length; i &lt; maxUnits; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1070</TD><TD>                        PossibleMatch possibleMatch = possibleMatches[i];</TD></TR><TR><TD CLASS="l">1071</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1072</TD><TD>                                if (possibleMatch.openable instanceof MetadataFile)</TD></TR><TR><TD CLASS="l">1073</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1074</TD><TD>                                        this.currentPossibleMatch=possibleMatch;</TD></TR><TR CLASS="z"><TD CLASS="l">1075</TD><TD>                                        processMetadata((MetadataFile)possibleMatch.openable);</TD></TR><TR><TD CLASS="l">1076</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1077</TD><TD>                                else</TD></TR><TR><TD CLASS="l">1078</TD><TD>                                {</TD></TR><TR CLASS="z"><TD CLASS="l">1079</TD><TD>                                if (!parseAndBuildBindings(possibleMatch, mustResolvePattern)) continue;</TD></TR><TR><TD CLASS="l">1080</TD><TD>                                // Currently we only need to resolve over pattern flag if there's potential parameterized types</TD></TR><TR CLASS="z"><TD CLASS="l">1081</TD><TD>                                if (this.patternLocator.mayBeGeneric) {</TD></TR><TR><TD CLASS="l">1082</TD><TD>                                        // If pattern does not resolve then rely on possible match node set resolution</TD></TR><TR><TD CLASS="l">1083</TD><TD>                                        // which may have been modified while locator was adding possible matches to it</TD></TR><TR CLASS="z"><TD CLASS="l">1084</TD><TD>                                        if (!mustResolvePattern &amp;&amp; !mustResolve) {</TD></TR><TR CLASS="z"><TD CLASS="l">1085</TD><TD>                                                mustResolve = possibleMatch.nodeSet.mustResolve;</TD></TR><TR CLASS="z"><TD CLASS="l">1086</TD><TD>                                                bindingsWereCreated = mustResolve;</TD></TR><TR><TD CLASS="l">1087</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1088</TD><TD>                                } else {</TD></TR><TR><TD CLASS="l">1089</TD><TD>                                        // Reset matching node resolution with pattern one if there's no potential parameterized type</TD></TR><TR><TD CLASS="l">1090</TD><TD>                                        // to minimize side effect on previous search behavior</TD></TR><TR CLASS="z"><TD CLASS="l">1091</TD><TD>                                        possibleMatch.nodeSet.mustResolve = mustResolvePattern;</TD></TR><TR><TD CLASS="l">1092</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1093</TD><TD>                                // possible match node resolution has been merged with pattern one, so rely on it to know</TD></TR><TR><TD CLASS="l">1094</TD><TD>                                // whether we need to process compilation unit now or later</TD></TR><TR CLASS="z"><TD CLASS="l">1095</TD><TD>                                if (!possibleMatch.nodeSet.mustResolve) {</TD></TR><TR CLASS="z"><TD CLASS="l">1096</TD><TD>                                        if (this.progressMonitor != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1097</TD><TD>                                                this.progressWorked++;</TD></TR><TR CLASS="z"><TD CLASS="l">1098</TD><TD>                                                if ((this.progressWorked%this.progressStep)==0) this.progressMonitor.worked(this.progressStep);</TD></TR><TR><TD CLASS="l">1099</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1100</TD><TD>                                        process(possibleMatch, bindingsWereCreated);</TD></TR><TR CLASS="z"><TD CLASS="l">1101</TD><TD>                                        if (this.numberOfMatches&gt;0 &amp;&amp; this.matchesToProcess[this.numberOfMatches-1] == possibleMatch) {</TD></TR><TR><TD CLASS="l">1102</TD><TD>                                                // forget last possible match as it was processed</TD></TR><TR CLASS="z"><TD CLASS="l">1103</TD><TD>                                                this.numberOfMatches--;</TD></TR><TR><TD CLASS="l">1104</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1105</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1106</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1107</TD><TD>                        } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1108</TD><TD>                                if (!possibleMatch.nodeSet.mustResolve)</TD></TR><TR CLASS="z"><TD CLASS="l">1109</TD><TD>                                        possibleMatch.cleanUp();</TD></TR><TR CLASS="z"><TD CLASS="l">1110</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1111</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1112</TD><TD>                if (mustResolve)</TD></TR><TR CLASS="z"><TD CLASS="l">1113</TD><TD>                        this.lookupEnvironment.completeTypeBindings();</TD></TR><TR><TD CLASS="l">1114</TD><TD> </TD></TR><TR><TD CLASS="l">1115</TD><TD>                // create hierarchy resolver if needed</TD></TR><TR CLASS="z"><TD CLASS="l">1116</TD><TD>                IType focusType = getFocusType();</TD></TR><TR CLASS="z"><TD CLASS="l">1117</TD><TD>                if (focusType == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1118</TD><TD>                        this.hierarchyResolver = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1119</TD><TD>                } else if (!createHierarchyResolver(focusType, possibleMatches)) {</TD></TR><TR><TD CLASS="l">1120</TD><TD>                        // focus type is not visible, use the super type names instead of the bindings</TD></TR><TR CLASS="z"><TD CLASS="l">1121</TD><TD>                        if (computeSuperTypeNames(focusType) == null) return;</TD></TR><TR><TD CLASS="l">1122</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1123</TD><TD>        } catch (AbortCompilation e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1124</TD><TD>                bindingsWereCreated = false;</TD></TR><TR><TD CLASS="l">1125</TD><TD>        }</TD></TR><TR><TD CLASS="l">1126</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1127</TD><TD>        if (!mustResolve) {</TD></TR><TR CLASS="z"><TD CLASS="l">1128</TD><TD>                return;</TD></TR><TR><TD CLASS="l">1129</TD><TD>        }</TD></TR><TR><TD CLASS="l">1130</TD><TD> </TD></TR><TR><TD CLASS="l">1131</TD><TD>        // possible match resolution</TD></TR><TR CLASS="z"><TD CLASS="l">1132</TD><TD>        for (int i = 0; i &lt; this.numberOfMatches; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1133</TD><TD>                if (this.progressMonitor != null &amp;&amp; this.progressMonitor.isCanceled())</TD></TR><TR CLASS="z"><TD CLASS="l">1134</TD><TD>                        throw new OperationCanceledException();</TD></TR><TR CLASS="z"><TD CLASS="l">1135</TD><TD>                PossibleMatch possibleMatch = this.matchesToProcess[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1136</TD><TD>                this.matchesToProcess[i] = null; // release reference to processed possible match</TD></TR><TR><TD CLASS="l">1137</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1138</TD><TD>                        process(possibleMatch, bindingsWereCreated);</TD></TR><TR CLASS="z"><TD CLASS="l">1139</TD><TD>                } catch (AbortCompilation e) {</TD></TR><TR><TD CLASS="l">1140</TD><TD>                        // problem with class path: it could not find base classes</TD></TR><TR><TD CLASS="l">1141</TD><TD>                        // continue and try next matching openable reporting innacurate matches (since bindings will be null)</TD></TR><TR CLASS="z"><TD CLASS="l">1142</TD><TD>                        bindingsWereCreated = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1143</TD><TD>                } catch (JavaScriptModelException e) {</TD></TR><TR><TD CLASS="l">1144</TD><TD>                        // problem with class path: it could not find base classes</TD></TR><TR><TD CLASS="l">1145</TD><TD>                        // continue and try next matching openable reporting innacurate matches (since bindings will be null)</TD></TR><TR CLASS="z"><TD CLASS="l">1146</TD><TD>                        bindingsWereCreated = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1147</TD><TD>                } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1148</TD><TD>                        if (this.progressMonitor != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1149</TD><TD>                                this.progressWorked++;</TD></TR><TR CLASS="z"><TD CLASS="l">1150</TD><TD>                                if ((this.progressWorked%this.progressStep)==0) this.progressMonitor.worked(this.progressStep);</TD></TR><TR><TD CLASS="l">1151</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1152</TD><TD>                        if (this.options.verbose)</TD></TR><TR CLASS="z"><TD CLASS="l">1153</TD><TD>                                System.out.println(</TD></TR><TR CLASS="z"><TD CLASS="l">1154</TD><TD>                                        Messages.bind(Messages.compilation_done,</TD></TR><TR CLASS="z"><TD CLASS="l">1155</TD><TD>                                                new String[] {</TD></TR><TR CLASS="z"><TD CLASS="l">1156</TD><TD>                                                        String.valueOf(i + 1),</TD></TR><TR CLASS="z"><TD CLASS="l">1157</TD><TD>                                                        String.valueOf(this.numberOfMatches),</TD></TR><TR CLASS="z"><TD CLASS="l">1158</TD><TD>                                                        new String(possibleMatch.parsedUnit.getFileName())</TD></TR><TR><TD CLASS="l">1159</TD><TD>                                                }));</TD></TR><TR><TD CLASS="l">1160</TD><TD>                        // cleanup compilation unit result</TD></TR><TR CLASS="z"><TD CLASS="l">1161</TD><TD>                        possibleMatch.cleanUp();</TD></TR><TR CLASS="z"><TD CLASS="l">1162</TD><TD>                }</TD></TR><TR><TD CLASS="l"><A NAME="33">1163</A></TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1164</TD><TD>}</TD></TR><TR><TD CLASS="l">1165</TD><TD>private void processMetadata(MetadataFile metadataFile) throws CoreException{</TD></TR><TR><TD CLASS="l">1166</TD><TD>        </TD></TR><TR CLASS="z"><TD CLASS="l">1167</TD><TD>                IType [] types = metadataFile.getTypes();</TD></TR><TR CLASS="z"><TD CLASS="l">1168</TD><TD>                int matchLevel=PatternLocator.IMPOSSIBLE_MATCH;</TD></TR><TR CLASS="z"><TD CLASS="l">1169</TD><TD>                for (int typeIndex = 0; typeIndex &lt; types.length; typeIndex++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1170</TD><TD>                        IType type=types[typeIndex];</TD></TR><TR CLASS="z"><TD CLASS="l">1171</TD><TD>                        matchLevel=this.patternLocator.matchMetadataElement(type);</TD></TR><TR CLASS="z"><TD CLASS="l">1172</TD><TD>                        if (matchLevel&gt;=PatternLocator.POSSIBLE_MATCH)</TD></TR><TR CLASS="z"><TD CLASS="l">1173</TD><TD>                                reportMatching(type, matchLevel, null, 1);</TD></TR><TR CLASS="z"><TD CLASS="l">1174</TD><TD>                        IFunction[] methods = type.getFunctions();</TD></TR><TR CLASS="z"><TD CLASS="l">1175</TD><TD>                        for (int methodIndex = 0; methodIndex &lt; methods.length; methodIndex++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1176</TD><TD>                                IFunction method=methods[methodIndex];</TD></TR><TR CLASS="z"><TD CLASS="l">1177</TD><TD>                                matchLevel=this.patternLocator.matchMetadataElement(method);</TD></TR><TR CLASS="z"><TD CLASS="l">1178</TD><TD>                                if (matchLevel&gt;=PatternLocator.POSSIBLE_MATCH)</TD></TR><TR CLASS="z"><TD CLASS="l">1179</TD><TD>                                        reportMatching(method, matchLevel, null, 1);</TD></TR><TR><TD CLASS="l">1180</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1181</TD><TD>                        IField[] fields = type.getFields();</TD></TR><TR CLASS="z"><TD CLASS="l">1182</TD><TD>                        for (int fieldIndex = 0; fieldIndex &lt; fields.length; fieldIndex++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1183</TD><TD>                                IField field=fields[fieldIndex];</TD></TR><TR CLASS="z"><TD CLASS="l">1184</TD><TD>                                matchLevel=this.patternLocator.matchMetadataElement(field);</TD></TR><TR CLASS="z"><TD CLASS="l">1185</TD><TD>                                if (matchLevel&gt;=PatternLocator.POSSIBLE_MATCH)</TD></TR><TR CLASS="z"><TD CLASS="l">1186</TD><TD>                                        reportMatching(field, matchLevel, null, 1);</TD></TR><TR><TD CLASS="l">1187</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1188</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1189</TD><TD>                IFunction[] methods = metadataFile.getFunctions();</TD></TR><TR CLASS="z"><TD CLASS="l">1190</TD><TD>                for (int methodIndex = 0; methodIndex &lt; methods.length; methodIndex++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1191</TD><TD>                        IFunction method=methods[methodIndex];</TD></TR><TR CLASS="z"><TD CLASS="l">1192</TD><TD>                        matchLevel=this.patternLocator.matchMetadataElement(method);</TD></TR><TR CLASS="z"><TD CLASS="l">1193</TD><TD>                        if (matchLevel&gt;=PatternLocator.POSSIBLE_MATCH)</TD></TR><TR CLASS="z"><TD CLASS="l">1194</TD><TD>                                reportMatching(method, matchLevel, null, 1);</TD></TR><TR><TD CLASS="l">1195</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1196</TD><TD>                IField[] fields = metadataFile.getFields();</TD></TR><TR CLASS="z"><TD CLASS="l">1197</TD><TD>                for (int fieldIndex = 0; fieldIndex &lt; fields.length; fieldIndex++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1198</TD><TD>                        IField field=fields[fieldIndex];</TD></TR><TR CLASS="z"><TD CLASS="l">1199</TD><TD>                        matchLevel=this.patternLocator.matchMetadataElement(field);</TD></TR><TR CLASS="z"><TD CLASS="l">1200</TD><TD>                        if (matchLevel&gt;=PatternLocator.POSSIBLE_MATCH)</TD></TR><TR CLASS="z"><TD CLASS="l">1201</TD><TD>                                reportMatching(field, matchLevel, null, 1);</TD></TR><TR><TD CLASS="l">1202</TD><TD>                }</TD></TR><TR><TD CLASS="l">1203</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1204</TD><TD>}</TD></TR><TR><TD CLASS="l">1205</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="23">1206</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">1207</TD><TD> * Locate the matches amongst the possible matches.</TD></TR><TR><TD CLASS="l">1208</TD><TD> */</TD></TR><TR><TD CLASS="l">1209</TD><TD>protected void locateMatches(JavaProject javaProject, PossibleMatchSet matchSet, int expected) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1210</TD><TD>        PossibleMatch[] possibleMatches = matchSet.getPossibleMatches(javaProject.getPackageFragmentRoots());</TD></TR><TR CLASS="z"><TD CLASS="l">1211</TD><TD>        int length = possibleMatches.length;</TD></TR><TR><TD CLASS="l">1212</TD><TD>        // increase progress from duplicate matches not stored in matchSet while adding...</TD></TR><TR CLASS="z"><TD CLASS="l">1213</TD><TD>        if (this.progressMonitor != null &amp;&amp; expected&gt;length) {</TD></TR><TR CLASS="z"><TD CLASS="l">1214</TD><TD>                this.progressWorked += expected-length;</TD></TR><TR CLASS="z"><TD CLASS="l">1215</TD><TD>                this.progressMonitor.worked( expected-length);</TD></TR><TR><TD CLASS="l">1216</TD><TD>        }</TD></TR><TR><TD CLASS="l">1217</TD><TD>        // locate matches (processed matches are limited to avoid problem while using VM default memory heap size)</TD></TR><TR CLASS="z"><TD CLASS="l">1218</TD><TD>        for (int index = 0; index &lt; length;) {</TD></TR><TR CLASS="z"><TD CLASS="l">1219</TD><TD>                int max = Math.min(MAX_AT_ONCE, length - index);</TD></TR><TR CLASS="z"><TD CLASS="l">1220</TD><TD>                locateMatches(javaProject, possibleMatches, index, max);</TD></TR><TR CLASS="z"><TD CLASS="l">1221</TD><TD>                index += max;</TD></TR><TR><TD CLASS="l">1222</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1223</TD><TD>        this.patternLocator.clear();</TD></TR><TR CLASS="z"><TD CLASS="l">1224</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="24">1225</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">1226</TD><TD> * Locate the matches in the given files and report them using the search requestor.</TD></TR><TR><TD CLASS="l">1227</TD><TD> */</TD></TR><TR><TD CLASS="l">1228</TD><TD>public void locateMatches(SearchDocument[] searchDocuments) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1229</TD><TD>        int docsLength = searchDocuments.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1230</TD><TD>        if (BasicSearchEngine.VERBOSE) {</TD></TR><TR CLASS="z"><TD CLASS="l">1231</TD><TD>                System.out.println(&#34;Locating matches in documents [&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1232</TD><TD>                for (int i = 0; i &lt; docsLength; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">1233</TD><TD>                        System.out.println(&#34;\t&#34; + searchDocuments[i]); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1234</TD><TD>                System.out.println(&#34;]&#34;); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1235</TD><TD>        }</TD></TR><TR><TD CLASS="l">1236</TD><TD> </TD></TR><TR><TD CLASS="l">1237</TD><TD>        // init infos for progress increasing</TD></TR><TR CLASS="z"><TD CLASS="l">1238</TD><TD>        int n = docsLength&lt;1000 ? Math.min(Math.max(docsLength/200+1, 2),4) : 5 *(docsLength/1000);</TD></TR><TR CLASS="z"><TD CLASS="l">1239</TD><TD>        this.progressStep = docsLength &lt; n ? 1 : docsLength / n; // step should not be 0</TD></TR><TR CLASS="z"><TD CLASS="l">1240</TD><TD>        this.progressWorked = 0;</TD></TR><TR><TD CLASS="l">1241</TD><TD> </TD></TR><TR><TD CLASS="l">1242</TD><TD>        // extract working copies</TD></TR><TR CLASS="z"><TD CLASS="l">1243</TD><TD>        ArrayList copies = new ArrayList();</TD></TR><TR CLASS="z"><TD CLASS="l">1244</TD><TD>        for (int i = 0; i &lt; docsLength; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1245</TD><TD>                SearchDocument document = searchDocuments[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1246</TD><TD>                if (document instanceof WorkingCopyDocument) {</TD></TR><TR CLASS="z"><TD CLASS="l">1247</TD><TD>                        copies.add(((WorkingCopyDocument)document).workingCopy);</TD></TR><TR><TD CLASS="l">1248</TD><TD>                }</TD></TR><TR><TD CLASS="l">1249</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1250</TD><TD>        int copiesLength = copies.size();</TD></TR><TR CLASS="z"><TD CLASS="l">1251</TD><TD>        this.workingCopies = new org.eclipse.wst.jsdt.core.IJavaScriptUnit[copiesLength];</TD></TR><TR CLASS="z"><TD CLASS="l">1252</TD><TD>        copies.toArray(this.workingCopies);</TD></TR><TR><TD CLASS="l">1253</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1254</TD><TD>        JavaModelManager manager = JavaModelManager.getJavaModelManager();</TD></TR><TR CLASS="z"><TD CLASS="l">1255</TD><TD>        this.bindings = new SimpleLookupTable();</TD></TR><TR><TD CLASS="l">1256</TD><TD>        try {</TD></TR><TR><TD CLASS="l">1257</TD><TD>                // optimize access to zip files during search operation</TD></TR><TR CLASS="z"><TD CLASS="l">1258</TD><TD>                manager.cacheZipFiles();</TD></TR><TR><TD CLASS="l">1259</TD><TD> </TD></TR><TR><TD CLASS="l">1260</TD><TD>                // initialize handle factory (used as a cache of handles so as to optimize space)</TD></TR><TR CLASS="z"><TD CLASS="l">1261</TD><TD>                if (this.handleFactory == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1262</TD><TD>                        this.handleFactory = new HandleFactory();</TD></TR><TR><TD CLASS="l">1263</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1264</TD><TD>                if (this.progressMonitor != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1265</TD><TD>                        this.progressMonitor.beginTask(&#34;&#34;, searchDocuments.length); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1266</TD><TD>                }</TD></TR><TR><TD CLASS="l">1267</TD><TD> </TD></TR><TR><TD CLASS="l">1268</TD><TD>                // initialize pattern for polymorphic search (ie. method reference pattern)</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="51">1269</A></TD><TD>                this.patternLocator.initializePolymorphicSearch(this);</TD></TR><TR><TD CLASS="l">1270</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="53">1271</A></TD><TD>                JavaProject previousJavaProject = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1272</TD><TD>                PossibleMatchSet matchSet = new PossibleMatchSet();</TD></TR><TR CLASS="z"><TD CLASS="l">1273</TD><TD>                Util.sort(searchDocuments, new Util.Comparer() {</TD></TR><TR><TD CLASS="l">1274</TD><TD>                        public int compare(Object a, Object b) {</TD></TR><TR CLASS="z"><TD CLASS="l">1275</TD><TD>                                return ((SearchDocument)a).getPath().compareTo(((SearchDocument)b).getPath());</TD></TR><TR><TD CLASS="l">1276</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1277</TD><TD>                });</TD></TR><TR CLASS="z"><TD CLASS="l">1278</TD><TD>                int displayed = 0; // progress worked displayed</TD></TR><TR CLASS="z"><TD CLASS="l">1279</TD><TD>                String previousPath = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1280</TD><TD>                for (int i = 0; i &lt; docsLength; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1281</TD><TD>                        if (this.progressMonitor != null &amp;&amp; this.progressMonitor.isCanceled()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1282</TD><TD>                                throw new OperationCanceledException();</TD></TR><TR><TD CLASS="l">1283</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1284</TD><TD> </TD></TR><TR><TD CLASS="l">1285</TD><TD>                        // skip duplicate paths</TD></TR><TR CLASS="z"><TD CLASS="l">1286</TD><TD>                        SearchDocument searchDocument = searchDocuments[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1287</TD><TD>                        searchDocuments[i] = null; // free current document</TD></TR><TR CLASS="z"><TD CLASS="l">1288</TD><TD>                        String pathString = searchDocument.getPath();</TD></TR><TR CLASS="z"><TD CLASS="l">1289</TD><TD>                        if (i &gt; 0 &amp;&amp; pathString.equals(previousPath)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1290</TD><TD>                                if (this.progressMonitor != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1291</TD><TD>                                        this.progressWorked++;</TD></TR><TR CLASS="z"><TD CLASS="l">1292</TD><TD>                                        if ((this.progressWorked%this.progressStep)==0) this.progressMonitor.worked(this.progressStep);</TD></TR><TR><TD CLASS="l">1293</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1294</TD><TD>                                displayed++;</TD></TR><TR CLASS="z"><TD CLASS="l">1295</TD><TD>                                continue;</TD></TR><TR><TD CLASS="l">1296</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1297</TD><TD>                        previousPath = pathString;</TD></TR><TR><TD CLASS="l">1298</TD><TD> </TD></TR><TR><TD CLASS="l">1299</TD><TD>                        Openable openable;</TD></TR><TR CLASS="z"><TD CLASS="l">1300</TD><TD>                        org.eclipse.wst.jsdt.core.IJavaScriptUnit workingCopy = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1301</TD><TD>                        if (searchDocument instanceof WorkingCopyDocument) {</TD></TR><TR CLASS="z"><TD CLASS="l">1302</TD><TD>                                workingCopy = ((WorkingCopyDocument)searchDocument).workingCopy;</TD></TR><TR CLASS="z"><TD CLASS="l">1303</TD><TD>                                openable = (Openable) workingCopy;</TD></TR><TR CLASS="z"><TD CLASS="l">1304</TD><TD>                        } else if(searchDocument.isVirtual()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1305</TD><TD>                                openable = (Openable)searchDocument.getJavaElement();</TD></TR><TR><TD CLASS="l">1306</TD><TD>                        }else{</TD></TR><TR CLASS="z"><TD CLASS="l">1307</TD><TD>                                openable = this.handleFactory.createOpenable(pathString, this.scope);</TD></TR><TR><TD CLASS="l">1308</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1309</TD><TD>                        if (openable == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1310</TD><TD>                                if (this.progressMonitor != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1311</TD><TD>                                        this.progressWorked++;</TD></TR><TR CLASS="z"><TD CLASS="l">1312</TD><TD>                                        if ((this.progressWorked%this.progressStep)==0) this.progressMonitor.worked(this.progressStep);</TD></TR><TR><TD CLASS="l">1313</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1314</TD><TD>                                displayed++;</TD></TR><TR CLASS="z"><TD CLASS="l">1315</TD><TD>                                continue; // match is outside classpath</TD></TR><TR><TD CLASS="l">1316</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1317</TD><TD> </TD></TR><TR><TD CLASS="l">1318</TD><TD>                        // create new parser and lookup environment if this is a new project</TD></TR><TR CLASS="z"><TD CLASS="l">1319</TD><TD>                        IResource resource = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1320</TD><TD>                        JavaProject javaProject = (JavaProject) openable.getJavaScriptProject();</TD></TR><TR CLASS="z"><TD CLASS="l">1321</TD><TD>                        resource = workingCopy != null ? workingCopy.getResource() : openable.getResource();</TD></TR><TR CLASS="z"><TD CLASS="l">1322</TD><TD>                        if (resource == null)</TD></TR><TR CLASS="z"><TD CLASS="l">1323</TD><TD>                                resource = javaProject.getProject(); // case of a file in an external jar</TD></TR><TR CLASS="z"><TD CLASS="l">1324</TD><TD>                        if (!javaProject.equals(previousJavaProject)) {</TD></TR><TR><TD CLASS="l">1325</TD><TD>                                // locate matches in previous project</TD></TR><TR CLASS="z"><TD CLASS="l">1326</TD><TD>                                if (previousJavaProject != null) {</TD></TR><TR><TD CLASS="l">1327</TD><TD>                                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1328</TD><TD>                                                locateMatches(previousJavaProject, matchSet, i-displayed);</TD></TR><TR CLASS="z"><TD CLASS="l">1329</TD><TD>                                                displayed = i;</TD></TR><TR CLASS="z"><TD CLASS="l">1330</TD><TD>                                        } catch (JavaScriptModelException e) {</TD></TR><TR><TD CLASS="l">1331</TD><TD>                                                // problem with classpath in this project -&gt; skip it</TD></TR><TR><TD CLASS="l">1332</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1333</TD><TD>                                        matchSet.reset();</TD></TR><TR><TD CLASS="l">1334</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1335</TD><TD>                                previousJavaProject = javaProject;</TD></TR><TR><TD CLASS="l">1336</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1337</TD><TD>                        matchSet.add(new PossibleMatch(this, resource, openable, searchDocument, ((InternalSearchPattern) this.pattern).mustResolve));</TD></TR><TR><TD CLASS="l">1338</TD><TD>                }</TD></TR><TR><TD CLASS="l">1339</TD><TD> </TD></TR><TR><TD CLASS="l">1340</TD><TD>                // last project</TD></TR><TR CLASS="z"><TD CLASS="l">1341</TD><TD>                if (previousJavaProject != null) {</TD></TR><TR><TD CLASS="l">1342</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1343</TD><TD>                                locateMatches(previousJavaProject, matchSet, docsLength-displayed);</TD></TR><TR CLASS="z"><TD CLASS="l">1344</TD><TD>                        } catch (JavaScriptModelException e) {</TD></TR><TR><TD CLASS="l">1345</TD><TD>                                // problem with classpath in last project -&gt; ignore</TD></TR><TR><TD CLASS="l">1346</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1347</TD><TD>                }</TD></TR><TR><TD CLASS="l">1348</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1349</TD><TD>        } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1350</TD><TD>                if (this.progressMonitor != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1351</TD><TD>                        this.progressMonitor.done();</TD></TR><TR CLASS="z"><TD CLASS="l">1352</TD><TD>                if (this.nameEnvironment != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1353</TD><TD>                        this.nameEnvironment.cleanup();</TD></TR><TR CLASS="z"><TD CLASS="l">1354</TD><TD>                manager.flushZipFiles();</TD></TR><TR CLASS="z"><TD CLASS="l">1355</TD><TD>                this.bindings = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1356</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1357</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="25">1358</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">1359</TD><TD> * Locates the package declarations corresponding to this locator's pattern.</TD></TR><TR><TD CLASS="l">1360</TD><TD> */</TD></TR><TR><TD CLASS="l">1361</TD><TD>public void locatePackageDeclarations(SearchParticipant participant) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1362</TD><TD>        locatePackageDeclarations(this.pattern, participant);</TD></TR><TR CLASS="z"><TD CLASS="l">1363</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="26">1364</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">1365</TD><TD> * Locates the package declarations corresponding to the search pattern.</TD></TR><TR><TD CLASS="l">1366</TD><TD> */</TD></TR><TR><TD CLASS="l">1367</TD><TD>protected void locatePackageDeclarations(SearchPattern searchPattern, SearchParticipant participant) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1368</TD><TD>        if (searchPattern instanceof OrPattern) {</TD></TR><TR CLASS="z"><TD CLASS="l">1369</TD><TD>                SearchPattern[] patterns = ((OrPattern) searchPattern).patterns;</TD></TR><TR CLASS="z"><TD CLASS="l">1370</TD><TD>                for (int i = 0, length = patterns.length; i &lt; length; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">1371</TD><TD>                        locatePackageDeclarations(patterns[i], participant);</TD></TR><TR CLASS="z"><TD CLASS="l">1372</TD><TD>        } else if (searchPattern instanceof PackageDeclarationPattern) {</TD></TR><TR CLASS="z"><TD CLASS="l">1373</TD><TD>                IJavaScriptElement focus = ((InternalSearchPattern) searchPattern).focus;</TD></TR><TR CLASS="z"><TD CLASS="l">1374</TD><TD>                if (focus != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1375</TD><TD>                        if (encloses(focus)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1376</TD><TD>                                SearchMatch match = new PackageDeclarationMatch(focus.getAncestor(IJavaScriptElement.PACKAGE_FRAGMENT), SearchMatch.A_ACCURATE, -1, -1, participant, focus.getResource());</TD></TR><TR CLASS="z"><TD CLASS="l">1377</TD><TD>                                report(match);</TD></TR><TR><TD CLASS="l">1378</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1379</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">1380</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1381</TD><TD>                PackageDeclarationPattern pkgPattern = (PackageDeclarationPattern) searchPattern;</TD></TR><TR CLASS="z"><TD CLASS="l">1382</TD><TD>                boolean isWorkspaceScope = this.scope == JavaModelManager.getJavaModelManager().getWorkspaceScope();</TD></TR><TR CLASS="z"><TD CLASS="l">1383</TD><TD>                IPath[] scopeProjectsAndJars =  isWorkspaceScope ? null : this.scope.enclosingProjectsAndJars();</TD></TR><TR CLASS="z"><TD CLASS="l">1384</TD><TD>                int scopeLength = isWorkspaceScope ? 0 : scopeProjectsAndJars.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1385</TD><TD>                IJavaScriptProject[] projects = JavaModelManager.getJavaModelManager().getJavaModel().getJavaScriptProjects();</TD></TR><TR CLASS="z"><TD CLASS="l">1386</TD><TD>                SimpleSet packages = new SimpleSet();</TD></TR><TR CLASS="z"><TD CLASS="l">1387</TD><TD>                for (int i = 0, length = projects.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1388</TD><TD>                        IJavaScriptProject javaProject = projects[i];</TD></TR><TR><TD CLASS="l">1389</TD><TD>                        // Verify that project belongs to the scope</TD></TR><TR CLASS="z"><TD CLASS="l">1390</TD><TD>                        if (!isWorkspaceScope) {</TD></TR><TR CLASS="z"><TD CLASS="l">1391</TD><TD>                                boolean found = false;</TD></TR><TR CLASS="z"><TD CLASS="l">1392</TD><TD>                                for (int j=0; j&lt;scopeLength; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1393</TD><TD>                                        if (javaProject.getPath().equals(scopeProjectsAndJars[j])) {</TD></TR><TR CLASS="z"><TD CLASS="l">1394</TD><TD>                                                found = true;</TD></TR><TR CLASS="z"><TD CLASS="l">1395</TD><TD>                                                break;</TD></TR><TR><TD CLASS="l">1396</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1397</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1398</TD><TD>                                if (!found) continue;</TD></TR><TR><TD CLASS="l">1399</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1400</TD><TD>                        // Get all project package fragment names</TD></TR><TR CLASS="z"><TD CLASS="l">1401</TD><TD>                        this.nameLookup = ((JavaProject) projects[i]).newNameLookup(this.workingCopies);</TD></TR><TR CLASS="z"><TD CLASS="l">1402</TD><TD>                        IPackageFragment[] packageFragments = this.nameLookup.findPackageFragments(new String(pkgPattern.pkgName), true, true);</TD></TR><TR CLASS="z"><TD CLASS="l">1403</TD><TD>                        int pLength = packageFragments == null ? 0 : packageFragments.length;</TD></TR><TR><TD CLASS="l">1404</TD><TD>                        // Report matches avoiding duplicate names</TD></TR><TR CLASS="z"><TD CLASS="l">1405</TD><TD>                        for (int p=0; p&lt;pLength; p++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1406</TD><TD>                                IPackageFragment fragment = packageFragments[p];</TD></TR><TR CLASS="z"><TD CLASS="l">1407</TD><TD>                                if (packages.addIfNotIncluded(fragment) == null) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">1408</TD><TD>                                if (encloses(fragment)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1409</TD><TD>                                        IResource resource = fragment.getResource();</TD></TR><TR CLASS="z"><TD CLASS="l">1410</TD><TD>                                        if (resource == null) // case of a file in an external jar</TD></TR><TR CLASS="z"><TD CLASS="l">1411</TD><TD>                                                resource = javaProject.getProject();</TD></TR><TR><TD CLASS="l">1412</TD><TD>                                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1413</TD><TD>                                                if (encloses(fragment)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1414</TD><TD>                                                        SearchMatch match = new PackageDeclarationMatch(fragment, SearchMatch.A_ACCURATE, -1, -1, participant, resource);</TD></TR><TR CLASS="z"><TD CLASS="l">1415</TD><TD>                                                        report(match);</TD></TR><TR><TD CLASS="l">1416</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1417</TD><TD>                                        } catch (JavaScriptModelException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1418</TD><TD>                                                throw e;</TD></TR><TR CLASS="z"><TD CLASS="l">1419</TD><TD>                                        } catch (CoreException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">1420</TD><TD>                                                throw new JavaScriptModelException(e);</TD></TR><TR><TD CLASS="l">1421</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1422</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1423</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1424</TD><TD>                }</TD></TR><TR><TD CLASS="l"><A NAME="27">1425</A></TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1426</TD><TD>}</TD></TR><TR><TD CLASS="l">1427</TD><TD>//*/</TD></TR><TR><TD CLASS="l">1428</TD><TD>protected IType lookupType(ReferenceBinding typeBinding) {</TD></TR><TR CLASS="z"><TD CLASS="l">1429</TD><TD>        if (typeBinding == null) return null;</TD></TR><TR><TD CLASS="l">1430</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1431</TD><TD>        char[] packageName = typeBinding.qualifiedPackageName();</TD></TR><TR CLASS="z"><TD CLASS="l">1432</TD><TD>        IPackageFragment[] pkgs = this.nameLookup.findPackageFragments(</TD></TR><TR CLASS="z"><TD CLASS="l">1433</TD><TD>                (packageName == null || packageName.length == 0)</TD></TR><TR CLASS="z"><TD CLASS="l">1434</TD><TD>                        ? IPackageFragment.DEFAULT_PACKAGE_NAME</TD></TR><TR CLASS="z"><TD CLASS="l">1435</TD><TD>                        : new String(packageName),</TD></TR><TR CLASS="z"><TD CLASS="l">1436</TD><TD>                false);</TD></TR><TR><TD CLASS="l">1437</TD><TD> </TD></TR><TR><TD CLASS="l">1438</TD><TD>        // iterate type lookup in each package fragment</TD></TR><TR CLASS="z"><TD CLASS="l">1439</TD><TD>        char[] sourceName = typeBinding.qualifiedSourceName();</TD></TR><TR CLASS="z"><TD CLASS="l">1440</TD><TD>        String typeName = new String(sourceName);</TD></TR><TR CLASS="z"><TD CLASS="l">1441</TD><TD>        int acceptFlag = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1442</TD><TD>        if (typeBinding.isAnnotationType()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1443</TD><TD>                acceptFlag = NameLookup.ACCEPT_ANNOTATIONS;</TD></TR><TR CLASS="z"><TD CLASS="l">1444</TD><TD>        } else if (typeBinding.isEnum()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1445</TD><TD>                acceptFlag = NameLookup.ACCEPT_ENUMS;</TD></TR><TR CLASS="z"><TD CLASS="l">1446</TD><TD>        } else if (typeBinding.isInterface()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1447</TD><TD>                acceptFlag = NameLookup.ACCEPT_INTERFACES;</TD></TR><TR CLASS="z"><TD CLASS="l">1448</TD><TD>        } else if (typeBinding.isClass()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1449</TD><TD>                acceptFlag = NameLookup.ACCEPT_CLASSES;</TD></TR><TR><TD CLASS="l">1450</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1451</TD><TD>        if (pkgs != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1452</TD><TD>                for (int i = 0, length = pkgs.length; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1453</TD><TD>                        IType type = this.nameLookup.findType(typeName, pkgs[i],  false,  acceptFlag, true/*consider secondary types*/);</TD></TR><TR CLASS="z"><TD CLASS="l">1454</TD><TD>                        if (type != null) return type;</TD></TR><TR><TD CLASS="l">1455</TD><TD>                }</TD></TR><TR><TD CLASS="l">1456</TD><TD>        }</TD></TR><TR><TD CLASS="l">1457</TD><TD> </TD></TR><TR><TD CLASS="l">1458</TD><TD>        // search inside enclosing element</TD></TR><TR CLASS="z"><TD CLASS="l">1459</TD><TD>        char[][] qualifiedName = CharOperation.splitOn('.', sourceName);</TD></TR><TR CLASS="z"><TD CLASS="l">1460</TD><TD>        int length = qualifiedName.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1461</TD><TD>        if (length == 0) return null;</TD></TR><TR><TD CLASS="l">1462</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1463</TD><TD>        IType type = createTypeHandle(new String(qualifiedName[0])); // find the top-level type</TD></TR><TR CLASS="z"><TD CLASS="l">1464</TD><TD>        if (type == null) return null;</TD></TR><TR><TD CLASS="l">1465</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1466</TD><TD>        for (int i = 1; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1467</TD><TD>                type = type.getType(new String(qualifiedName[i]));</TD></TR><TR CLASS="z"><TD CLASS="l">1468</TD><TD>                if (type == null) return null;</TD></TR><TR><TD CLASS="l">1469</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1470</TD><TD>        if (type.exists()) return type;</TD></TR><TR CLASS="z"><TD CLASS="l">1471</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">1472</TD><TD>}</TD></TR><TR><TD CLASS="l">1473</TD><TD>public SearchMatch newDeclarationMatch(</TD></TR><TR><TD CLASS="l">1474</TD><TD>                IJavaScriptElement element,</TD></TR><TR><TD CLASS="l"><A NAME="28">1475</A></TD><TD>                Binding binding,</TD></TR><TR><TD CLASS="l">1476</TD><TD>                int accuracy,</TD></TR><TR><TD CLASS="l">1477</TD><TD>                int offset,</TD></TR><TR><TD CLASS="l">1478</TD><TD>                int length) {</TD></TR><TR CLASS="z"><TD CLASS="l">1479</TD><TD>        SearchParticipant participant = getParticipant();</TD></TR><TR CLASS="z"><TD CLASS="l">1480</TD><TD>        IResource resource = this.currentPossibleMatch.resource;</TD></TR><TR CLASS="z"><TD CLASS="l">1481</TD><TD>        return newDeclarationMatch(element, binding, accuracy, offset, length, participant, resource);</TD></TR><TR><TD CLASS="l">1482</TD><TD>}</TD></TR><TR><TD CLASS="l">1483</TD><TD> </TD></TR><TR><TD CLASS="l">1484</TD><TD>public SearchMatch newDeclarationMatch(</TD></TR><TR><TD CLASS="l">1485</TD><TD>                IJavaScriptElement element,</TD></TR><TR><TD CLASS="l">1486</TD><TD>                Binding binding,</TD></TR><TR><TD CLASS="l">1487</TD><TD>                int accuracy,</TD></TR><TR><TD CLASS="l"><A NAME="29">1488</A></TD><TD>                int offset,</TD></TR><TR><TD CLASS="l">1489</TD><TD>                int length,</TD></TR><TR><TD CLASS="l">1490</TD><TD>                SearchParticipant participant,</TD></TR><TR><TD CLASS="l">1491</TD><TD>                IResource resource) {</TD></TR><TR CLASS="z"><TD CLASS="l">1492</TD><TD>        switch (element.getElementType()) {</TD></TR><TR><TD CLASS="l">1493</TD><TD>                case IJavaScriptElement.PACKAGE_FRAGMENT:</TD></TR><TR CLASS="z"><TD CLASS="l">1494</TD><TD>                        return new PackageDeclarationMatch(element, accuracy, offset, length, participant, resource);</TD></TR><TR><TD CLASS="l">1495</TD><TD>                case IJavaScriptElement.TYPE:</TD></TR><TR CLASS="z"><TD CLASS="l">1496</TD><TD>                        return new TypeDeclarationMatch(binding == null ? element : ((JavaElement) element).resolved(binding), accuracy, offset, length, participant, resource);</TD></TR><TR><TD CLASS="l">1497</TD><TD>                case IJavaScriptElement.FIELD:</TD></TR><TR CLASS="z"><TD CLASS="l">1498</TD><TD>                        return new FieldDeclarationMatch(binding == null ? element : ((JavaElement) element).resolved(binding), accuracy, offset, length, participant, resource);</TD></TR><TR><TD CLASS="l">1499</TD><TD>                case IJavaScriptElement.METHOD:</TD></TR><TR CLASS="z"><TD CLASS="l">1500</TD><TD>                        return new MethodDeclarationMatch(binding == null ? element : ((JavaElement) element).resolved(binding), accuracy, offset, length, participant, resource);</TD></TR><TR><TD CLASS="l">1501</TD><TD>                case IJavaScriptElement.LOCAL_VARIABLE:</TD></TR><TR CLASS="z"><TD CLASS="l">1502</TD><TD>                        return new LocalVariableDeclarationMatch(element, accuracy, offset, length, participant, resource);</TD></TR><TR><TD CLASS="l">1503</TD><TD>                case IJavaScriptElement.PACKAGE_DECLARATION:</TD></TR><TR CLASS="z"><TD CLASS="l">1504</TD><TD>                        return new PackageDeclarationMatch(element, accuracy, offset, length, participant, resource);</TD></TR><TR><TD CLASS="l">1505</TD><TD>                default:</TD></TR><TR CLASS="z"><TD CLASS="l">1506</TD><TD>                        return null;</TD></TR><TR><TD CLASS="l">1507</TD><TD>        }</TD></TR><TR><TD CLASS="l">1508</TD><TD>}</TD></TR><TR><TD CLASS="l">1509</TD><TD> </TD></TR><TR><TD CLASS="l">1510</TD><TD>public SearchMatch newFieldReferenceMatch(</TD></TR><TR><TD CLASS="l">1511</TD><TD>                IJavaScriptElement enclosingElement,</TD></TR><TR><TD CLASS="l">1512</TD><TD>                Binding enclosingBinding,</TD></TR><TR><TD CLASS="l"><A NAME="2a">1513</A></TD><TD>                int accuracy,</TD></TR><TR><TD CLASS="l">1514</TD><TD>                int offset,</TD></TR><TR><TD CLASS="l">1515</TD><TD>                int length,</TD></TR><TR><TD CLASS="l">1516</TD><TD>                ASTNode reference) {</TD></TR><TR CLASS="z"><TD CLASS="l">1517</TD><TD>        int bits = reference.bits;</TD></TR><TR CLASS="z"><TD CLASS="l">1518</TD><TD>        boolean isCoupoundAssigned = (bits &amp; ASTNode.IsCompoundAssigned) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1519</TD><TD>        boolean isReadAccess = isCoupoundAssigned || (bits &amp; ASTNode.IsStrictlyAssigned) == 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1520</TD><TD>        boolean isWriteAccess = isCoupoundAssigned || (bits &amp; ASTNode.IsStrictlyAssigned) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1521</TD><TD>        boolean insideDocComment = (bits &amp; ASTNode.InsideJavadoc) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1522</TD><TD>        SearchParticipant participant = getParticipant();</TD></TR><TR CLASS="z"><TD CLASS="l">1523</TD><TD>        IResource resource = this.currentPossibleMatch.resource;</TD></TR><TR CLASS="z"><TD CLASS="l">1524</TD><TD>        if (enclosingBinding != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1525</TD><TD>                enclosingElement = ((JavaElement) enclosingElement).resolved(enclosingBinding);</TD></TR><TR CLASS="z"><TD CLASS="l">1526</TD><TD>        return new FieldReferenceMatch(enclosingElement, accuracy, offset, length, isReadAccess, isWriteAccess, insideDocComment, participant, resource);</TD></TR><TR><TD CLASS="l">1527</TD><TD>}</TD></TR><TR><TD CLASS="l">1528</TD><TD> </TD></TR><TR><TD CLASS="l">1529</TD><TD>public SearchMatch newLocalVariableReferenceMatch(</TD></TR><TR><TD CLASS="l">1530</TD><TD>                IJavaScriptElement enclosingElement,</TD></TR><TR><TD CLASS="l"><A NAME="2b">1531</A></TD><TD>                int accuracy,</TD></TR><TR><TD CLASS="l">1532</TD><TD>                int offset,</TD></TR><TR><TD CLASS="l">1533</TD><TD>                int length,</TD></TR><TR><TD CLASS="l">1534</TD><TD>                ASTNode reference) {</TD></TR><TR CLASS="z"><TD CLASS="l">1535</TD><TD>        int bits = reference.bits;</TD></TR><TR CLASS="z"><TD CLASS="l">1536</TD><TD>        boolean isCoupoundAssigned = (bits &amp; ASTNode.IsCompoundAssigned) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1537</TD><TD>        boolean isReadAccess = isCoupoundAssigned || (bits &amp; ASTNode.IsStrictlyAssigned) == 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1538</TD><TD>        boolean isWriteAccess = isCoupoundAssigned || (bits &amp; ASTNode.IsStrictlyAssigned) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1539</TD><TD>        boolean insideDocComment = (bits &amp; ASTNode.InsideJavadoc) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1540</TD><TD>        SearchParticipant participant = getParticipant();</TD></TR><TR CLASS="z"><TD CLASS="l">1541</TD><TD>        IResource resource = this.currentPossibleMatch.resource;</TD></TR><TR CLASS="z"><TD CLASS="l">1542</TD><TD>        return new LocalVariableReferenceMatch(enclosingElement, accuracy, offset, length, isReadAccess, isWriteAccess, insideDocComment, participant, resource);</TD></TR><TR><TD CLASS="l">1543</TD><TD>}</TD></TR><TR><TD CLASS="l">1544</TD><TD> </TD></TR><TR><TD CLASS="l">1545</TD><TD>public SearchMatch newMethodReferenceMatch(</TD></TR><TR><TD CLASS="l">1546</TD><TD>                IJavaScriptElement enclosingElement,</TD></TR><TR><TD CLASS="l">1547</TD><TD>                Binding enclosingBinding,</TD></TR><TR><TD CLASS="l">1548</TD><TD>                int accuracy,</TD></TR><TR><TD CLASS="l">1549</TD><TD>                int offset,</TD></TR><TR><TD CLASS="l"><A NAME="2c">1550</A></TD><TD>                int length,</TD></TR><TR><TD CLASS="l">1551</TD><TD>                boolean isConstructor,</TD></TR><TR><TD CLASS="l">1552</TD><TD>                boolean isSynthetic,</TD></TR><TR><TD CLASS="l">1553</TD><TD>                ASTNode reference) {</TD></TR><TR CLASS="z"><TD CLASS="l">1554</TD><TD>        SearchParticipant participant = getParticipant();</TD></TR><TR CLASS="z"><TD CLASS="l">1555</TD><TD>        IResource resource = this.currentPossibleMatch.resource;</TD></TR><TR CLASS="z"><TD CLASS="l">1556</TD><TD>        boolean insideDocComment = (reference.bits &amp; ASTNode.InsideJavadoc) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1557</TD><TD>        if (enclosingBinding != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1558</TD><TD>                enclosingElement = ((JavaElement) enclosingElement).resolved(enclosingBinding);</TD></TR><TR CLASS="z"><TD CLASS="l">1559</TD><TD>        boolean isOverridden = (accuracy &amp; PatternLocator.SUPER_INVOCATION_FLAVOR) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1560</TD><TD>        return new MethodReferenceMatch(enclosingElement, accuracy, offset, length, isConstructor, isSynthetic, isOverridden, insideDocComment, participant, resource);</TD></TR><TR><TD CLASS="l">1561</TD><TD>}</TD></TR><TR><TD CLASS="l">1562</TD><TD> </TD></TR><TR><TD CLASS="l">1563</TD><TD>public SearchMatch newPackageReferenceMatch(</TD></TR><TR><TD CLASS="l">1564</TD><TD>                IJavaScriptElement enclosingElement,</TD></TR><TR><TD CLASS="l"><A NAME="2d">1565</A></TD><TD>                int accuracy,</TD></TR><TR><TD CLASS="l">1566</TD><TD>                int offset,</TD></TR><TR><TD CLASS="l">1567</TD><TD>                int length,</TD></TR><TR><TD CLASS="l">1568</TD><TD>                ASTNode reference) {</TD></TR><TR CLASS="z"><TD CLASS="l">1569</TD><TD>        SearchParticipant participant = getParticipant();</TD></TR><TR CLASS="z"><TD CLASS="l">1570</TD><TD>        IResource resource = this.currentPossibleMatch.resource;</TD></TR><TR CLASS="z"><TD CLASS="l">1571</TD><TD>        boolean insideDocComment = (reference.bits &amp; ASTNode.InsideJavadoc) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1572</TD><TD>        return new PackageReferenceMatch(enclosingElement, accuracy, offset, length, insideDocComment, participant, resource);</TD></TR><TR><TD CLASS="l">1573</TD><TD>}</TD></TR><TR><TD CLASS="l">1574</TD><TD> </TD></TR><TR><TD CLASS="l">1575</TD><TD>public SearchMatch newTypeParameterReferenceMatch(</TD></TR><TR><TD CLASS="l">1576</TD><TD>                IJavaScriptElement enclosingElement,</TD></TR><TR><TD CLASS="l"><A NAME="2e">1577</A></TD><TD>                int accuracy,</TD></TR><TR><TD CLASS="l">1578</TD><TD>                int offset,</TD></TR><TR><TD CLASS="l">1579</TD><TD>                int length,</TD></TR><TR><TD CLASS="l">1580</TD><TD>                ASTNode reference) {</TD></TR><TR CLASS="z"><TD CLASS="l">1581</TD><TD>        int bits = reference.bits;</TD></TR><TR CLASS="z"><TD CLASS="l">1582</TD><TD>        boolean insideDocComment = (bits &amp; ASTNode.InsideJavadoc) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1583</TD><TD>        SearchParticipant participant = getParticipant();</TD></TR><TR CLASS="z"><TD CLASS="l">1584</TD><TD>        IResource resource = this.currentPossibleMatch.resource;</TD></TR><TR CLASS="z"><TD CLASS="l">1585</TD><TD>        return new TypeParameterReferenceMatch(enclosingElement, accuracy, offset, length, insideDocComment, participant, resource);</TD></TR><TR><TD CLASS="l">1586</TD><TD>}</TD></TR><TR><TD CLASS="l">1587</TD><TD> </TD></TR><TR><TD CLASS="l">1588</TD><TD>public TypeReferenceMatch newTypeReferenceMatch(</TD></TR><TR><TD CLASS="l">1589</TD><TD>                IJavaScriptElement enclosingElement,</TD></TR><TR><TD CLASS="l">1590</TD><TD>                Binding enclosingBinding,</TD></TR><TR><TD CLASS="l"><A NAME="30">1591</A></TD><TD>                int accuracy,</TD></TR><TR><TD CLASS="l">1592</TD><TD>                int offset,</TD></TR><TR><TD CLASS="l">1593</TD><TD>                int length,</TD></TR><TR><TD CLASS="l">1594</TD><TD>                ASTNode reference) {</TD></TR><TR CLASS="z"><TD CLASS="l">1595</TD><TD>        SearchParticipant participant = getParticipant();</TD></TR><TR CLASS="z"><TD CLASS="l">1596</TD><TD>        IResource resource = this.currentPossibleMatch.resource;</TD></TR><TR CLASS="z"><TD CLASS="l">1597</TD><TD>        boolean insideDocComment = (reference.bits &amp; ASTNode.InsideJavadoc) != 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1598</TD><TD>        if (enclosingBinding != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1599</TD><TD>                enclosingElement = ((JavaElement) enclosingElement).resolved(enclosingBinding);</TD></TR><TR CLASS="z"><TD CLASS="l">1600</TD><TD>        return new TypeReferenceMatch(enclosingElement, accuracy, offset, length, insideDocComment, participant, resource);</TD></TR><TR><TD CLASS="l">1601</TD><TD>}</TD></TR><TR><TD CLASS="l">1602</TD><TD> </TD></TR><TR><TD CLASS="l">1603</TD><TD>public TypeReferenceMatch newTypeReferenceMatch(</TD></TR><TR><TD CLASS="l"><A NAME="2f">1604</A></TD><TD>                IJavaScriptElement enclosingElement,</TD></TR><TR><TD CLASS="l">1605</TD><TD>                Binding enclosingBinding,</TD></TR><TR><TD CLASS="l">1606</TD><TD>                int accuracy,</TD></TR><TR><TD CLASS="l">1607</TD><TD>                ASTNode reference) {</TD></TR><TR CLASS="z"><TD CLASS="l">1608</TD><TD>        return newTypeReferenceMatch(enclosingElement, enclosingBinding, accuracy, reference.sourceStart, reference.sourceEnd-reference.sourceStart+1, reference);</TD></TR><TR><TD CLASS="l">1609</TD><TD>}</TD></TR><TR><TD CLASS="l">1610</TD><TD> </TD></TR><TR><TD CLASS="l">1611</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="31">1612</A></TD><TD> * Add the possibleMatch to the loop</TD></TR><TR><TD CLASS="l">1613</TD><TD> *  -&gt;  build compilation unit declarations, their bindings and record their results.</TD></TR><TR><TD CLASS="l">1614</TD><TD> */</TD></TR><TR><TD CLASS="l">1615</TD><TD>protected boolean parseAndBuildBindings(PossibleMatch possibleMatch, boolean mustResolve) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1616</TD><TD>        if (this.progressMonitor != null &amp;&amp; this.progressMonitor.isCanceled())</TD></TR><TR CLASS="z"><TD CLASS="l">1617</TD><TD>                throw new OperationCanceledException();</TD></TR><TR><TD CLASS="l">1618</TD><TD> </TD></TR><TR><TD CLASS="l">1619</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1620</TD><TD>                if (BasicSearchEngine.VERBOSE)</TD></TR><TR CLASS="z"><TD CLASS="l">1621</TD><TD>                        System.out.println(&#34;Parsing &#34; + possibleMatch.openable.toStringWithAncestors()); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1622</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1623</TD><TD>                this.parser.nodeSet = possibleMatch.nodeSet;</TD></TR><TR CLASS="z"><TD CLASS="l">1624</TD><TD>                CompilationResult unitResult = new CompilationResult(possibleMatch, 1, 1, this.options.maxProblemsPerUnit);</TD></TR><TR CLASS="z"><TD CLASS="l">1625</TD><TD>                CompilationUnitDeclaration parsedUnit = this.parser.dietParse(possibleMatch, unitResult);</TD></TR><TR CLASS="z"><TD CLASS="l">1626</TD><TD>                if (parsedUnit != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1627</TD><TD>                        this.parser.inferTypes(parsedUnit,this.options);</TD></TR><TR CLASS="z"><TD CLASS="l">1628</TD><TD>                        if (!parsedUnit.isEmpty()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1629</TD><TD>                                if (mustResolve) {</TD></TR><TR CLASS="z"><TD CLASS="l">1630</TD><TD>                                        this.lookupEnvironment.buildTypeBindings(parsedUnit, null /*no access restriction*/);</TD></TR><TR><TD CLASS="l">1631</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1632</TD><TD>                                if (hasAlreadyDefinedType(parsedUnit)) return false; // skip type has it is hidden so not visible</TD></TR><TR CLASS="z"><TD CLASS="l">1633</TD><TD>                                getMethodBodies(parsedUnit, possibleMatch.nodeSet);</TD></TR><TR CLASS="z"><TD CLASS="l">1634</TD><TD>                                if (this.patternLocator.mayBeGeneric &amp;&amp; !mustResolve &amp;&amp; possibleMatch.nodeSet.mustResolve) {</TD></TR><TR><TD CLASS="l">1635</TD><TD>                                        // special case: possible match node set force resolution although pattern does not</TD></TR><TR><TD CLASS="l">1636</TD><TD>                                        // =&gt; we need to build types for this compilation unit</TD></TR><TR CLASS="z"><TD CLASS="l">1637</TD><TD>                                        this.lookupEnvironment.buildTypeBindings(parsedUnit, null /*no access restriction*/);</TD></TR><TR><TD CLASS="l">1638</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1639</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1640</TD><TD> </TD></TR><TR><TD CLASS="l">1641</TD><TD>                        // add the possibleMatch with its parsedUnit to matchesToProcess</TD></TR><TR CLASS="z"><TD CLASS="l">1642</TD><TD>                        possibleMatch.parsedUnit = parsedUnit;</TD></TR><TR CLASS="z"><TD CLASS="l">1643</TD><TD>                        int size = this.matchesToProcess.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1644</TD><TD>                        if (this.numberOfMatches == size)</TD></TR><TR CLASS="z"><TD CLASS="l">1645</TD><TD>                                System.arraycopy(this.matchesToProcess, 0, this.matchesToProcess = new PossibleMatch[size == 0 ? 1 : size * 2], 0, this.numberOfMatches);</TD></TR><TR CLASS="z"><TD CLASS="l">1646</TD><TD>                        this.matchesToProcess[this.numberOfMatches++] = possibleMatch;</TD></TR><TR><TD CLASS="l">1647</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1648</TD><TD>        } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1649</TD><TD>                this.parser.nodeSet = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1650</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1651</TD><TD>        return true;</TD></TR><TR><TD CLASS="l">1652</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="32">1653</A></TD><TD>/*</TD></TR><TR><TD CLASS="l">1654</TD><TD> * Process a compilation unit already parsed and build.</TD></TR><TR><TD CLASS="l">1655</TD><TD> */</TD></TR><TR><TD CLASS="l">1656</TD><TD>protected void process(PossibleMatch possibleMatch, boolean bindingsWereCreated) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1657</TD><TD>        this.currentPossibleMatch = possibleMatch;</TD></TR><TR CLASS="z"><TD CLASS="l">1658</TD><TD>        CompilationUnitDeclaration unit = possibleMatch.parsedUnit;</TD></TR><TR><TD CLASS="l">1659</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1660</TD><TD>                if (unit.isEmpty()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1661</TD><TD>                        if (this.currentPossibleMatch.openable instanceof ClassFile) {</TD></TR><TR CLASS="z"><TD CLASS="l">1662</TD><TD>                                ClassFile classFile = (ClassFile) this.currentPossibleMatch.openable;</TD></TR><TR CLASS="z"><TD CLASS="l">1663</TD><TD>                                IBinaryType info = getBinaryInfo(classFile, this.currentPossibleMatch.resource);</TD></TR><TR CLASS="z"><TD CLASS="l">1664</TD><TD>                                if (info != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1665</TD><TD>                                        boolean mayBeGeneric = this.patternLocator.mayBeGeneric;</TD></TR><TR CLASS="z"><TD CLASS="l">1666</TD><TD>                                        this.patternLocator.mayBeGeneric = false; // there's no longer generics in class files</TD></TR><TR><TD CLASS="l">1667</TD><TD>                                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1668</TD><TD>                                                new ClassFileMatchLocator().locateMatches(this, classFile, info);</TD></TR><TR><TD CLASS="l">1669</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1670</TD><TD>                                        finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1671</TD><TD>                                                this.patternLocator.mayBeGeneric = mayBeGeneric;</TD></TR><TR CLASS="z"><TD CLASS="l">1672</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1673</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1674</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1675</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">1676</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1677</TD><TD>                if (hasAlreadyDefinedType(unit)) return; // skip type has it is hidden so not visible</TD></TR><TR><TD CLASS="l">1678</TD><TD> </TD></TR><TR><TD CLASS="l">1679</TD><TD>                // Move getMethodBodies to #parseAndBuildings(...) method to allow possible match resolution management</TD></TR><TR><TD CLASS="l">1680</TD><TD>                //getMethodBodies(unit);</TD></TR><TR><TD CLASS="l">1681</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1682</TD><TD>                boolean mustResolve = (((InternalSearchPattern)this.pattern).mustResolve || possibleMatch.nodeSet.mustResolve);</TD></TR><TR CLASS="z"><TD CLASS="l">1683</TD><TD>                if (bindingsWereCreated &amp;&amp; mustResolve) {</TD></TR><TR CLASS="z"><TD CLASS="l">1684</TD><TD>                        if (unit.types != null || unit.statements!=null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1685</TD><TD>                                if (BasicSearchEngine.VERBOSE)</TD></TR><TR CLASS="z"><TD CLASS="l">1686</TD><TD>                                        System.out.println(&#34;Resolving &#34; + this.currentPossibleMatch.openable.toStringWithAncestors()); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1687</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1688</TD><TD>                                this.lookupEnvironment.unitBeingCompleted = unit;</TD></TR><TR CLASS="z"><TD CLASS="l">1689</TD><TD>                                reduceParseTree(unit);</TD></TR><TR><TD CLASS="l">1690</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1691</TD><TD>                                if (unit.scope != null) {</TD></TR><TR><TD CLASS="l">1692</TD><TD>                                        // fault in fields &amp; methods</TD></TR><TR CLASS="z"><TD CLASS="l">1693</TD><TD>                                        unit.scope.faultInTypes();</TD></TR><TR><TD CLASS="l">1694</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1695</TD><TD>                                unit.resolve();</TD></TR><TR CLASS="z"><TD CLASS="l">1696</TD><TD>                        } else if (unit.isPackageInfo()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1697</TD><TD>                                if (BasicSearchEngine.VERBOSE)</TD></TR><TR CLASS="z"><TD CLASS="l">1698</TD><TD>                                        System.out.println(&#34;Resolving &#34; + this.currentPossibleMatch.openable.toStringWithAncestors()); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1699</TD><TD>                                unit.resolve();</TD></TR><TR><TD CLASS="l">1700</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1701</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1702</TD><TD>                reportMatching(unit, mustResolve);</TD></TR><TR CLASS="z"><TD CLASS="l">1703</TD><TD>        } catch (AbortCompilation e) {</TD></TR><TR><TD CLASS="l">1704</TD><TD>                // could not resolve: report inaccurate matches</TD></TR><TR CLASS="z"><TD CLASS="l">1705</TD><TD>                reportMatching(unit, false); // do not resolve when cu has errors</TD></TR><TR CLASS="z"><TD CLASS="l">1706</TD><TD>                if (!(e instanceof AbortCompilationUnit)) {</TD></TR><TR><TD CLASS="l">1707</TD><TD>                        // problem with class path</TD></TR><TR CLASS="z"><TD CLASS="l">1708</TD><TD>                        throw e;</TD></TR><TR><TD CLASS="l">1709</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1710</TD><TD>        } finally {</TD></TR><TR CLASS="z"><TD CLASS="l">1711</TD><TD>                this.lookupEnvironment.unitBeingCompleted = null;</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="36">1712</A></TD><TD>                this.currentPossibleMatch = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1713</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1714</TD><TD>}</TD></TR><TR><TD CLASS="l">1715</TD><TD>protected void purgeMethodStatements(TypeDeclaration type, boolean checkEachMethod) {</TD></TR><TR CLASS="z"><TD CLASS="l">1716</TD><TD>        checkEachMethod = checkEachMethod</TD></TR><TR CLASS="z"><TD CLASS="l">1717</TD><TD>                &amp;&amp; this.currentPossibleMatch.nodeSet.hasPossibleNodes(type.declarationSourceStart, type.declarationSourceEnd);</TD></TR><TR CLASS="z"><TD CLASS="l">1718</TD><TD>        AbstractMethodDeclaration[] methods = type.methods;</TD></TR><TR CLASS="z"><TD CLASS="l">1719</TD><TD>        if (methods != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1720</TD><TD>                if (checkEachMethod) {</TD></TR><TR CLASS="z"><TD CLASS="l">1721</TD><TD>                        for (int j = 0, length = methods.length; j &lt; length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1722</TD><TD>                                AbstractMethodDeclaration method = methods[j];</TD></TR><TR CLASS="z"><TD CLASS="l">1723</TD><TD>                                purgeMethodStatements(method);</TD></TR><TR><TD CLASS="l">1724</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1725</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1726</TD><TD>                        for (int j = 0, length = methods.length; j &lt; length; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1727</TD><TD>                                methods[j].statements = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1728</TD><TD>                                methods[j].javadoc = null;</TD></TR><TR><TD CLASS="l">1729</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1730</TD><TD>                }</TD></TR><TR><TD CLASS="l">1731</TD><TD>        }</TD></TR><TR><TD CLASS="l">1732</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1733</TD><TD>        TypeDeclaration[] memberTypes = type.memberTypes;</TD></TR><TR CLASS="z"><TD CLASS="l">1734</TD><TD>        if (memberTypes != null)</TD></TR><TR CLASS="z"><TD CLASS="l">1735</TD><TD>                for (int i = 0, l = memberTypes.length; i &lt; l; i++)</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="35">1736</A></TD><TD>                        purgeMethodStatements(memberTypes[i], checkEachMethod);</TD></TR><TR CLASS="z"><TD CLASS="l">1737</TD><TD>}</TD></TR><TR><TD CLASS="l">1738</TD><TD> </TD></TR><TR><TD CLASS="l">1739</TD><TD>private void purgeMethodStatements(AbstractMethodDeclaration method) {</TD></TR><TR CLASS="z"><TD CLASS="l">1740</TD><TD>        if (!this.currentPossibleMatch.nodeSet.hasPossibleNodes(method.declarationSourceStart, method.declarationSourceEnd)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1741</TD><TD>                method.statements = null;</TD></TR><TR CLASS="z"><TD CLASS="l">1742</TD><TD>                method.javadoc = null;</TD></TR><TR><TD CLASS="l">1743</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1744</TD><TD>}</TD></TR><TR><TD CLASS="l">1745</TD><TD> </TD></TR><TR><TD CLASS="l">1746</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="37">1747</A></TD><TD> * Called prior to the unit being resolved. Reduce the parse tree where possible.</TD></TR><TR><TD CLASS="l">1748</TD><TD> */</TD></TR><TR><TD CLASS="l">1749</TD><TD>protected void reduceParseTree(CompilationUnitDeclaration unit) {</TD></TR><TR><TD CLASS="l">1750</TD><TD>        // remove statements from methods that have no possible matching nodes</TD></TR><TR CLASS="z"><TD CLASS="l">1751</TD><TD>        if (unit.types!=null)</TD></TR><TR><TD CLASS="l">1752</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1753</TD><TD>                TypeDeclaration[] types = unit.types;</TD></TR><TR CLASS="z"><TD CLASS="l">1754</TD><TD>                for (int i = 0, l = types.length; i &lt; l; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">1755</TD><TD>                        purgeMethodStatements(types[i], true);</TD></TR><TR><TD CLASS="l">1756</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1757</TD><TD>        if (unit.statements!=null)</TD></TR><TR CLASS="z"><TD CLASS="l">1758</TD><TD>                for (int i = 0; i &lt; unit.statements.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1759</TD><TD>                        if (unit.statements[i] instanceof AbstractMethodDeclaration)</TD></TR><TR CLASS="z"><TD CLASS="l">1760</TD><TD>                                purgeMethodStatements((AbstractMethodDeclaration)unit.statements[i]);</TD></TR><TR><TD CLASS="l"><A NAME="1d">1761</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">1762</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1763</TD><TD>}</TD></TR><TR><TD CLASS="l">1764</TD><TD>public SearchParticipant getParticipant() {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="38">1765</A></TD><TD>        return this.currentPossibleMatch.document.getParticipant();</TD></TR><TR><TD CLASS="l">1766</TD><TD>}</TD></TR><TR><TD CLASS="l">1767</TD><TD> </TD></TR><TR><TD CLASS="l">1768</TD><TD>protected void report(SearchMatch match) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1769</TD><TD>        long start = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">1770</TD><TD>        if (BasicSearchEngine.VERBOSE) {</TD></TR><TR CLASS="z"><TD CLASS="l">1771</TD><TD>                start = System.currentTimeMillis();</TD></TR><TR CLASS="z"><TD CLASS="l">1772</TD><TD>                System.out.println(&#34;Reporting match&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1773</TD><TD>                System.out.println(&#34;\tResource: &#34; + match.getResource());//$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1774</TD><TD>                System.out.println(&#34;\tPositions: [offset=&#34; + match.getOffset() + &#34;, length=&#34; + match.getLength() + &#34;]&#34;); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$</TD></TR><TR><TD CLASS="l">1775</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1776</TD><TD>                        if (this.parser != null &amp;&amp; match.getOffset() &gt; 0 &amp;&amp; match.getLength() &gt; 0 &amp;&amp; !(match.getElement() instanceof BinaryMember)) {</TD></TR><TR CLASS="z"><TD CLASS="l">1777</TD><TD>                                String selection = new String(this.parser.scanner.source, match.getOffset(), match.getLength());</TD></TR><TR CLASS="z"><TD CLASS="l">1778</TD><TD>                                System.out.println(&#34;\tSelection: --&gt;&#34; + selection + &#34;&lt;--&#34;); //$NON-NLS-1$ //$NON-NLS-2$</TD></TR><TR><TD CLASS="l">1779</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1780</TD><TD>                } catch (Exception e) {</TD></TR><TR><TD CLASS="l">1781</TD><TD>                        // it's just for debug purposes... ignore all exceptions in this area</TD></TR><TR><TD CLASS="l">1782</TD><TD>                }</TD></TR><TR><TD CLASS="l">1783</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1784</TD><TD>                        JavaElement javaElement = (JavaElement)match.getElement();</TD></TR><TR CLASS="z"><TD CLASS="l">1785</TD><TD>                        System.out.println(&#34;\tJava element: &#34;+ javaElement.toStringWithAncestors()); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1786</TD><TD>                        if (!javaElement.exists()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1787</TD><TD>                                System.out.println(&#34;\t\tWARNING: this element does NOT exist!&#34;); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1788</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1789</TD><TD>                } catch (Exception e) {</TD></TR><TR><TD CLASS="l">1790</TD><TD>                        // it's just for debug purposes... ignore all exceptions in this area</TD></TR><TR><TD CLASS="l">1791</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1792</TD><TD>                if (match instanceof TypeReferenceMatch) {</TD></TR><TR><TD CLASS="l">1793</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1794</TD><TD>                                TypeReferenceMatch typeRefMatch = (TypeReferenceMatch) match;</TD></TR><TR CLASS="z"><TD CLASS="l">1795</TD><TD>                                JavaElement local = (JavaElement) typeRefMatch.getLocalElement();</TD></TR><TR CLASS="z"><TD CLASS="l">1796</TD><TD>                                if (local != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1797</TD><TD>                                        System.out.println(&#34;\tLocal element: &#34;+ local.toStringWithAncestors()); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1798</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1799</TD><TD>                                IJavaScriptElement[] others = typeRefMatch.getOtherElements();</TD></TR><TR CLASS="z"><TD CLASS="l">1800</TD><TD>                                if (others != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1801</TD><TD>                                        int length = others.length;</TD></TR><TR CLASS="z"><TD CLASS="l">1802</TD><TD>                                        if (length &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1803</TD><TD>                                                System.out.println(&#34;\tOther elements:&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1804</TD><TD>                                                for (int i=0; i&lt;length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">1805</TD><TD>                                                        JavaElement other = (JavaElement) others[i];</TD></TR><TR CLASS="z"><TD CLASS="l">1806</TD><TD>                                                        System.out.println(&#34;\t\t- &#34;+ other.toStringWithAncestors()); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1807</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1808</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1809</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">1810</TD><TD>                        } catch (Exception e) {</TD></TR><TR><TD CLASS="l">1811</TD><TD>                                // it's just for debug purposes... ignore all exceptions in this area</TD></TR><TR><TD CLASS="l">1812</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1813</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1814</TD><TD>                System.out.println(match.getAccuracy() == SearchMatch.A_ACCURATE</TD></TR><TR CLASS="z"><TD CLASS="l">1815</TD><TD>                        ? &#34;\tAccuracy: EXACT_MATCH&#34; //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1816</TD><TD>                        : &#34;\tAccuracy: POTENTIAL_MATCH&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1817</TD><TD>                System.out.print(&#34;\tRule: &#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1818</TD><TD>                if (match.isExact()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1819</TD><TD>                        System.out.print(&#34;EXACT&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1820</TD><TD>                } else if (match.isEquivalent()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1821</TD><TD>                        System.out.print(&#34;EQUIVALENT&#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">1822</TD><TD>                } else if (match.isErasure()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1823</TD><TD>                        System.out.print(&#34;ERASURE&#34;); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1824</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">1825</TD><TD>                        System.out.print(&#34;INVALID RULE&#34;); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1826</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1827</TD><TD>                if (match instanceof MethodReferenceMatch) {</TD></TR><TR CLASS="z"><TD CLASS="l">1828</TD><TD>                        MethodReferenceMatch methodReferenceMatch = (MethodReferenceMatch) match;</TD></TR><TR CLASS="z"><TD CLASS="l">1829</TD><TD>                        if (methodReferenceMatch.isSuperInvocation()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1830</TD><TD>                                System.out.print(&#34;+SUPER INVOCATION&#34;); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1831</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1832</TD><TD>                        if (methodReferenceMatch.isImplicit()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1833</TD><TD>                                System.out.print(&#34;+IMPLICIT&#34;); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1834</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1835</TD><TD>                        if (methodReferenceMatch.isSynthetic()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1836</TD><TD>                                System.out.print(&#34;+SYNTHETIC&#34;); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1837</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1838</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1839</TD><TD>                System.out.println(&#34;\n\tRaw: &#34;+match.isRaw()); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">1840</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1841</TD><TD>        this.requestor.acceptSearchMatch(match);</TD></TR><TR CLASS="z"><TD CLASS="l">1842</TD><TD>        if (BasicSearchEngine.VERBOSE)</TD></TR><TR CLASS="z"><TD CLASS="l">1843</TD><TD>                this.resultCollectorTime += System.currentTimeMillis()-start;</TD></TR><TR CLASS="z"><TD CLASS="l">1844</TD><TD>}</TD></TR><TR><TD CLASS="l">1845</TD><TD>/**</TD></TR><TR><TD CLASS="l">1846</TD><TD> * Finds the accurate positions of the sequence of tokens given by qualifiedName</TD></TR><TR><TD CLASS="l"><A NAME="3d">1847</A></TD><TD> * in the source and reports a reference to this this qualified name</TD></TR><TR><TD CLASS="l">1848</TD><TD> * to the search requestor.</TD></TR><TR><TD CLASS="l">1849</TD><TD> */</TD></TR><TR><TD CLASS="l">1850</TD><TD>protected void reportAccurateTypeReference(SearchMatch match, ASTNode typeRef, char[] name) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1851</TD><TD>        if (match.getRule() == 0) return;</TD></TR><TR CLASS="z"><TD CLASS="l">1852</TD><TD>        if (!encloses((IJavaScriptElement)match.getElement())) return;</TD></TR><TR><TD CLASS="l">1853</TD><TD> </TD></TR><TR><TD CLASS="l">1854</TD><TD>        // Compute source positions of the qualified reference</TD></TR><TR CLASS="z"><TD CLASS="l">1855</TD><TD>        int sourceStart = typeRef.sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">1856</TD><TD>        int sourceEnd = typeRef.sourceEnd;</TD></TR><TR CLASS="z"><TD CLASS="l">1857</TD><TD>        Scanner scanner = this.parser.scanner;</TD></TR><TR CLASS="z"><TD CLASS="l">1858</TD><TD>        scanner.setSource(this.currentPossibleMatch.getContents());</TD></TR><TR CLASS="z"><TD CLASS="l">1859</TD><TD>        scanner.resetTo(sourceStart, sourceEnd);</TD></TR><TR><TD CLASS="l">1860</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1861</TD><TD>        int token = -1;</TD></TR><TR><TD CLASS="l">1862</TD><TD>        int currentPosition;</TD></TR><TR><TD CLASS="l">1863</TD><TD>        do {</TD></TR><TR CLASS="z"><TD CLASS="l">1864</TD><TD>                currentPosition = scanner.currentPosition;</TD></TR><TR><TD CLASS="l">1865</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">1866</TD><TD>                        token = scanner.getNextToken();</TD></TR><TR CLASS="z"><TD CLASS="l">1867</TD><TD>                } catch (InvalidInputException e) {</TD></TR><TR><TD CLASS="l">1868</TD><TD>                        // ignore</TD></TR><TR><TD CLASS="l">1869</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1870</TD><TD>                if (token == TerminalTokens.TokenNameIdentifier &amp;&amp; this.pattern.matchesName(name, scanner.getCurrentTokenSource())) {</TD></TR><TR CLASS="z"><TD CLASS="l">1871</TD><TD>                        int length = scanner.currentPosition-currentPosition;</TD></TR><TR CLASS="z"><TD CLASS="l">1872</TD><TD>                        match.setOffset(currentPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">1873</TD><TD>                        match.setLength(length);</TD></TR><TR CLASS="z"><TD CLASS="l">1874</TD><TD>                        report(match);</TD></TR><TR CLASS="z"><TD CLASS="l">1875</TD><TD>                        return;</TD></TR><TR><TD CLASS="l">1876</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">1877</TD><TD>        } while (token != TerminalTokens.TokenNameEOF);</TD></TR><TR><TD CLASS="l">1878</TD><TD> </TD></TR><TR><TD CLASS="l">1879</TD><TD>        //        Report match</TD></TR><TR CLASS="z"><TD CLASS="l">1880</TD><TD>        match.setOffset(sourceStart);</TD></TR><TR CLASS="z"><TD CLASS="l">1881</TD><TD>        match.setLength(sourceEnd-sourceStart+1);</TD></TR><TR CLASS="z"><TD CLASS="l">1882</TD><TD>        report(match);</TD></TR><TR CLASS="z"><TD CLASS="l">1883</TD><TD>}</TD></TR><TR><TD CLASS="l">1884</TD><TD> </TD></TR><TR><TD CLASS="l">1885</TD><TD>/**</TD></TR><TR><TD CLASS="l">1886</TD><TD> * Finds the accurate positions of the sequence of tokens given by qualifiedName</TD></TR><TR><TD CLASS="l">1887</TD><TD> * in the source and reports a reference to this parameterized type name</TD></TR><TR><TD CLASS="l"><A NAME="3b">1888</A></TD><TD> * to the search requestor.</TD></TR><TR><TD CLASS="l">1889</TD><TD> * @since 3.1</TD></TR><TR><TD CLASS="l">1890</TD><TD> */</TD></TR><TR><TD CLASS="l">1891</TD><TD>protected void reportAccurateParameterizedMethodReference(SearchMatch match, ASTNode statement, TypeReference[] typeArguments) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1892</TD><TD>        if (match.getRule() == 0) return;</TD></TR><TR CLASS="z"><TD CLASS="l">1893</TD><TD>        if (!encloses((IJavaScriptElement)match.getElement())) return;</TD></TR><TR><TD CLASS="l">1894</TD><TD> </TD></TR><TR><TD CLASS="l">1895</TD><TD>        // If there's type arguments, look for end (ie. char '&gt;') of last one.</TD></TR><TR CLASS="z"><TD CLASS="l">1896</TD><TD>        int start = match.getOffset();</TD></TR><TR CLASS="z"><TD CLASS="l">1897</TD><TD>        if (typeArguments != null &amp;&amp; typeArguments.length &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1898</TD><TD>                boolean isErasureMatch= (pattern instanceof OrPattern) ? ((OrPattern)pattern).isErasureMatch() : ((JavaSearchPattern)pattern).isErasureMatch();</TD></TR><TR CLASS="z"><TD CLASS="l">1899</TD><TD>                if (!isErasureMatch) {</TD></TR><TR><TD CLASS="l">1900</TD><TD> </TD></TR><TR><TD CLASS="l">1901</TD><TD>                        // Initialize scanner</TD></TR><TR CLASS="z"><TD CLASS="l">1902</TD><TD>                        Scanner scanner = this.parser.scanner;</TD></TR><TR CLASS="z"><TD CLASS="l">1903</TD><TD>                        char[] source = this.currentPossibleMatch.getContents();</TD></TR><TR CLASS="z"><TD CLASS="l">1904</TD><TD>                        scanner.setSource(source);</TD></TR><TR><TD CLASS="l">1905</TD><TD> </TD></TR><TR><TD CLASS="l">1906</TD><TD>                        // Search previous opening '&lt;'</TD></TR><TR CLASS="z"><TD CLASS="l">1907</TD><TD>                        start = typeArguments[0].sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">1908</TD><TD>                        int end = statement.sourceEnd;</TD></TR><TR CLASS="z"><TD CLASS="l">1909</TD><TD>                        scanner.resetTo(start, end);</TD></TR><TR CLASS="z"><TD CLASS="l">1910</TD><TD>                        int lineStart = start;</TD></TR><TR><TD CLASS="l">1911</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">1912</TD><TD>                                linesUp: while (true) {</TD></TR><TR CLASS="z"><TD CLASS="l">1913</TD><TD>                                        while (scanner.source[scanner.currentPosition] != '\n') {</TD></TR><TR CLASS="z"><TD CLASS="l">1914</TD><TD>                                                scanner.currentPosition--;</TD></TR><TR CLASS="z"><TD CLASS="l">1915</TD><TD>                                                if (scanner.currentPosition == 0) break linesUp;</TD></TR><TR><TD CLASS="l">1916</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1917</TD><TD>                                        lineStart = scanner.currentPosition+1;</TD></TR><TR CLASS="z"><TD CLASS="l">1918</TD><TD>                                        scanner.resetTo(lineStart, end);</TD></TR><TR CLASS="z"><TD CLASS="l">1919</TD><TD>                                        while (!scanner.atEnd()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1920</TD><TD>                                                if (scanner.getNextToken() == TerminalTokens.TokenNameLESS) {</TD></TR><TR CLASS="z"><TD CLASS="l">1921</TD><TD>                                                        start = scanner.getCurrentTokenStartPosition();</TD></TR><TR CLASS="z"><TD CLASS="l">1922</TD><TD>                                                        break linesUp;</TD></TR><TR><TD CLASS="l">1923</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">1924</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1925</TD><TD>                                        end = lineStart - 2;</TD></TR><TR CLASS="z"><TD CLASS="l">1926</TD><TD>                                        scanner.currentPosition = end;</TD></TR><TR><TD CLASS="l">1927</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1928</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1929</TD><TD>                        catch (InvalidInputException ex) {</TD></TR><TR><TD CLASS="l">1930</TD><TD>                                // give up</TD></TR><TR><TD CLASS="l">1931</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1932</TD><TD>                 }</TD></TR><TR><TD CLASS="l">1933</TD><TD>        }</TD></TR><TR><TD CLASS="l">1934</TD><TD> </TD></TR><TR><TD CLASS="l">1935</TD><TD>        // Report match</TD></TR><TR CLASS="z"><TD CLASS="l">1936</TD><TD>        match.setOffset(start);</TD></TR><TR CLASS="z"><TD CLASS="l">1937</TD><TD>        match.setLength(statement.sourceEnd-start+1);</TD></TR><TR CLASS="z"><TD CLASS="l">1938</TD><TD>        report(match);</TD></TR><TR CLASS="z"><TD CLASS="l">1939</TD><TD>}</TD></TR><TR><TD CLASS="l">1940</TD><TD> </TD></TR><TR><TD CLASS="l">1941</TD><TD>/**</TD></TR><TR><TD CLASS="l">1942</TD><TD> * Finds the accurate positions of the sequence of tokens given by qualifiedName</TD></TR><TR><TD CLASS="l">1943</TD><TD> * in the source and reports a reference to this parameterized type name</TD></TR><TR><TD CLASS="l"><A NAME="3c">1944</A></TD><TD> * to the search requestor.</TD></TR><TR><TD CLASS="l">1945</TD><TD> * @since 3.1</TD></TR><TR><TD CLASS="l">1946</TD><TD> */</TD></TR><TR><TD CLASS="l">1947</TD><TD>protected void reportAccurateParameterizedTypeReference(SearchMatch match, TypeReference typeRef, int index, TypeReference[] typeArguments) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">1948</TD><TD>        if (match.getRule() == 0) return;</TD></TR><TR CLASS="z"><TD CLASS="l">1949</TD><TD>        if (!encloses((IJavaScriptElement)match.getElement())) return;</TD></TR><TR><TD CLASS="l">1950</TD><TD> </TD></TR><TR><TD CLASS="l">1951</TD><TD>        // If there's type arguments, look for end (ie. char '&gt;') of last one.</TD></TR><TR CLASS="z"><TD CLASS="l">1952</TD><TD>        int end = typeRef.sourceEnd;</TD></TR><TR CLASS="z"><TD CLASS="l">1953</TD><TD>        if (typeArguments != null) {</TD></TR><TR><TD CLASS="l">1954</TD><TD>                // Initialize scanner</TD></TR><TR CLASS="z"><TD CLASS="l">1955</TD><TD>                Scanner scanner = this.parser.scanner;</TD></TR><TR CLASS="z"><TD CLASS="l">1956</TD><TD>                char[] source = this.currentPossibleMatch.getContents();</TD></TR><TR CLASS="z"><TD CLASS="l">1957</TD><TD>                scanner.setSource(source);</TD></TR><TR><TD CLASS="l">1958</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">1959</TD><TD>                boolean shouldMatchErasure= (pattern instanceof OrPattern) ? ((OrPattern)pattern).isErasureMatch() : ((JavaSearchPattern)pattern).isErasureMatch();</TD></TR><TR CLASS="z"><TD CLASS="l">1960</TD><TD>                boolean hasSignatures = (pattern instanceof OrPattern) ? ((OrPattern)pattern).hasSignatures() : ((JavaSearchPattern)pattern).hasSignatures();</TD></TR><TR CLASS="z"><TD CLASS="l">1961</TD><TD>                if (shouldMatchErasure || !hasSignatures) {</TD></TR><TR><TD CLASS="l">1962</TD><TD>                        // if pattern is erasure only, then select the end of the reference</TD></TR><TR CLASS="z"><TD CLASS="l">1963</TD><TD>                        if (typeRef instanceof QualifiedTypeReference &amp;&amp; index &gt;= 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1964</TD><TD>                                long[] positions = ((QualifiedTypeReference) typeRef).sourcePositions;</TD></TR><TR CLASS="z"><TD CLASS="l">1965</TD><TD>                                end = (int) positions[index];</TD></TR><TR CLASS="z"><TD CLASS="l">1966</TD><TD>                        } else if (typeRef instanceof ArrayTypeReference) {</TD></TR><TR CLASS="z"><TD CLASS="l">1967</TD><TD>                                end = ((ArrayTypeReference) typeRef).originalSourceEnd;</TD></TR><TR><TD CLASS="l">1968</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1969</TD><TD>                }  else {</TD></TR><TR><TD CLASS="l">1970</TD><TD>                        // Set scanner position at end of last type argument</TD></TR><TR CLASS="z"><TD CLASS="l">1971</TD><TD>                        scanner.resetTo(end, source.length-1);</TD></TR><TR CLASS="z"><TD CLASS="l">1972</TD><TD>                        int depth = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">1973</TD><TD>                        for (int i=typeArguments.length-1; i&gt;=0; i--) {</TD></TR><TR CLASS="z"><TD CLASS="l">1974</TD><TD>                                if (typeArguments[i] != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">1975</TD><TD>                                        long lastTypeArgInfo = findLastTypeArgumentInfo(typeArguments[i]);</TD></TR><TR CLASS="z"><TD CLASS="l">1976</TD><TD>                                        depth = (int) (lastTypeArgInfo &gt;&gt;&gt; 32)+1;</TD></TR><TR CLASS="z"><TD CLASS="l">1977</TD><TD>                                        scanner.resetTo(((int)lastTypeArgInfo)+1, scanner.eofPosition-1);</TD></TR><TR CLASS="z"><TD CLASS="l">1978</TD><TD>                                        break;</TD></TR><TR><TD CLASS="l">1979</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1980</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1981</TD><TD> </TD></TR><TR><TD CLASS="l">1982</TD><TD>                        // Now, scan to search next closing '&gt;'</TD></TR><TR CLASS="z"><TD CLASS="l">1983</TD><TD>                        while (depth-- &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">1984</TD><TD>                                while (!scanner.atEnd()) {</TD></TR><TR CLASS="z"><TD CLASS="l">1985</TD><TD>                                        if (scanner.getNextChar() == '&gt;') {</TD></TR><TR CLASS="z"><TD CLASS="l">1986</TD><TD>                                                end = scanner.currentPosition - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">1987</TD><TD>                                                break;</TD></TR><TR><TD CLASS="l">1988</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">1989</TD><TD>                                }</TD></TR><TR><TD CLASS="l">1990</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1991</TD><TD>                 }</TD></TR><TR><TD CLASS="l">1992</TD><TD>        }</TD></TR><TR><TD CLASS="l">1993</TD><TD> </TD></TR><TR><TD CLASS="l">1994</TD><TD>        // Report match</TD></TR><TR CLASS="z"><TD CLASS="l">1995</TD><TD>        match.setLength(end-match.getOffset()+1);</TD></TR><TR CLASS="z"><TD CLASS="l">1996</TD><TD>        report(match);</TD></TR><TR CLASS="z"><TD CLASS="l">1997</TD><TD>}</TD></TR><TR><TD CLASS="l">1998</TD><TD>/**</TD></TR><TR><TD CLASS="l">1999</TD><TD> * Finds the accurate positions of each valid token in the source and</TD></TR><TR><TD CLASS="l">2000</TD><TD> * reports a reference to this token to the search requestor.</TD></TR><TR><TD CLASS="l"><A NAME="39">2001</A></TD><TD> * A token is valid if it has an accuracy which is not -1.</TD></TR><TR><TD CLASS="l">2002</TD><TD> */</TD></TR><TR><TD CLASS="l">2003</TD><TD>protected void reportAccurateEnumConstructorReference(SearchMatch match, FieldDeclaration field, AllocationExpression allocation) throws CoreException {</TD></TR><TR><TD CLASS="l">2004</TD><TD>        // Verify that field declaration is really an enum constant</TD></TR><TR CLASS="z"><TD CLASS="l">2005</TD><TD>        if (allocation == null || allocation.enumConstant == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2006</TD><TD>                report(match);</TD></TR><TR CLASS="z"><TD CLASS="l">2007</TD><TD>                return;</TD></TR><TR><TD CLASS="l">2008</TD><TD>        }</TD></TR><TR><TD CLASS="l">2009</TD><TD> </TD></TR><TR><TD CLASS="l">2010</TD><TD>        // Get scan area</TD></TR><TR CLASS="z"><TD CLASS="l">2011</TD><TD>        int sourceStart = match.getOffset()+match.getLength();</TD></TR><TR CLASS="z"><TD CLASS="l">2012</TD><TD>        if (allocation.arguments != null &amp;&amp; allocation.arguments.length &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2013</TD><TD>                sourceStart = allocation.arguments[allocation.arguments.length-1].sourceEnd+1;</TD></TR><TR><TD CLASS="l">2014</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2015</TD><TD>        int sourceEnd = field.declarationSourceEnd;</TD></TR><TR CLASS="z"><TD CLASS="l">2016</TD><TD>        if (allocation instanceof QualifiedAllocationExpression) {</TD></TR><TR CLASS="z"><TD CLASS="l">2017</TD><TD>                QualifiedAllocationExpression qualifiedAllocation = (QualifiedAllocationExpression) allocation;</TD></TR><TR CLASS="z"><TD CLASS="l">2018</TD><TD>                if (qualifiedAllocation.anonymousType != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2019</TD><TD>                        sourceEnd = qualifiedAllocation.anonymousType.sourceStart - 1;</TD></TR><TR><TD CLASS="l">2020</TD><TD>                }</TD></TR><TR><TD CLASS="l">2021</TD><TD>        }</TD></TR><TR><TD CLASS="l">2022</TD><TD> </TD></TR><TR><TD CLASS="l">2023</TD><TD>        // Scan to find last closing parenthesis</TD></TR><TR CLASS="z"><TD CLASS="l">2024</TD><TD>        Scanner scanner = this.parser.scanner;</TD></TR><TR CLASS="z"><TD CLASS="l">2025</TD><TD>        scanner.setSource(this.currentPossibleMatch.getContents());</TD></TR><TR CLASS="z"><TD CLASS="l">2026</TD><TD>        scanner.resetTo(sourceStart, sourceEnd);</TD></TR><TR><TD CLASS="l">2027</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">2028</TD><TD>                int token = scanner.getNextToken();</TD></TR><TR CLASS="z"><TD CLASS="l">2029</TD><TD>                while (token != TerminalTokens.TokenNameEOF) {</TD></TR><TR CLASS="z"><TD CLASS="l">2030</TD><TD>                        if (token == TerminalTokens.TokenNameRPAREN) {</TD></TR><TR CLASS="z"><TD CLASS="l">2031</TD><TD>                                sourceEnd = scanner.getCurrentTokenEndPosition();</TD></TR><TR><TD CLASS="l">2032</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2033</TD><TD>                        token = scanner.getNextToken();</TD></TR><TR><TD CLASS="l">2034</TD><TD>                }</TD></TR><TR><TD CLASS="l">2035</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2036</TD><TD>        catch (InvalidInputException iie) {</TD></TR><TR><TD CLASS="l">2037</TD><TD>                // give up</TD></TR><TR><TD CLASS="l">2038</TD><TD>        }</TD></TR><TR><TD CLASS="l">2039</TD><TD> </TD></TR><TR><TD CLASS="l">2040</TD><TD>        // Report match</TD></TR><TR CLASS="z"><TD CLASS="l">2041</TD><TD>        match.setLength(sourceEnd-match.getOffset()+1);</TD></TR><TR CLASS="z"><TD CLASS="l">2042</TD><TD>        report(match);</TD></TR><TR CLASS="z"><TD CLASS="l">2043</TD><TD>}</TD></TR><TR><TD CLASS="l">2044</TD><TD>/**</TD></TR><TR><TD CLASS="l">2045</TD><TD> * Finds the accurate positions of each valid token in the source and</TD></TR><TR><TD CLASS="l"><A NAME="3a">2046</A></TD><TD> * reports a reference to this token to the search requestor.</TD></TR><TR><TD CLASS="l">2047</TD><TD> * A token is valid if it has an accuracy which is not -1.</TD></TR><TR><TD CLASS="l">2048</TD><TD> */</TD></TR><TR><TD CLASS="l">2049</TD><TD>protected void reportAccurateFieldReference(SearchMatch[] matches, QualifiedNameReference qNameRef) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">2050</TD><TD>        if (matches == null) return; // there's nothing to accurate in this case</TD></TR><TR CLASS="z"><TD CLASS="l">2051</TD><TD>        int matchesLength = matches.length;</TD></TR><TR><TD CLASS="l">2052</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2053</TD><TD>        int sourceStart = qNameRef.sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">2054</TD><TD>        int sourceEnd = qNameRef.sourceEnd;</TD></TR><TR CLASS="z"><TD CLASS="l">2055</TD><TD>        char[][] tokens = qNameRef.tokens;</TD></TR><TR><TD CLASS="l">2056</TD><TD> </TD></TR><TR><TD CLASS="l">2057</TD><TD>        // compute source positions of the qualified reference</TD></TR><TR CLASS="z"><TD CLASS="l">2058</TD><TD>        Scanner scanner = this.parser.scanner;</TD></TR><TR CLASS="z"><TD CLASS="l">2059</TD><TD>        scanner.setSource(this.currentPossibleMatch.getContents());</TD></TR><TR CLASS="z"><TD CLASS="l">2060</TD><TD>        scanner.resetTo(sourceStart, sourceEnd);</TD></TR><TR CLASS="z"><TD CLASS="l">2061</TD><TD>        int sourceLength = sourceEnd-sourceStart+1;</TD></TR><TR><TD CLASS="l">2062</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2063</TD><TD>        int refSourceStart = -1, refSourceEnd = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2064</TD><TD>        int length = tokens.length;</TD></TR><TR CLASS="z"><TD CLASS="l">2065</TD><TD>        int token = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2066</TD><TD>        int previousValid = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2067</TD><TD>        int i = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">2068</TD><TD>        int index = 0;</TD></TR><TR><TD CLASS="l">2069</TD><TD>        do {</TD></TR><TR CLASS="z"><TD CLASS="l">2070</TD><TD>                int currentPosition = scanner.currentPosition;</TD></TR><TR><TD CLASS="l">2071</TD><TD>                // read token</TD></TR><TR><TD CLASS="l">2072</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">2073</TD><TD>                        token = scanner.getNextToken();</TD></TR><TR CLASS="z"><TD CLASS="l">2074</TD><TD>                } catch (InvalidInputException e) {</TD></TR><TR><TD CLASS="l">2075</TD><TD>                        //ignore</TD></TR><TR><TD CLASS="l">2076</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2077</TD><TD>                if (token != TerminalTokens.TokenNameEOF) {</TD></TR><TR CLASS="z"><TD CLASS="l">2078</TD><TD>                        char[] currentTokenSource = scanner.getCurrentTokenSource();</TD></TR><TR CLASS="z"><TD CLASS="l">2079</TD><TD>                        boolean equals = false;</TD></TR><TR CLASS="z"><TD CLASS="l">2080</TD><TD>                        while (i &lt; length &amp;&amp; !(equals = this.pattern.matchesName(tokens[i++], currentTokenSource))){/*empty*/}</TD></TR><TR CLASS="z"><TD CLASS="l">2081</TD><TD>                        if (equals &amp;&amp; (previousValid == -1 || previousValid == i - 2)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2082</TD><TD>                                previousValid = i - 1;</TD></TR><TR CLASS="z"><TD CLASS="l">2083</TD><TD>                                if (refSourceStart == -1)</TD></TR><TR CLASS="z"><TD CLASS="l">2084</TD><TD>                                        refSourceStart = currentPosition;</TD></TR><TR CLASS="z"><TD CLASS="l">2085</TD><TD>                                refSourceEnd = scanner.currentPosition - 1;</TD></TR><TR><TD CLASS="l">2086</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2087</TD><TD>                                i = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">2088</TD><TD>                                refSourceStart = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2089</TD><TD>                                previousValid = -1;</TD></TR><TR><TD CLASS="l">2090</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2091</TD><TD>                        // read '.'</TD></TR><TR><TD CLASS="l">2092</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">2093</TD><TD>                                token = scanner.getNextToken();</TD></TR><TR CLASS="z"><TD CLASS="l">2094</TD><TD>                        } catch (InvalidInputException e) {</TD></TR><TR><TD CLASS="l">2095</TD><TD>                                // ignore</TD></TR><TR><TD CLASS="l">2096</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2097</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2098</TD><TD>                SearchMatch match = matches[index];</TD></TR><TR CLASS="z"><TD CLASS="l">2099</TD><TD>                if (match != null &amp;&amp; match.getRule() != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2100</TD><TD>                        if (!encloses((IJavaScriptElement)match.getElement())) return;</TD></TR><TR><TD CLASS="l">2101</TD><TD>                        // accept reference</TD></TR><TR CLASS="z"><TD CLASS="l">2102</TD><TD>                        if (refSourceStart != -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">2103</TD><TD>                                match.setOffset(refSourceStart);</TD></TR><TR CLASS="z"><TD CLASS="l">2104</TD><TD>                                match.setLength(refSourceEnd-refSourceStart+1);</TD></TR><TR CLASS="z"><TD CLASS="l">2105</TD><TD>                                report(match);</TD></TR><TR><TD CLASS="l">2106</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2107</TD><TD>                                match.setOffset(sourceStart);</TD></TR><TR CLASS="z"><TD CLASS="l">2108</TD><TD>                                match.setLength(sourceLength);</TD></TR><TR CLASS="z"><TD CLASS="l">2109</TD><TD>                                report(match);</TD></TR><TR><TD CLASS="l">2110</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2111</TD><TD>                        i = 0;</TD></TR><TR><TD CLASS="l">2112</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2113</TD><TD>                refSourceStart = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2114</TD><TD>                previousValid = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2115</TD><TD>                if (index &lt; matchesLength - 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">2116</TD><TD>                        index++;</TD></TR><TR><TD CLASS="l">2117</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3e">2118</A></TD><TD>        } while (token != TerminalTokens.TokenNameEOF);</TD></TR><TR><TD CLASS="l">2119</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2120</TD><TD>}</TD></TR><TR><TD CLASS="l">2121</TD><TD>protected void reportBinaryMemberDeclaration(IResource resource, IMember binaryMember, Binding binaryMemberBinding, IBinaryType info, int accuracy) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">2122</TD><TD>        ClassFile classFile = (ClassFile) binaryMember.getClassFile();</TD></TR><TR CLASS="z"><TD CLASS="l">2123</TD><TD>        ISourceRange range = classFile.isOpen() ? binaryMember.getNameRange() : SourceMapper.UNKNOWN_RANGE;</TD></TR><TR CLASS="z"><TD CLASS="l">2124</TD><TD>        if (range.getOffset() == -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">2125</TD><TD>                BinaryType type = (BinaryType) classFile.getType();</TD></TR><TR CLASS="z"><TD CLASS="l">2126</TD><TD>                String sourceFileName = type.sourceFileName(info);</TD></TR><TR CLASS="z"><TD CLASS="l">2127</TD><TD>                if (sourceFileName != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2128</TD><TD>                        SourceMapper mapper = classFile.getSourceMapper();</TD></TR><TR CLASS="z"><TD CLASS="l">2129</TD><TD>                        if (mapper != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2130</TD><TD>                                char[] contents = mapper.findSource(type, sourceFileName);</TD></TR><TR CLASS="z"><TD CLASS="l">2131</TD><TD>                                if (contents != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2132</TD><TD>                                        range = mapper.mapSource(type, contents, info, binaryMember);</TD></TR><TR><TD CLASS="l">2133</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2134</TD><TD>                }</TD></TR><TR><TD CLASS="l">2135</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2136</TD><TD>        if (resource == null) resource =  this.currentPossibleMatch.resource;</TD></TR><TR CLASS="z"><TD CLASS="l">2137</TD><TD>        SearchMatch match = newDeclarationMatch(binaryMember, binaryMemberBinding, accuracy, range.getOffset(), range.getLength(), getParticipant(), resource);</TD></TR><TR CLASS="z"><TD CLASS="l">2138</TD><TD>        report(match);</TD></TR><TR CLASS="z"><TD CLASS="l">2139</TD><TD>}</TD></TR><TR><TD CLASS="l">2140</TD><TD>/**</TD></TR><TR><TD CLASS="l">2141</TD><TD> * Visit the given method declaration and report the nodes that match exactly the</TD></TR><TR><TD CLASS="l"><A NAME="45">2142</A></TD><TD> * search pattern (ie. the ones in the matching nodes set)</TD></TR><TR><TD CLASS="l">2143</TD><TD> * Note that the method declaration has already been checked.</TD></TR><TR><TD CLASS="l">2144</TD><TD> */</TD></TR><TR><TD CLASS="l">2145</TD><TD>protected void reportMatching(TypeDeclaration type, AbstractMethodDeclaration method, IJavaScriptElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">2146</TD><TD>        IJavaScriptElement enclosingElement = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2147</TD><TD>        if (accuracy &gt; -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">2148</TD><TD>                enclosingElement = createHandle(method, parent);</TD></TR><TR CLASS="z"><TD CLASS="l">2149</TD><TD>                if (enclosingElement != null) { // skip if unable to find method</TD></TR><TR><TD CLASS="l">2150</TD><TD>                        // compute source positions of the selector</TD></TR><TR CLASS="z"><TD CLASS="l">2151</TD><TD>                        Scanner scanner = parser.scanner;</TD></TR><TR CLASS="z"><TD CLASS="l">2152</TD><TD>                        int nameSourceStart = method.sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">2153</TD><TD>                        scanner.setSource(this.currentPossibleMatch.getContents());</TD></TR><TR CLASS="z"><TD CLASS="l">2154</TD><TD>                        scanner.resetTo(nameSourceStart, method.sourceEnd);</TD></TR><TR><TD CLASS="l">2155</TD><TD>                        try {</TD></TR><TR CLASS="z"><TD CLASS="l">2156</TD><TD>                                scanner.getNextToken();</TD></TR><TR CLASS="z"><TD CLASS="l">2157</TD><TD>                        } catch (InvalidInputException e) {</TD></TR><TR><TD CLASS="l">2158</TD><TD>                                // ignore</TD></TR><TR><TD CLASS="l">2159</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2160</TD><TD>                        if (encloses(enclosingElement)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2161</TD><TD>                                SearchMatch match = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2162</TD><TD>                                if (method.isDefaultConstructor()) {</TD></TR><TR><TD CLASS="l">2163</TD><TD>                                        // Use type for match associated element as default constructor does not exist in source</TD></TR><TR CLASS="z"><TD CLASS="l">2164</TD><TD>                                        int offset = type.sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">2165</TD><TD>                                        match = this.patternLocator.newDeclarationMatch(type, parent, type.binding, accuracy, type.sourceEnd-offset+1, this);</TD></TR><TR><TD CLASS="l">2166</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2167</TD><TD>                                        int length = scanner.currentPosition - nameSourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">2168</TD><TD>                                        match = this.patternLocator.newDeclarationMatch(method, enclosingElement, method.binding, accuracy, length, this);</TD></TR><TR><TD CLASS="l">2169</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2170</TD><TD>                                if (match != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2171</TD><TD>                                        report(match);</TD></TR><TR><TD CLASS="l">2172</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2173</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2174</TD><TD>                }</TD></TR><TR><TD CLASS="l">2175</TD><TD>        }</TD></TR><TR><TD CLASS="l">2176</TD><TD> </TD></TR><TR><TD CLASS="l">2177</TD><TD>        // handle nodes for the local type first</TD></TR><TR CLASS="z"><TD CLASS="l">2178</TD><TD>        if ((method.bits &amp; ASTNode.HasLocalType) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2179</TD><TD>                if (enclosingElement == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2180</TD><TD>                        enclosingElement = createHandle(method, parent);</TD></TR><TR CLASS="z"><TD CLASS="l">2181</TD><TD>                LocalDeclarationVisitor localDeclarationVisitor = new LocalDeclarationVisitor(enclosingElement, method.binding, nodeSet);</TD></TR><TR><TD CLASS="l">2182</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">2183</TD><TD>                        method.traverse(localDeclarationVisitor, (ClassScope) null);</TD></TR><TR CLASS="z"><TD CLASS="l">2184</TD><TD>                } catch (WrappedCoreException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2185</TD><TD>                        throw e.coreException;</TD></TR><TR><TD CLASS="l">2186</TD><TD>                }</TD></TR><TR><TD CLASS="l">2187</TD><TD>        }</TD></TR><TR><TD CLASS="l">2188</TD><TD> </TD></TR><TR><TD CLASS="l">2189</TD><TD>        // report the type parameters</TD></TR><TR CLASS="z"><TD CLASS="l">2190</TD><TD>        TypeParameter[] typeParameters = method.typeParameters();</TD></TR><TR CLASS="z"><TD CLASS="l">2191</TD><TD>        if (typeParameters != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2192</TD><TD>                if (enclosingElement == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2193</TD><TD>                        enclosingElement = createHandle(method, parent);</TD></TR><TR><TD CLASS="l">2194</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2195</TD><TD>                reportMatching(typeParameters, enclosingElement, parent, method.binding, nodeSet);</TD></TR><TR><TD CLASS="l">2196</TD><TD>        }</TD></TR><TR><TD CLASS="l">2197</TD><TD> </TD></TR><TR><TD CLASS="l">2198</TD><TD>        // references in this method</TD></TR><TR CLASS="z"><TD CLASS="l">2199</TD><TD>        if (typeInHierarchy) {</TD></TR><TR CLASS="z"><TD CLASS="l">2200</TD><TD>                ASTNode[] nodes = nodeSet.matchingNodes(method.declarationSourceStart, method.declarationSourceEnd);</TD></TR><TR CLASS="z"><TD CLASS="l">2201</TD><TD>                if (nodes != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2202</TD><TD>                        if ((this.matchContainer &amp; PatternLocator.METHOD_CONTAINER) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2203</TD><TD>                                if (enclosingElement == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2204</TD><TD>                                        enclosingElement = createHandle(method, parent);</TD></TR><TR CLASS="z"><TD CLASS="l">2205</TD><TD>                                if (encloses(enclosingElement)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2206</TD><TD>                                        for (int i = 0, l = nodes.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2207</TD><TD>                                                ASTNode node = nodes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2208</TD><TD>                                                Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);</TD></TR><TR CLASS="z"><TD CLASS="l">2209</TD><TD>                                                this.patternLocator.matchReportReference(node, enclosingElement, method.binding, method.scope, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2210</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2211</TD><TD>                                        return;</TD></TR><TR><TD CLASS="l">2212</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2213</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2214</TD><TD>                        for (int i = 0, l = nodes.length; i &lt; l; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">2215</TD><TD>                                nodeSet.matchingNodes.removeKey(nodes[i]);</TD></TR><TR><TD CLASS="l">2216</TD><TD>                }</TD></TR><TR><TD CLASS="l">2217</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2218</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="3f">2219</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">2220</TD><TD> * Visit the given resolved parse tree and report the nodes that match the search pattern.</TD></TR><TR><TD CLASS="l">2221</TD><TD> */</TD></TR><TR><TD CLASS="l">2222</TD><TD>protected void reportMatching(CompilationUnitDeclaration unit, boolean mustResolve) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">2223</TD><TD>        MatchingNodeSet nodeSet = this.currentPossibleMatch.nodeSet;</TD></TR><TR CLASS="z"><TD CLASS="l">2224</TD><TD>        boolean locatorMustResolve = this.patternLocator.mustResolve;</TD></TR><TR CLASS="z"><TD CLASS="l">2225</TD><TD>        if (nodeSet.mustResolve) this.patternLocator.mustResolve = true;</TD></TR><TR CLASS="z"><TD CLASS="l">2226</TD><TD>        if (BasicSearchEngine.VERBOSE) {</TD></TR><TR CLASS="z"><TD CLASS="l">2227</TD><TD>                System.out.println(&#34;Report matching: &#34;); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">2228</TD><TD>                int size = nodeSet.matchingNodes==null ? 0 : nodeSet.matchingNodes.elementSize;</TD></TR><TR CLASS="z"><TD CLASS="l">2229</TD><TD>                System.out.print(&#34;        - node set: accurate=&#34;+ size); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">2230</TD><TD>                size = nodeSet.possibleMatchingNodesSet==null ? 0 : nodeSet.possibleMatchingNodesSet.elementSize;</TD></TR><TR CLASS="z"><TD CLASS="l">2231</TD><TD>                System.out.println(&#34;, possible=&#34;+size); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">2232</TD><TD>                System.out.print(&#34;        - must resolve: &#34;+mustResolve); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">2233</TD><TD>                System.out.print(&#34; (locator: &#34;+this.patternLocator.mustResolve); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">2234</TD><TD>                System.out.println(&#34;, nodeSet: &#34;+nodeSet.mustResolve+')'); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">2235</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2236</TD><TD>        if (mustResolve) {</TD></TR><TR CLASS="z"><TD CLASS="l">2237</TD><TD>                this.unitScope= unit.scope.compilationUnitScope();</TD></TR><TR><TD CLASS="l">2238</TD><TD>                // move the possible matching nodes that exactly match the search pattern to the matching nodes set</TD></TR><TR CLASS="z"><TD CLASS="l">2239</TD><TD>                Object[] nodes = nodeSet.possibleMatchingNodesSet.values;</TD></TR><TR CLASS="z"><TD CLASS="l">2240</TD><TD>                for (int i = 0, l = nodes.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2241</TD><TD>                        ASTNode node = (ASTNode) nodes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2242</TD><TD>                        if (node == null) continue;</TD></TR><TR CLASS="z"><TD CLASS="l">2243</TD><TD>                        if (node instanceof ImportReference) {</TD></TR><TR><TD CLASS="l">2244</TD><TD>                                // special case for import refs: they don't know their binding</TD></TR><TR><TD CLASS="l">2245</TD><TD>                                // import ref cannot be in the hierarchy of a type</TD></TR><TR CLASS="z"><TD CLASS="l">2246</TD><TD>                                if (this.hierarchyResolver != null) continue;</TD></TR><TR><TD CLASS="l">2247</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2248</TD><TD>                                ImportReference importRef = (ImportReference) node;</TD></TR><TR CLASS="z"><TD CLASS="l">2249</TD><TD>                                Binding binding = (importRef.bits &amp; ASTNode.OnDemand) != 0</TD></TR><TR CLASS="z"><TD CLASS="l">2250</TD><TD>                                        ? unitScope.getImport(CharOperation.subarray(importRef.tokens, 0, importRef.tokens.length), true)</TD></TR><TR CLASS="z"><TD CLASS="l">2251</TD><TD>                                        : unitScope.getImport(importRef.tokens, false);</TD></TR><TR CLASS="z"><TD CLASS="l">2252</TD><TD>                                this.patternLocator.matchLevelAndReportImportRef(importRef, binding, this);</TD></TR><TR><TD CLASS="l">2253</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2254</TD><TD>                        nodeSet.addMatch(node, this.patternLocator.resolveLevel(node));</TD></TR><TR><TD CLASS="l">2255</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2256</TD><TD>                nodeSet.possibleMatchingNodesSet = new SimpleSet(3);</TD></TR><TR CLASS="z"><TD CLASS="l">2257</TD><TD>                if (BasicSearchEngine.VERBOSE) {</TD></TR><TR CLASS="z"><TD CLASS="l">2258</TD><TD>                        int size = nodeSet.matchingNodes==null ? 0 : nodeSet.matchingNodes.elementSize;</TD></TR><TR CLASS="z"><TD CLASS="l">2259</TD><TD>                        System.out.print(&#34;        - node set: accurate=&#34;+size); //$NON-NLS-1$</TD></TR><TR CLASS="z"><TD CLASS="l">2260</TD><TD>                        size = nodeSet.possibleMatchingNodesSet==null ? 0 : nodeSet.possibleMatchingNodesSet.elementSize;</TD></TR><TR CLASS="z"><TD CLASS="l">2261</TD><TD>                        System.out.println(&#34;, possible=&#34;+size); //$NON-NLS-1$</TD></TR><TR><TD CLASS="l">2262</TD><TD>                }</TD></TR><TR><TD CLASS="l">2263</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2264</TD><TD>                this.unitScope = null;</TD></TR><TR><TD CLASS="l">2265</TD><TD>        }</TD></TR><TR><TD CLASS="l">2266</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2267</TD><TD>        if (nodeSet.matchingNodes.elementSize == 0) return; // no matching nodes were found</TD></TR><TR CLASS="z"><TD CLASS="l">2268</TD><TD>        this.methodHandles = new HashSet();</TD></TR><TR><TD CLASS="l">2269</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2270</TD><TD>        boolean matchedUnitContainer = (this.matchContainer &amp; PatternLocator.COMPILATION_UNIT_CONTAINER) != 0;</TD></TR><TR><TD CLASS="l">2271</TD><TD> </TD></TR><TR><TD CLASS="l">2272</TD><TD>        // report references in javadoc</TD></TR><TR CLASS="z"><TD CLASS="l">2273</TD><TD>        if (unit.javadoc != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2274</TD><TD>                ASTNode[] nodes = nodeSet.matchingNodes(unit.javadoc.sourceStart, unit.javadoc.sourceEnd);</TD></TR><TR CLASS="z"><TD CLASS="l">2275</TD><TD>                if (nodes != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2276</TD><TD>                        if (!matchedUnitContainer) {</TD></TR><TR CLASS="z"><TD CLASS="l">2277</TD><TD>                                for (int i = 0, l = nodes.length; i &lt; l; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">2278</TD><TD>                                        nodeSet.matchingNodes.removeKey(nodes[i]);</TD></TR><TR><TD CLASS="l">2279</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2280</TD><TD>                                IJavaScriptElement element = createPackageDeclarationHandle(unit);</TD></TR><TR CLASS="z"><TD CLASS="l">2281</TD><TD>                                for (int i = 0, l = nodes.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2282</TD><TD>                                        ASTNode node = nodes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2283</TD><TD>                                        Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);</TD></TR><TR CLASS="z"><TD CLASS="l">2284</TD><TD>                                        if (encloses(element))</TD></TR><TR CLASS="z"><TD CLASS="l">2285</TD><TD>                                                this.patternLocator.matchReportReference(node, element, null/*no binding*/, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2286</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2287</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2288</TD><TD>                }</TD></TR><TR><TD CLASS="l">2289</TD><TD>        }</TD></TR><TR><TD CLASS="l">2290</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2291</TD><TD>        if (matchedUnitContainer) {</TD></TR><TR CLASS="z"><TD CLASS="l">2292</TD><TD>                ImportReference[] imports = unit.imports;</TD></TR><TR CLASS="z"><TD CLASS="l">2293</TD><TD>                if (imports != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2294</TD><TD>                        for (int i = 0, l = imports.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2295</TD><TD>                                ImportReference importRef = imports[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2296</TD><TD>                                Integer level = (Integer) nodeSet.matchingNodes.removeKey(importRef);</TD></TR><TR CLASS="z"><TD CLASS="l">2297</TD><TD>                                if (level != null)</TD></TR><TR CLASS="z"><TD CLASS="l">2298</TD><TD>                                        this.patternLocator.matchReportImportRef(importRef, null/*no binding*/, createImportHandle(importRef), level.intValue(), this);</TD></TR><TR><TD CLASS="l">2299</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2300</TD><TD>                }</TD></TR><TR><TD CLASS="l">2301</TD><TD>        }</TD></TR><TR><TD CLASS="l">2302</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2303</TD><TD>        TypeDeclaration[] types = unit.types;</TD></TR><TR CLASS="z"><TD CLASS="l">2304</TD><TD>        if (types != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2305</TD><TD>                for (int i = 0, l = types.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2306</TD><TD>                        if (nodeSet.matchingNodes.elementSize == 0) return; // reported all the matching nodes</TD></TR><TR CLASS="z"><TD CLASS="l">2307</TD><TD>                        TypeDeclaration type = types[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2308</TD><TD>                        Integer level = (Integer) nodeSet.matchingNodes.removeKey(type);</TD></TR><TR CLASS="z"><TD CLASS="l">2309</TD><TD>                        int accuracy = (level != null &amp;&amp; matchedUnitContainer) ? level.intValue() : -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2310</TD><TD>                        reportMatching(type, null, accuracy, nodeSet, 1);</TD></TR><TR><TD CLASS="l">2311</TD><TD>                }</TD></TR><TR><TD CLASS="l">2312</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2313</TD><TD>        ProgramElement[] statements = unit.statements;</TD></TR><TR><TD CLASS="l">2314</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2315</TD><TD>        if (statements!=null)</TD></TR><TR><TD CLASS="l">2316</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2317</TD><TD>                IJavaScriptElement enclosingElement = this.currentPossibleMatch.openable;</TD></TR><TR CLASS="z"><TD CLASS="l">2318</TD><TD>                if (enclosingElement == null) return;</TD></TR><TR><TD CLASS="l">2319</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2320</TD><TD>                boolean typeInHierarchy = true;</TD></TR><TR CLASS="z"><TD CLASS="l">2321</TD><TD>                boolean matchedClassContainer=true;</TD></TR><TR CLASS="z"><TD CLASS="l">2322</TD><TD>                ReportMatchingVisitor reportMatchingVisitor = new ReportMatchingVisitor(nodeSet,matchedClassContainer,enclosingElement,typeInHierarchy);</TD></TR><TR CLASS="z"><TD CLASS="l">2323</TD><TD>                unit.traverse(reportMatchingVisitor, unit.scope);</TD></TR><TR><TD CLASS="l">2324</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2325</TD><TD>                for (int i = 0; i &lt; statements.length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2326</TD><TD>                        if (nodeSet.matchingNodes.elementSize == 0) return; // reported all the matching nodes</TD></TR><TR CLASS="z"><TD CLASS="l">2327</TD><TD>                        if (statements[i] instanceof AbstractMethodDeclaration) {//already handled</TD></TR><TR CLASS="z"><TD CLASS="l">2328</TD><TD>                        } else if (statements[i] instanceof LocalDeclaration) {//already handled</TD></TR><TR><TD CLASS="l">2329</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2330</TD><TD>                        else</TD></TR><TR><TD CLASS="l">2331</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">2332</TD><TD>                                ASTNode[] nodes = nodeSet.matchingNodes(statements[i].sourceStart, statements[i].sourceEnd);</TD></TR><TR CLASS="z"><TD CLASS="l">2333</TD><TD>                                if (nodes != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2334</TD><TD>                                        if ((this.matchContainer &amp; PatternLocator.COMPILATION_UNIT_CONTAINER) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2335</TD><TD>                                                if (encloses(enclosingElement)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2336</TD><TD>                                                        for (int j = 0, l = nodes.length; j &lt; l; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2337</TD><TD>                                                                ASTNode node = nodes[j];</TD></TR><TR CLASS="z"><TD CLASS="l">2338</TD><TD>                                                                Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);</TD></TR><TR CLASS="z"><TD CLASS="l">2339</TD><TD>                                                                int accuracy = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2340</TD><TD>                                                                this.patternLocator.matchReportReference(node, enclosingElement, unit.compilationUnitBinding, unit.scope, accuracy, this);</TD></TR><TR><TD CLASS="l">2341</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2342</TD><TD>//                                                        return;</TD></TR><TR><TD CLASS="l">2343</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2344</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2345</TD><TD>                                        for (int j = 0, l = nodes.length; j &lt; l; j++)</TD></TR><TR CLASS="z"><TD CLASS="l">2346</TD><TD>                                                nodeSet.matchingNodes.removeKey(nodes[j]);</TD></TR><TR><TD CLASS="l">2347</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2348</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2349</TD><TD> </TD></TR><TR><TD CLASS="l">2350</TD><TD>                }</TD></TR><TR><TD CLASS="l">2351</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2352</TD><TD>        for (int i=0;i&lt;unit.numberInferredTypes;i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2353</TD><TD>                InferredType inferredType = unit.inferredTypes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2354</TD><TD>                        IJavaScriptElement enclosingElement = this.currentPossibleMatch.openable;</TD></TR><TR CLASS="z"><TD CLASS="l">2355</TD><TD>                        if (enclosingElement == null) return;</TD></TR><TR CLASS="z"><TD CLASS="l">2356</TD><TD>                        boolean typeInHierarchy = true;</TD></TR><TR CLASS="z"><TD CLASS="l">2357</TD><TD>                        boolean matchedClassContainer=true;</TD></TR><TR CLASS="z"><TD CLASS="l">2358</TD><TD>                        enclosingElement=((ITypeRoot)enclosingElement).getType(new String(inferredType.getName()));</TD></TR><TR><TD CLASS="l">2359</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2360</TD><TD>                        Integer level = (Integer) nodeSet.matchingNodes.removeKey(inferredType);</TD></TR><TR CLASS="z"><TD CLASS="l">2361</TD><TD>                        int accuracy = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2362</TD><TD>                        reportMatching(inferredType, null, accuracy, nodeSet, 1);</TD></TR><TR><TD CLASS="l">2363</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2364</TD><TD>                          for (int attributeInx=0; attributeInx&lt;inferredType.numberAttributes; attributeInx++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2365</TD><TD>                                        InferredAttribute attribute = inferredType.attributes[attributeInx];</TD></TR><TR CLASS="z"><TD CLASS="l">2366</TD><TD>                                         level = (Integer) nodeSet.matchingNodes.removeKey(attribute);</TD></TR><TR CLASS="z"><TD CLASS="l">2367</TD><TD>                                         accuracy = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2368</TD><TD>                                                reportMatching(attribute, inferredType, enclosingElement, accuracy, typeInHierarchy, nodeSet);</TD></TR><TR><TD CLASS="l">2369</TD><TD> </TD></TR><TR><TD CLASS="l">2370</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2371</TD><TD>                        ArrayList methods = inferredType.methods;</TD></TR><TR CLASS="z"><TD CLASS="l">2372</TD><TD>                        if (methods!=null)</TD></TR><TR CLASS="z"><TD CLASS="l">2373</TD><TD>                                for (Iterator iterator = methods.iterator(); iterator.hasNext();) {</TD></TR><TR CLASS="z"><TD CLASS="l">2374</TD><TD>                                        InferredMethod method = (InferredMethod) iterator.next();</TD></TR><TR CLASS="z"><TD CLASS="l">2375</TD><TD>                                         level = (Integer) nodeSet.matchingNodes.removeKey(method);</TD></TR><TR CLASS="z"><TD CLASS="l">2376</TD><TD>                                         accuracy = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2377</TD><TD>                                        int value = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2378</TD><TD>                                        reportMatching(null, (AbstractMethodDeclaration) method.getFunctionDeclaration(), enclosingElement, value, typeInHierarchy, nodeSet);</TD></TR><TR><TD CLASS="l">2379</TD><TD> </TD></TR><TR><TD CLASS="l">2380</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2381</TD><TD>                }</TD></TR><TR><TD CLASS="l">2382</TD><TD> </TD></TR><TR><TD CLASS="l">2383</TD><TD> </TD></TR><TR><TD CLASS="l">2384</TD><TD>        // Clear handle cache</TD></TR><TR CLASS="z"><TD CLASS="l">2385</TD><TD>        this.methodHandles = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2386</TD><TD>        this.bindings.removeKey(this.pattern);</TD></TR><TR CLASS="z"><TD CLASS="l">2387</TD><TD>        this.patternLocator.mustResolve = locatorMustResolve;</TD></TR><TR CLASS="z"><TD CLASS="l">2388</TD><TD>}</TD></TR><TR><TD CLASS="l">2389</TD><TD>/**</TD></TR><TR><TD CLASS="l"><A NAME="40">2390</A></TD><TD> * Visit the given field declaration and report the nodes that match exactly the</TD></TR><TR><TD CLASS="l">2391</TD><TD> * search pattern (ie. the ones in the matching nodes set)</TD></TR><TR><TD CLASS="l">2392</TD><TD> */</TD></TR><TR><TD CLASS="l">2393</TD><TD>protected void reportMatching(FieldDeclaration field, FieldDeclaration[] otherFields, TypeDeclaration type, IJavaScriptElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">2394</TD><TD>        IJavaScriptElement enclosingElement = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2395</TD><TD>        if (accuracy &gt; -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">2396</TD><TD>                enclosingElement = createHandle(field, type, parent);</TD></TR><TR CLASS="z"><TD CLASS="l">2397</TD><TD>                if (encloses(enclosingElement)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2398</TD><TD>                        int offset = field.sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">2399</TD><TD>                        SearchMatch match = newDeclarationMatch(enclosingElement, field.binding, accuracy, offset, field.sourceEnd-offset+1);</TD></TR><TR CLASS="z"><TD CLASS="l">2400</TD><TD>                        if (field.initialization instanceof AllocationExpression) {</TD></TR><TR CLASS="z"><TD CLASS="l">2401</TD><TD>                                reportAccurateEnumConstructorReference(match, field, (AllocationExpression) field.initialization);</TD></TR><TR><TD CLASS="l">2402</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2403</TD><TD>                                report(match);</TD></TR><TR><TD CLASS="l">2404</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2405</TD><TD>                }</TD></TR><TR><TD CLASS="l">2406</TD><TD>        }</TD></TR><TR><TD CLASS="l">2407</TD><TD> </TD></TR><TR><TD CLASS="l">2408</TD><TD>        // handle the nodes for the local type first</TD></TR><TR CLASS="z"><TD CLASS="l">2409</TD><TD>        if ((field.bits &amp; ASTNode.HasLocalType) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2410</TD><TD>                if (enclosingElement == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2411</TD><TD>                        enclosingElement = createHandle(field, type, parent);</TD></TR><TR CLASS="z"><TD CLASS="l">2412</TD><TD>                LocalDeclarationVisitor localDeclarationVisitor = new LocalDeclarationVisitor(enclosingElement, field.binding, nodeSet);</TD></TR><TR><TD CLASS="l">2413</TD><TD>                try {</TD></TR><TR CLASS="z"><TD CLASS="l">2414</TD><TD>                        field.traverse(localDeclarationVisitor, null);</TD></TR><TR CLASS="z"><TD CLASS="l">2415</TD><TD>                } catch (WrappedCoreException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">2416</TD><TD>                        throw e.coreException;</TD></TR><TR><TD CLASS="l">2417</TD><TD>                }</TD></TR><TR><TD CLASS="l">2418</TD><TD>        }</TD></TR><TR><TD CLASS="l">2419</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2420</TD><TD>        if (typeInHierarchy) {</TD></TR><TR><TD CLASS="l">2421</TD><TD>                // Look at field declaration</TD></TR><TR CLASS="z"><TD CLASS="l">2422</TD><TD>                if (field.endPart1Position != 0) { // not necessary if field is an initializer</TD></TR><TR CLASS="z"><TD CLASS="l">2423</TD><TD>                        ASTNode[] nodes = nodeSet.matchingNodes(field.declarationSourceStart, field.endPart1Position);</TD></TR><TR CLASS="z"><TD CLASS="l">2424</TD><TD>                        if (nodes != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2425</TD><TD>                                if ((this.matchContainer &amp; PatternLocator.FIELD_CONTAINER) == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2426</TD><TD>                                        for (int i = 0, l = nodes.length; i &lt; l; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">2427</TD><TD>                                                nodeSet.matchingNodes.removeKey(nodes[i]);</TD></TR><TR><TD CLASS="l">2428</TD><TD>                                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2429</TD><TD>                                        if (enclosingElement == null)</TD></TR><TR CLASS="z"><TD CLASS="l">2430</TD><TD>                                                enclosingElement = createHandle(field, type, parent);</TD></TR><TR CLASS="z"><TD CLASS="l">2431</TD><TD>                                        if (encloses(enclosingElement)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2432</TD><TD>                                                for (int i = 0, l = nodes.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2433</TD><TD>                                                        ASTNode node = nodes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2434</TD><TD>                                                        Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);</TD></TR><TR CLASS="z"><TD CLASS="l">2435</TD><TD>                                                        IJavaScriptElement[] otherElements = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2436</TD><TD>                                                        if (otherFields != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2437</TD><TD>                                                                int length = otherFields.length;</TD></TR><TR CLASS="z"><TD CLASS="l">2438</TD><TD>                                                                int size = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">2439</TD><TD>                                                                while (size&lt;length &amp;&amp; otherFields[size] != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2440</TD><TD>                                                                        size++;</TD></TR><TR><TD CLASS="l">2441</TD><TD>                                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2442</TD><TD>                                                                otherElements = new IJavaScriptElement[size];</TD></TR><TR CLASS="z"><TD CLASS="l">2443</TD><TD>                                                                for (int j=0; j&lt;size; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2444</TD><TD>                                                                        otherElements[j] = createHandle(otherFields[j], type, parent);</TD></TR><TR><TD CLASS="l">2445</TD><TD>                                                                }</TD></TR><TR><TD CLASS="l">2446</TD><TD>                                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2447</TD><TD>                                                        this.patternLocator.matchReportReference(node, enclosingElement, null, otherElements, field.binding, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2448</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2449</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2450</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2451</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2452</TD><TD>                }</TD></TR><TR><TD CLASS="l">2453</TD><TD> </TD></TR><TR><TD CLASS="l">2454</TD><TD>                // Look in initializer</TD></TR><TR CLASS="z"><TD CLASS="l">2455</TD><TD>                int fieldEnd = field.endPart2Position == 0 ? field.declarationSourceEnd : field.endPart2Position;</TD></TR><TR CLASS="z"><TD CLASS="l">2456</TD><TD>                ASTNode[] nodes = nodeSet.matchingNodes(field.sourceStart, fieldEnd);</TD></TR><TR CLASS="z"><TD CLASS="l">2457</TD><TD>                if (nodes != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2458</TD><TD>                        if ((this.matchContainer &amp; PatternLocator.FIELD_CONTAINER) == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2459</TD><TD>                                for (int i = 0, l = nodes.length; i &lt; l; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">2460</TD><TD>                                        nodeSet.matchingNodes.removeKey(nodes[i]);</TD></TR><TR><TD CLASS="l">2461</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2462</TD><TD>                                if (enclosingElement == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2463</TD><TD>                                        enclosingElement = createHandle(field, type, parent);</TD></TR><TR><TD CLASS="l">2464</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2465</TD><TD>                                if (encloses(enclosingElement)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2466</TD><TD>                                        for (int i = 0, l = nodes.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2467</TD><TD>                                                ASTNode node = nodes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2468</TD><TD>                                                Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);</TD></TR><TR CLASS="z"><TD CLASS="l">2469</TD><TD>                                                if (node instanceof TypeDeclaration) {</TD></TR><TR><TD CLASS="l">2470</TD><TD>                                                        // use field declaration to report match (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=88174)</TD></TR><TR CLASS="z"><TD CLASS="l">2471</TD><TD>                                                        AllocationExpression allocation = ((TypeDeclaration)node).allocation;</TD></TR><TR CLASS="z"><TD CLASS="l">2472</TD><TD>                                                        if (allocation != null &amp;&amp; allocation.enumConstant != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2473</TD><TD>                                                                node = field;</TD></TR><TR><TD CLASS="l">2474</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2475</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2476</TD><TD>                                                // Set block scope for initializer in case there would have other local and other elements to report</TD></TR><TR CLASS="z"><TD CLASS="l">2477</TD><TD>                                                BlockScope blockScope = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2478</TD><TD>                                                if (field.getKind() == AbstractVariableDeclaration.INITIALIZER) {</TD></TR><TR CLASS="z"><TD CLASS="l">2479</TD><TD>                                                        Block block = ((Initializer)field).block;</TD></TR><TR CLASS="z"><TD CLASS="l">2480</TD><TD>                                                        if (block != null) blockScope = block.scope;</TD></TR><TR><TD CLASS="l">2481</TD><TD>                                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2482</TD><TD>                                                this.patternLocator.matchReportReference(node, enclosingElement, field.binding, blockScope, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2483</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2484</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2485</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2486</TD><TD>                }</TD></TR><TR><TD CLASS="l">2487</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="42">2488</A></TD><TD>}</TD></TR><TR><TD CLASS="l">2489</TD><TD> </TD></TR><TR><TD CLASS="l">2490</TD><TD> </TD></TR><TR><TD CLASS="l">2491</TD><TD>protected void reportMatching(InferredAttribute field,   InferredType type, IJavaScriptElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">2492</TD><TD>        IJavaScriptElement enclosingElement = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2493</TD><TD>        if (accuracy &gt; -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">2494</TD><TD>                enclosingElement = createHandle(field, type, parent);</TD></TR><TR CLASS="z"><TD CLASS="l">2495</TD><TD>                if (encloses(enclosingElement)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2496</TD><TD>                        int offset = field.sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">2497</TD><TD>                        SearchMatch match = newDeclarationMatch(enclosingElement, field.binding, accuracy, offset, field.sourceEnd-offset+1);</TD></TR><TR CLASS="z"><TD CLASS="l">2498</TD><TD>                        report(match);</TD></TR><TR><TD CLASS="l">2499</TD><TD>                }</TD></TR><TR><TD CLASS="l">2500</TD><TD>        }</TD></TR><TR><TD CLASS="l">2501</TD><TD> </TD></TR><TR><TD CLASS="l">2502</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="43">2503</A></TD><TD>}</TD></TR><TR><TD CLASS="l">2504</TD><TD> </TD></TR><TR><TD CLASS="l">2505</TD><TD>protected void reportMatching(InferredType type, IJavaScriptElement parent, int accuracy, MatchingNodeSet nodeSet, int occurrenceCount) throws CoreException {</TD></TR><TR><TD CLASS="l">2506</TD><TD>        // create type handle</TD></TR><TR CLASS="z"><TD CLASS="l">2507</TD><TD>        IJavaScriptElement enclosingElement = parent;</TD></TR><TR CLASS="z"><TD CLASS="l">2508</TD><TD>        if (enclosingElement == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2509</TD><TD>                enclosingElement = createTypeHandle(new String(type.getName()));</TD></TR><TR CLASS="z"><TD CLASS="l">2510</TD><TD>        } else if (enclosingElement instanceof IType) {</TD></TR><TR CLASS="z"><TD CLASS="l">2511</TD><TD>                enclosingElement = ((IType) parent).getType(new String(type.getName()));</TD></TR><TR CLASS="z"><TD CLASS="l">2512</TD><TD>        } else if (enclosingElement instanceof IMember) {</TD></TR><TR CLASS="z"><TD CLASS="l">2513</TD><TD>            IMember member = (IMember) parent;</TD></TR><TR CLASS="z"><TD CLASS="l">2514</TD><TD>                if (member.isBinary())  {</TD></TR><TR CLASS="z"><TD CLASS="l">2515</TD><TD>                        enclosingElement = ((IClassFile)this.currentPossibleMatch.openable).getType();</TD></TR><TR><TD CLASS="l">2516</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2517</TD><TD>                        enclosingElement = member.getType(new String(type.getName()), occurrenceCount);</TD></TR><TR><TD CLASS="l">2518</TD><TD>                }</TD></TR><TR><TD CLASS="l">2519</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2520</TD><TD>        if (enclosingElement == null) return;</TD></TR><TR CLASS="z"><TD CLASS="l">2521</TD><TD>        boolean enclosesElement = encloses(enclosingElement);</TD></TR><TR><TD CLASS="l">2522</TD><TD> </TD></TR><TR><TD CLASS="l">2523</TD><TD>        // report the type declaration</TD></TR><TR CLASS="z"><TD CLASS="l">2524</TD><TD>        if (accuracy &gt; -1 &amp;&amp; enclosesElement) {</TD></TR><TR CLASS="z"><TD CLASS="l">2525</TD><TD>                int offset = type.sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">2526</TD><TD>                SearchMatch match = this.patternLocator.newDeclarationMatch(type, enclosingElement, type.binding, accuracy, type.sourceEnd-offset+1, this);</TD></TR><TR CLASS="z"><TD CLASS="l">2527</TD><TD>                report(match);</TD></TR><TR><TD CLASS="l">2528</TD><TD>        }</TD></TR><TR><TD CLASS="l">2529</TD><TD> </TD></TR><TR><TD CLASS="l">2530</TD><TD>//        boolean matchedClassContainer = (this.matchContainer &amp; PatternLocator.CLASS_CONTAINER) != 0;</TD></TR><TR><TD CLASS="l">2531</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2532</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="41">2533</A></TD><TD> </TD></TR><TR><TD CLASS="l">2534</TD><TD> </TD></TR><TR><TD CLASS="l">2535</TD><TD>protected void reportMatching( IJavaScriptElement enclosingElement, int accuracy, MatchingNodeSet nodeSet, int occurrenceCount) throws CoreException {</TD></TR><TR><TD CLASS="l">2536</TD><TD>        // create type handle</TD></TR><TR CLASS="z"><TD CLASS="l">2537</TD><TD>        if (enclosingElement == null) return;</TD></TR><TR CLASS="z"><TD CLASS="l">2538</TD><TD>        boolean enclosesElement = encloses(enclosingElement);</TD></TR><TR><TD CLASS="l">2539</TD><TD> </TD></TR><TR><TD CLASS="l">2540</TD><TD>        // report the type declaration</TD></TR><TR CLASS="z"><TD CLASS="l">2541</TD><TD>        if (accuracy &gt; -1 &amp;&amp; enclosesElement) {</TD></TR><TR CLASS="z"><TD CLASS="l">2542</TD><TD>                int offset = 0;//element.g;</TD></TR><TR CLASS="z"><TD CLASS="l">2543</TD><TD>                int elementLength=0;</TD></TR><TR CLASS="z"><TD CLASS="l">2544</TD><TD>                SearchMatch match = this.patternLocator.newDeclarationMatch(null, enclosingElement, null, accuracy, elementLength, this);</TD></TR><TR CLASS="z"><TD CLASS="l">2545</TD><TD>                report(match);</TD></TR><TR><TD CLASS="l">2546</TD><TD>        }</TD></TR><TR><TD CLASS="l">2547</TD><TD> </TD></TR><TR><TD CLASS="l">2548</TD><TD>//        boolean matchedClassContainer = (this.matchContainer &amp; PatternLocator.CLASS_CONTAINER) != 0;</TD></TR><TR><TD CLASS="l">2549</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="44">2550</A></TD><TD>}</TD></TR><TR><TD CLASS="l">2551</TD><TD> </TD></TR><TR><TD CLASS="l">2552</TD><TD> </TD></TR><TR><TD CLASS="l">2553</TD><TD>protected void reportMatching(LocalDeclaration field, LocalDeclaration[] otherFields, TypeDeclaration type, IJavaScriptElement parent, int accuracy, boolean typeInHierarchy, MatchingNodeSet nodeSet) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">2554</TD><TD>        IJavaScriptElement enclosingElement = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2555</TD><TD>        if (accuracy &gt; -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">2556</TD><TD>                enclosingElement = createHandle(field,   parent);</TD></TR><TR CLASS="z"><TD CLASS="l">2557</TD><TD>                if (encloses(enclosingElement)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2558</TD><TD>                        int offset = field.sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">2559</TD><TD>                        SearchMatch match = newDeclarationMatch(enclosingElement, field.binding, accuracy, offset, field.sourceEnd-offset+1);</TD></TR><TR CLASS="z"><TD CLASS="l">2560</TD><TD>                        report(match);</TD></TR><TR><TD CLASS="l">2561</TD><TD>                }</TD></TR><TR><TD CLASS="l">2562</TD><TD>        }</TD></TR><TR><TD CLASS="l">2563</TD><TD> </TD></TR><TR><TD CLASS="l">2564</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2565</TD><TD>        if (typeInHierarchy) {</TD></TR><TR><TD CLASS="l">2566</TD><TD>                // Look in initializer</TD></TR><TR CLASS="z"><TD CLASS="l">2567</TD><TD>                ASTNode[] nodes = nodeSet.matchingNodes(field.sourceStart, field.declarationSourceEnd);</TD></TR><TR CLASS="z"><TD CLASS="l">2568</TD><TD>                if (nodes != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2569</TD><TD>                        if ((this.matchContainer &amp; PatternLocator.FIELD_CONTAINER) == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2570</TD><TD>                                for (int i = 0, l = nodes.length; i &lt; l; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">2571</TD><TD>                                        nodeSet.matchingNodes.removeKey(nodes[i]);</TD></TR><TR><TD CLASS="l">2572</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2573</TD><TD>                                if (enclosingElement == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2574</TD><TD>                                        enclosingElement = createHandle(field,  parent);</TD></TR><TR><TD CLASS="l">2575</TD><TD>                                }</TD></TR><TR CLASS="z"><TD CLASS="l">2576</TD><TD>                                if (encloses(enclosingElement)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2577</TD><TD>                                        for (int i = 0, l = nodes.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2578</TD><TD>                                                ASTNode node = nodes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2579</TD><TD>                                                Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);</TD></TR><TR CLASS="z"><TD CLASS="l">2580</TD><TD>                                                if (node instanceof TypeDeclaration) {</TD></TR><TR><TD CLASS="l">2581</TD><TD>                                                        // use field declaration to report match (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=88174)</TD></TR><TR CLASS="z"><TD CLASS="l">2582</TD><TD>                                                        AllocationExpression allocation = ((TypeDeclaration)node).allocation;</TD></TR><TR CLASS="z"><TD CLASS="l">2583</TD><TD>                                                        if (allocation != null &amp;&amp; allocation.enumConstant != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2584</TD><TD>                                                                node = field;</TD></TR><TR><TD CLASS="l">2585</TD><TD>                                                        }</TD></TR><TR><TD CLASS="l">2586</TD><TD>                                                }</TD></TR><TR><TD CLASS="l">2587</TD><TD>                                                // Set block scope for initializer in case there would have other local and other elements to report</TD></TR><TR CLASS="z"><TD CLASS="l">2588</TD><TD>                                                BlockScope blockScope = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2589</TD><TD>                                                this.patternLocator.matchReportReference(node, enclosingElement, field.binding, blockScope, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2590</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2591</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2592</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2593</TD><TD>                }</TD></TR><TR><TD CLASS="l">2594</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2595</TD><TD>}</TD></TR><TR><TD CLASS="l">2596</TD><TD> </TD></TR><TR><TD CLASS="l">2597</TD><TD> </TD></TR><TR><TD CLASS="l">2598</TD><TD>/**</TD></TR><TR><TD CLASS="l">2599</TD><TD> * Visit the given type declaration and report the nodes that match exactly the</TD></TR><TR><TD CLASS="l"><A NAME="46">2600</A></TD><TD> * search pattern (ie. the ones in the matching nodes set)</TD></TR><TR><TD CLASS="l">2601</TD><TD> */</TD></TR><TR><TD CLASS="l">2602</TD><TD>protected void reportMatching(TypeDeclaration type, IJavaScriptElement parent, int accuracy, MatchingNodeSet nodeSet, int occurrenceCount) throws CoreException {</TD></TR><TR><TD CLASS="l">2603</TD><TD>        // create type handle</TD></TR><TR CLASS="z"><TD CLASS="l">2604</TD><TD>        IJavaScriptElement enclosingElement = parent;</TD></TR><TR CLASS="z"><TD CLASS="l">2605</TD><TD>        if (enclosingElement == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2606</TD><TD>                enclosingElement = createTypeHandle(new String(type.name));</TD></TR><TR CLASS="z"><TD CLASS="l">2607</TD><TD>        } else if (enclosingElement instanceof IType) {</TD></TR><TR CLASS="z"><TD CLASS="l">2608</TD><TD>                enclosingElement = ((IType) parent).getType(new String(type.name));</TD></TR><TR CLASS="z"><TD CLASS="l">2609</TD><TD>        } else if (enclosingElement instanceof IMember) {</TD></TR><TR CLASS="z"><TD CLASS="l">2610</TD><TD>            IMember member = (IMember) parent;</TD></TR><TR CLASS="z"><TD CLASS="l">2611</TD><TD>                if (member.isBinary())  {</TD></TR><TR CLASS="z"><TD CLASS="l">2612</TD><TD>                        enclosingElement = ((IClassFile)this.currentPossibleMatch.openable).getType();</TD></TR><TR><TD CLASS="l">2613</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2614</TD><TD>                        enclosingElement = member.getType(new String(type.name), occurrenceCount);</TD></TR><TR><TD CLASS="l">2615</TD><TD>                }</TD></TR><TR><TD CLASS="l">2616</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2617</TD><TD>        if (enclosingElement == null) return;</TD></TR><TR CLASS="z"><TD CLASS="l">2618</TD><TD>        boolean enclosesElement = encloses(enclosingElement);</TD></TR><TR><TD CLASS="l">2619</TD><TD> </TD></TR><TR><TD CLASS="l">2620</TD><TD>        // report the type declaration</TD></TR><TR CLASS="z"><TD CLASS="l">2621</TD><TD>        if (accuracy &gt; -1 &amp;&amp; enclosesElement) {</TD></TR><TR CLASS="z"><TD CLASS="l">2622</TD><TD>                int offset = type.sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">2623</TD><TD>                SearchMatch match = this.patternLocator.newDeclarationMatch(type, enclosingElement, type.binding, accuracy, type.sourceEnd-offset+1, this);</TD></TR><TR CLASS="z"><TD CLASS="l">2624</TD><TD>                report(match);</TD></TR><TR><TD CLASS="l">2625</TD><TD>        }</TD></TR><TR><TD CLASS="l">2626</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2627</TD><TD>        boolean matchedClassContainer = (this.matchContainer &amp; PatternLocator.CLASS_CONTAINER) != 0;</TD></TR><TR><TD CLASS="l">2628</TD><TD> </TD></TR><TR><TD CLASS="l">2629</TD><TD>        // report the type parameters</TD></TR><TR CLASS="z"><TD CLASS="l">2630</TD><TD>        if (type.typeParameters != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2631</TD><TD>                reportMatching(type.typeParameters, enclosingElement, parent, type.binding, nodeSet);</TD></TR><TR><TD CLASS="l">2632</TD><TD>        }</TD></TR><TR><TD CLASS="l">2633</TD><TD> </TD></TR><TR><TD CLASS="l">2634</TD><TD>        // report references in javadoc</TD></TR><TR CLASS="z"><TD CLASS="l">2635</TD><TD>        if (type.javadoc != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2636</TD><TD>                ASTNode[] nodes = nodeSet.matchingNodes(type.declarationSourceStart, type.sourceStart);</TD></TR><TR CLASS="z"><TD CLASS="l">2637</TD><TD>                if (nodes != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2638</TD><TD>                        if (!matchedClassContainer) {</TD></TR><TR CLASS="z"><TD CLASS="l">2639</TD><TD>                                for (int i = 0, l = nodes.length; i &lt; l; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">2640</TD><TD>                                        nodeSet.matchingNodes.removeKey(nodes[i]);</TD></TR><TR><TD CLASS="l">2641</TD><TD>                        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2642</TD><TD>                                for (int i = 0, l = nodes.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2643</TD><TD>                                        ASTNode node = nodes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2644</TD><TD>                                        Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);</TD></TR><TR CLASS="z"><TD CLASS="l">2645</TD><TD>                                        if (enclosesElement) {</TD></TR><TR CLASS="z"><TD CLASS="l">2646</TD><TD>                                                this.patternLocator.matchReportReference(node, enclosingElement, type.binding, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2647</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2648</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2649</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2650</TD><TD>                }</TD></TR><TR><TD CLASS="l">2651</TD><TD>        }</TD></TR><TR><TD CLASS="l">2652</TD><TD> </TD></TR><TR><TD CLASS="l">2653</TD><TD>        // super types</TD></TR><TR CLASS="z"><TD CLASS="l">2654</TD><TD>        if ((type.bits &amp; ASTNode.IsAnonymousType) != 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2655</TD><TD>                TypeReference superType =type.allocation.type;</TD></TR><TR CLASS="z"><TD CLASS="l">2656</TD><TD>                if (superType != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2657</TD><TD>                        Integer level = (Integer) nodeSet.matchingNodes.removeKey(superType);</TD></TR><TR CLASS="z"><TD CLASS="l">2658</TD><TD>                        if (level != null &amp;&amp; matchedClassContainer)</TD></TR><TR CLASS="z"><TD CLASS="l">2659</TD><TD>                                this.patternLocator.matchReportReference(superType, enclosingElement, type.binding, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2660</TD><TD>                }</TD></TR><TR><TD CLASS="l">2661</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2662</TD><TD>                TypeReference superClass = type.superclass;</TD></TR><TR CLASS="z"><TD CLASS="l">2663</TD><TD>                if (superClass != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2664</TD><TD>                        reportMatchingSuper(superClass, enclosingElement, type.binding, nodeSet, matchedClassContainer);</TD></TR><TR><TD CLASS="l">2665</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">2666</TD><TD>                TypeReference[] superInterfaces = type.superInterfaces;</TD></TR><TR CLASS="z"><TD CLASS="l">2667</TD><TD>                if (superInterfaces != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2668</TD><TD>                        for (int i = 0, l = superInterfaces.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2669</TD><TD>                                reportMatchingSuper(superInterfaces[i], enclosingElement, type.binding, nodeSet, matchedClassContainer);</TD></TR><TR><TD CLASS="l">2670</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2671</TD><TD>                }</TD></TR><TR><TD CLASS="l">2672</TD><TD>        }</TD></TR><TR><TD CLASS="l">2673</TD><TD> </TD></TR><TR><TD CLASS="l">2674</TD><TD>        // filter out element not in hierarchy scope</TD></TR><TR CLASS="z"><TD CLASS="l">2675</TD><TD>        boolean typeInHierarchy = type.binding == null || typeInHierarchy(type.binding);</TD></TR><TR CLASS="z"><TD CLASS="l">2676</TD><TD>        matchedClassContainer = matchedClassContainer &amp;&amp; typeInHierarchy;</TD></TR><TR><TD CLASS="l">2677</TD><TD> </TD></TR><TR><TD CLASS="l">2678</TD><TD>        // Visit fields</TD></TR><TR CLASS="z"><TD CLASS="l">2679</TD><TD>        FieldDeclaration[] fields = type.fields;</TD></TR><TR CLASS="z"><TD CLASS="l">2680</TD><TD>        if (fields != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2681</TD><TD>                if (nodeSet.matchingNodes.elementSize == 0) return;        // end as all matching nodes were reported</TD></TR><TR CLASS="z"><TD CLASS="l">2682</TD><TD>                FieldDeclaration[] otherFields = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2683</TD><TD>                int first = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2684</TD><TD>                int length = fields.length;</TD></TR><TR CLASS="z"><TD CLASS="l">2685</TD><TD>                for (int i = 0; i &lt; length; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2686</TD><TD>                        FieldDeclaration field = fields[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2687</TD><TD>                        boolean last = field.endPart2Position == 0 || field.declarationEnd == field.endPart2Position;</TD></TR><TR><TD CLASS="l">2688</TD><TD>                        // Store first index of multiple field declaration</TD></TR><TR CLASS="z"><TD CLASS="l">2689</TD><TD>                        if (!last) {</TD></TR><TR CLASS="z"><TD CLASS="l">2690</TD><TD>                                if (first == -1) {</TD></TR><TR CLASS="z"><TD CLASS="l">2691</TD><TD>                                        first = i;</TD></TR><TR><TD CLASS="l">2692</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2693</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2694</TD><TD>                        if (first &gt;= 0) {</TD></TR><TR><TD CLASS="l">2695</TD><TD>                                // Store all multiple fields but first one for other elements</TD></TR><TR CLASS="z"><TD CLASS="l">2696</TD><TD>                                if (i &gt; first) {</TD></TR><TR CLASS="z"><TD CLASS="l">2697</TD><TD>                                        if (otherFields == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2698</TD><TD>                                                otherFields = new FieldDeclaration[length-i];</TD></TR><TR><TD CLASS="l">2699</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2700</TD><TD>                                        otherFields[i-1-first] = field;</TD></TR><TR><TD CLASS="l">2701</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2702</TD><TD>                                // On last field, report match with all other elements</TD></TR><TR CLASS="z"><TD CLASS="l">2703</TD><TD>                                if (last) {</TD></TR><TR CLASS="z"><TD CLASS="l">2704</TD><TD>                                        for (int j=first; j&lt;=i; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2705</TD><TD>                                                Integer level = (Integer) nodeSet.matchingNodes.removeKey(fields[j]);</TD></TR><TR CLASS="z"><TD CLASS="l">2706</TD><TD>                                                int value = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2707</TD><TD>                                                reportMatching(fields[j], otherFields, type, enclosingElement, value, typeInHierarchy, nodeSet);</TD></TR><TR><TD CLASS="l">2708</TD><TD>                                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2709</TD><TD>                                        first = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2710</TD><TD>                                        otherFields = null;</TD></TR><TR><TD CLASS="l">2711</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2712</TD><TD>                        } else {</TD></TR><TR><TD CLASS="l">2713</TD><TD>                                // Single field, report normally</TD></TR><TR CLASS="z"><TD CLASS="l">2714</TD><TD>                                Integer level = (Integer) nodeSet.matchingNodes.removeKey(field);</TD></TR><TR CLASS="z"><TD CLASS="l">2715</TD><TD>                                int value = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2716</TD><TD>                                reportMatching(field, null, type, enclosingElement, value, typeInHierarchy, nodeSet);</TD></TR><TR><TD CLASS="l">2717</TD><TD>                        }</TD></TR><TR><TD CLASS="l">2718</TD><TD>                }</TD></TR><TR><TD CLASS="l">2719</TD><TD>        }</TD></TR><TR><TD CLASS="l">2720</TD><TD> </TD></TR><TR><TD CLASS="l">2721</TD><TD>        // Visit methods</TD></TR><TR CLASS="z"><TD CLASS="l">2722</TD><TD>        AbstractMethodDeclaration[] methods = type.methods;</TD></TR><TR CLASS="z"><TD CLASS="l">2723</TD><TD>        if (methods != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2724</TD><TD>                if (nodeSet.matchingNodes.elementSize == 0) return;        // end as all matching nodes were reported</TD></TR><TR CLASS="z"><TD CLASS="l">2725</TD><TD>                for (int i = 0, l = methods.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2726</TD><TD>                        AbstractMethodDeclaration method = methods[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2727</TD><TD>                        Integer level = (Integer) nodeSet.matchingNodes.removeKey(method);</TD></TR><TR CLASS="z"><TD CLASS="l">2728</TD><TD>                        int value = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2729</TD><TD>                        reportMatching(type, method, enclosingElement, value, typeInHierarchy, nodeSet);</TD></TR><TR><TD CLASS="l">2730</TD><TD>                }</TD></TR><TR><TD CLASS="l">2731</TD><TD>        }</TD></TR><TR><TD CLASS="l">2732</TD><TD> </TD></TR><TR><TD CLASS="l">2733</TD><TD>        // Visit types</TD></TR><TR CLASS="z"><TD CLASS="l">2734</TD><TD>        TypeDeclaration[] memberTypes = type.memberTypes;</TD></TR><TR CLASS="z"><TD CLASS="l">2735</TD><TD>        if (memberTypes != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2736</TD><TD>                for (int i = 0, l = memberTypes.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2737</TD><TD>                        if (nodeSet.matchingNodes.elementSize == 0) return;        // end as all matching nodes were reported</TD></TR><TR CLASS="z"><TD CLASS="l">2738</TD><TD>                        TypeDeclaration memberType = memberTypes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2739</TD><TD>                        Integer level = (Integer) nodeSet.matchingNodes.removeKey(memberType);</TD></TR><TR CLASS="z"><TD CLASS="l">2740</TD><TD>                        int value = (level != null &amp;&amp; matchedClassContainer) ? level.intValue() : -1;</TD></TR><TR CLASS="z"><TD CLASS="l">2741</TD><TD>                        reportMatching(memberType, enclosingElement, value, nodeSet, 1);</TD></TR><TR><TD CLASS="l">2742</TD><TD>                }</TD></TR><TR><TD CLASS="l">2743</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2744</TD><TD>}</TD></TR><TR><TD CLASS="l"><A NAME="47">2745</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">2746</TD><TD> * Report matches in type parameters.</TD></TR><TR><TD CLASS="l">2747</TD><TD> */</TD></TR><TR><TD CLASS="l">2748</TD><TD>protected void reportMatching(TypeParameter[] typeParameters, IJavaScriptElement enclosingElement, IJavaScriptElement parent, Binding binding, MatchingNodeSet nodeSet) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">2749</TD><TD>        if (typeParameters == null) return;</TD></TR><TR CLASS="z"><TD CLASS="l">2750</TD><TD>        for (int i=0, l=typeParameters.length; i&lt;l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2751</TD><TD>                TypeParameter typeParameter = typeParameters[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2752</TD><TD>                if (typeParameter != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2753</TD><TD>                        Integer level = (Integer) nodeSet.matchingNodes.removeKey(typeParameter);</TD></TR><TR CLASS="z"><TD CLASS="l">2754</TD><TD>                        if (level != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2755</TD><TD>                                if (level.intValue() &gt; -1 &amp;&amp; encloses(enclosingElement)) {</TD></TR><TR CLASS="z"><TD CLASS="l">2756</TD><TD>                                        int offset = typeParameter.sourceStart;</TD></TR><TR CLASS="z"><TD CLASS="l">2757</TD><TD>                                        SearchMatch match = this.patternLocator.newDeclarationMatch(typeParameter, enclosingElement, binding, level.intValue(), typeParameter.sourceEnd-offset+1, this);</TD></TR><TR CLASS="z"><TD CLASS="l">2758</TD><TD>                                        report(match);</TD></TR><TR><TD CLASS="l">2759</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2760</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2761</TD><TD>                        if (typeParameter.type != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2762</TD><TD>                                level = (Integer) nodeSet.matchingNodes.removeKey(typeParameter.type);</TD></TR><TR CLASS="z"><TD CLASS="l">2763</TD><TD>                                if (level != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2764</TD><TD>                                        IJavaScriptElement localElement = createHandle(typeParameter, enclosingElement);</TD></TR><TR CLASS="z"><TD CLASS="l">2765</TD><TD>                                        this.patternLocator.matchReportReference(typeParameter.type, enclosingElement, localElement, null, binding, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2766</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2767</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">2768</TD><TD>                        if (typeParameter.bounds != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2769</TD><TD>                                for (int j=0, b=typeParameter.bounds.length; j&lt;b; j++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2770</TD><TD>                                        level = (Integer) nodeSet.matchingNodes.removeKey(typeParameter.bounds[j]);</TD></TR><TR CLASS="z"><TD CLASS="l">2771</TD><TD>                                        if (level != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2772</TD><TD>                                                IJavaScriptElement localElement = createHandle(typeParameter, enclosingElement);</TD></TR><TR CLASS="z"><TD CLASS="l">2773</TD><TD>                                                this.patternLocator.matchReportReference(typeParameter.bounds[j], enclosingElement, localElement, null, binding, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2774</TD><TD>                                        }</TD></TR><TR><TD CLASS="l">2775</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2776</TD><TD>                        }</TD></TR><TR><TD CLASS="l"><A NAME="48">2777</A></TD><TD>                }</TD></TR><TR><TD CLASS="l">2778</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2779</TD><TD>}</TD></TR><TR><TD CLASS="l">2780</TD><TD>protected void reportMatchingSuper(TypeReference superReference, IJavaScriptElement enclosingElement, Binding elementBinding, MatchingNodeSet nodeSet, boolean matchedClassContainer) throws CoreException {</TD></TR><TR CLASS="z"><TD CLASS="l">2781</TD><TD>        ASTNode[] nodes = null;</TD></TR><TR CLASS="z"><TD CLASS="l">2782</TD><TD>        if (superReference instanceof ParameterizedSingleTypeReference || superReference instanceof ParameterizedQualifiedTypeReference) {</TD></TR><TR CLASS="z"><TD CLASS="l">2783</TD><TD>                long lastTypeArgumentInfo = findLastTypeArgumentInfo(superReference);</TD></TR><TR CLASS="z"><TD CLASS="l">2784</TD><TD>                nodes = nodeSet.matchingNodes(superReference.sourceStart, (int)lastTypeArgumentInfo);</TD></TR><TR><TD CLASS="l">2785</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2786</TD><TD>        if (nodes != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2787</TD><TD>                if ((this.matchContainer &amp; PatternLocator.CLASS_CONTAINER) == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">2788</TD><TD>                        for (int i = 0, l = nodes.length; i &lt; l; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">2789</TD><TD>                                nodeSet.matchingNodes.removeKey(nodes[i]);</TD></TR><TR><TD CLASS="l">2790</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2791</TD><TD>                        if (encloses(enclosingElement))</TD></TR><TR CLASS="z"><TD CLASS="l">2792</TD><TD>                                for (int i = 0, l = nodes.length; i &lt; l; i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">2793</TD><TD>                                        ASTNode node = nodes[i];</TD></TR><TR CLASS="z"><TD CLASS="l">2794</TD><TD>                                        Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);</TD></TR><TR CLASS="z"><TD CLASS="l">2795</TD><TD>                                        this.patternLocator.matchReportReference(node, enclosingElement, elementBinding, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2796</TD><TD>                                }</TD></TR><TR><TD CLASS="l">2797</TD><TD>                }</TD></TR><TR><TD CLASS="l">2798</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2799</TD><TD>                Integer level = (Integer) nodeSet.matchingNodes.removeKey(superReference);</TD></TR><TR CLASS="z"><TD CLASS="l">2800</TD><TD>                if (level != null &amp;&amp; matchedClassContainer)</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="4a">2801</A></TD><TD>                        this.patternLocator.matchReportReference(superReference, enclosingElement, elementBinding, level.intValue(), this);</TD></TR><TR><TD CLASS="l">2802</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2803</TD><TD>}</TD></TR><TR><TD CLASS="l">2804</TD><TD>protected boolean typeInHierarchy(ReferenceBinding binding) {</TD></TR><TR CLASS="z"><TD CLASS="l">2805</TD><TD>        if (this.hierarchyResolver == null) return true; // not a hierarchy scope</TD></TR><TR CLASS="z"><TD CLASS="l">2806</TD><TD>        if (this.hierarchyResolver.subOrSuperOfFocus(binding)) return true;</TD></TR><TR><TD CLASS="l">2807</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">2808</TD><TD>        if (this.allSuperTypeNames != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">2809</TD><TD>                char[][] compoundName = binding.compoundName;</TD></TR><TR CLASS="z"><TD CLASS="l">2810</TD><TD>                for (int i = 0, length = this.allSuperTypeNames.length; i &lt; length; i++)</TD></TR><TR CLASS="z"><TD CLASS="l">2811</TD><TD>                        if (CharOperation.equals(compoundName, this.allSuperTypeNames[i]))</TD></TR><TR CLASS="z"><TD CLASS="l">2812</TD><TD>                                return true;</TD></TR><TR><TD CLASS="l">2813</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">2814</TD><TD>        return false;</TD></TR><TR><TD CLASS="l"><A NAME="15">2815</A></TD><TD>}</TD></TR><TR><TD CLASS="l">2816</TD><TD> </TD></TR><TR><TD CLASS="l">2817</TD><TD>public CompilationUnitDeclaration doParse(ICompilationUnit unit, AccessRestriction accessRestriction) {</TD></TR><TR CLASS="z"><TD CLASS="l">2818</TD><TD>        CompilationResult unitResult =</TD></TR><TR CLASS="z"><TD CLASS="l">2819</TD><TD>                new CompilationResult(unit, 1, 1, this.options.maxProblemsPerUnit);</TD></TR><TR><TD CLASS="l">2820</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">2821</TD><TD>                Parser parser=basicParser();</TD></TR><TR CLASS="z"><TD CLASS="l">2822</TD><TD>                CompilationUnitDeclaration parsedUnit = parser.parse(unit, unitResult);</TD></TR><TR CLASS="z"><TD CLASS="l">2823</TD><TD>                parser.inferTypes(parsedUnit,this.options);</TD></TR><TR CLASS="z"><TD CLASS="l">2824</TD><TD>                return parsedUnit;</TD></TR><TR CLASS="z"><TD CLASS="l">2825</TD><TD>        } catch (AbortCompilationUnit e) {</TD></TR><TR><TD CLASS="l">2826</TD><TD>//                // at this point, currentCompilationUnitResult may not be sourceUnit, but some other</TD></TR><TR><TD CLASS="l">2827</TD><TD>//                // one requested further along to resolve sourceUnit.</TD></TR><TR><TD CLASS="l">2828</TD><TD>//                if (unitResult.compilationUnit == sourceUnit) { // only report once</TD></TR><TR><TD CLASS="l">2829</TD><TD>//                        requestor.acceptResult(unitResult.tagAsAccepted());</TD></TR><TR><TD CLASS="l">2830</TD><TD>//                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">2831</TD><TD>                        throw e; // want to abort enclosing request to compile</TD></TR><TR><TD CLASS="l">2832</TD><TD>//                }</TD></TR><TR><TD CLASS="l">2833</TD><TD>        }</TD></TR><TR><TD CLASS="l">2834</TD><TD> </TD></TR><TR><TD CLASS="l">2835</TD><TD>}</TD></TR><TR><TD CLASS="l">2836</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" CELLSPACING="0" WIDTH="100%"><TR><TD CLASS="nv">[<A HREF="../xslUnitTestCoverage.html">all classes</A>][<A HREF="12f.html">org.eclipse.wst.jsdt.internal.core.search.matching</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://www.eclemma.org/support.html">EMMA 2.0.5312 EclEmma Fix 1</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>